




JVM의 구조



JVM의 구성요소는 크게 3가지로 이루어져 있다.

클래스 로더(Class Loader)

메모리 (Jvm Memory)

실행 엔진 (Execution Engine)


하나하나 알아 보도록 하자.




1. 클래스 로더


JVM내로 클래스(.class파일)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. Runtime 시에 동적으로 클래스를 로드한다.



클래스 로더의 특징을 6가지로 나눌 수 있다.


1 - 계층구조

2 - 위임 원칙

3 - 가시범위 원칙(가시성 제한)

4 - 유일성의 원칙

5 - 언로드(Unload) 불가

6 - 이름공간(Name Space)






1-1. 계층 구조


클래스 로더는 단순하게 하나로 이루어져 있지 않다. 

여러 클래스 로더끼리 부모-자식 관계를 이루고 있어서 계층적인 구조로 되어 있다.


부트스트랩 클래스 로더 -> 익스텐션 클래스 로더 -> 시스템 클래스 로더 -> 사용자 정의 클래스 로더

클래스 로더는 위와 같은 형태를 이루고 있다.


코드를 구현하다 보면 중복을 줄이기 위해 상속을 사용하게 된다.

부모 Class를 가진 자식 Class처럼 ClassLoader도 계층적으로 생성이 가능하다.

부트스트랩(Bootstrap) ClassLoader가 확장(Extensions) ClassLoader를 가지고 있는 것처럼 말이다.


부모 클래스는 자식 클래스의 데이터를 사용할 수 없고 자식 클래스는 부모클래스의 데이터를 이용할 수 있는 것 처럼

클래스 로더의 계층 구조도 클래스와 같은 형식을 띈다.

부모 클래스 로더는 자식 클래스의 데이터(변수,메소드 등)을 사용할 수 없고

자식 클래스 로더는 부모 클래스 로더의 데이터를 사용할 수 있다.



1. 부트스트랩 클래스 로더(Bootstrap Class Loader)

- 최상위 클래스로더로 유일하게 JAVA가 아니라 *네이티브 코드로 구현이 되어있다.

- JVM이 실행될 때 같이 메모리에 올라간다.(JVM이 기동될 때 생성된다는 뜻)

- Object 클래스를 비롯하여 JAVA API들을 로드한다.


부트스트랩 클래스 로더는 JAVA8 기준으로 ${JAVA_HOME}/jre/lib에 위치한 

rt.jar 및 기타 핵심 라이브러리와 같은 JDK 내부 클래스를 로드하는 역할을 한다.

요점은 우리가 자바 프로그램을 돌리기 위해 다운 받은 여러 프로그램들(JDk,JRE 등)이 제공하는 클래스를

부트스트랩 클래스 로더가 로드하여 사용한다는 것이다.



*JRE란?

Java Runtime Environment의 약자로, 자바 실행 환경을 의미한다.

JVM을 동작하는데에 필요한 각종 자바 라이브러리를 담고 있다.



*네이티브 코드란?

CPU와 운영체제(OS)가 직접 실행할 수 있는 코드를 네이티브 코드라고 한다.

기계 코드는 "CPU"에서 바로 실행될 수 있는 코드를 의미하는데

지금의 환경은 OS에서 지원해주는 API가 너무나 큰 범위를 차지하기 때문에 "기계 코드"라는 용어는 잘 사용하지 않는다.

그래서 기계어 또는 OS를 직접 다룰 수 있는 코드를 묶어서 네이티브 코드라고 하는 듯 하다.

우리가 실행하는 거의 모든 프로그램(*.exe, *.dll, *.ocx...)이 바로 네이티브 코드라고 할 수 있다.



2. 익스텐션 클래스 로더(Extension Class Loader)

- 기본 JAVA API를 제외한 확장 클래스들을 로드한다. (다양한 보안 확장기능 로드)

java.ext.dirs 환경 변수에 설정된 디렉토리의 클래스 파일을 로드하고 

이 값이 설정되어 있지 않은 경우 ${JAVA_HOME}/jre/lib/ext에 있는 클래스 파일을 로드한다.

*java9 부터는 뭐가 바뀌었다고 하는데 그건 나중에 알아 보자.



3. 시스템 클래스 로더(System Class Loader)

- 부트스트랩과 익스텐션 클래스로더(상위 클래스 로더들)가 JVM 자체의 구성요소들을 로드한다면 

시스템 클래스 로더는 어플리케이션의 클래스들을 로드한다. 

자바 프로그램 실행 시 지정한 Classpath에 있는 클래스 파일 혹은 Jar에 속한 클래스들을 로드한다.



4. 사용자 정의 클래스 로더(User-Defined Class Loader)

- 어플리케이션 사용자가 직접 코드상에서 생성하여 사용하는 클래스 로더.

사용자가 직접 클래스 로더를 만들어 사용할 수 있다는 뜻이다.

내장 클래스 로더(위의 3가지)는 파일이 이미 파일 시스템에 있는 경우에 대부분 충분히 사용할 수 있다.

그러나 로컬 하드 드라이브나 네트워크에서 클래스를 로드해야 하는 시나리오에서는 사용자 지정 클래스 로더를 사용해야 할 수도 있다.

커스텀 클래스를 만드는 법은 ClassLoader를 상속받고 findClass() 메소드를 Override 하면 된다.




지금부터 나오는 1-2 ~ 1-4는 클래스 로더가 지켜야 할 3가지 원칙에 포함된다.

1-2. 위임 원칙


클래스 로더는 상위 클래스 로더에 필요한 클래스 정보가 있으면 로드를 위임, 없으면 로드를 요청받은 자신이 로드하는 구조이다.

만약 하위 클래스 로더가 어떤 클래스를 로드하도록 요청 받으면 먼저 부모 클래스 로더에게 그것을 위임한다.

그럼 부모클래스 로더도 자신의 부모 클래스 로더 즉 부트스트랩 클래스 로더에 도달할 때 까지 이 과정이 반복된다.

그리고 부트스트랩 클래스 로더부터 자신이 담당하는 classpath(JDK/JRE/LIB)에 해당 클래스가 있는 지 확인하고

없으면 자식 클래스에게 요청을 수행하도록 한다. 그럼 자식 클래스는 자신의 Classpath(JDK/JRE/LIB/EXT)에서 클래스를 찾는다.

이런 식으로 클래스가 나올 때까지 찾는 과정이다. 


그리고 클래스 로드를 할 때에 위의 과정 전에 한 가지 먼저 확인하는 게 있다 바로 캐시이다.

캐시에서는 클래스를 로딩한 적이 있는 지 확인한다. 

이전에 로딩된 클래스는 해당 클래스 로더의 캐시에 저장되고 다음 번 요청 시 캐시에 저장된 내용을 사용한다.

만약 로드된 적이 없다면 위의 찾는 과정을 거치는 것이다. 


한 마디로 클래스 로드하는 순서는

캐시 -> 하위 클래스 로더에 요청 -> 상위 클래스 로더에 위임 -> 상위 클래스 로더 -> 하위 클래스 로더 

만약 저렇게 했는데 못 찾았다면 요청받은 클래스 로더가 파일 시스템 자체에서 해당 클래스를 찾는것으로 마무리 된다.

그래도 없으면 오류가 발생하고.


결론)

클래스가 로딩되는 과정

1. 이전에 로드된 클래스인지 클래스 로더 캐시를 확인한다.

2. 캐시에 없다면 최상위 클래스 로더까지 위임하며 올라간 후 내려오면서 찾는다.

3. 요청을 받은 클래스 로더가 마지막으로 파일 시스템에서 찾고 찾지 못한다면 ClassNotFoundException을 발생시킨다.




1-3 Visibility Principle(가시범위 원칙)


가시범위 원칙은 하위 클래스 로더는 상위 클래스 로더가 로드한 클래스를 볼 수 있지만, 

반대로 상위 클래스로더는 하위 클래스로더가 로드한 클래스를 알 수 없다는 것이다.

위의 계층 구조를 배울 때 나온 내용이다. 

부모 클래스 로더는 확장 클래스 로더로 하위 클래스 로더를 갖는다.

그리고 이것은 클래스와 같은 특성을 지닌다고 했다.

때문에 java.lang.Object 클래스 등 상위 클래스 로더에서 로드한 클래스도 

하위 클래스로더인 애플리케이션 클래스 로더 등에서 사용할 수 있는 것이다. 

이러한 원칙이 없는 경우 클래스 로더 간의 상/하위 개념이 사라지기 때문에 이 원칙은 반드시 지켜져야 한다.

곧 나올 내용이지만 애플리케이션 클래스 로더가 사용자들이 만든 프로그램의 클래스를 로드하기 위해 필요한 클래스들이 있는데

그것들은 상위 클래스에 의해 로드된다. 즉 상위 클래스 로더가 로드한 클래스를 사용한 것이다.

하지만 그 반대는 불가하다는 것이다.




1-4 Uniqueness Principle(유일성의 원칙)

유일성의 원칙은 하위 클래스로더가 상위 클래스로더에서 로드한 클래스를 다시 로드하지 않아야 한다는 원칙이다. 

이 원칙이 지켜지지 않는다면 JVM에 동일한 클래스가 2개 이상 로드되는 상황이 발생할 수 있다.


loadClass의 동작과 클래스 로더의 세가지 원칙

위 클래스 로더의 3가지 원칙들은 java.lang.ClassLoader의 loadClass 메서드에 포함되어 있다.




1-5 언로드 불가

언로드 불가 역시 간단한 개념으로 말 그대로 클래스를 로드하는 것은 가능하지만 

반대로 언로드(Unload)하는 것은 불가능하다는 특성이다.

클래스 로더에 의해 로딩된 클래스들은 다시 JVM상에서 없다는 뜻이다. 

그렇기에 언로딩(Unloading)을 하기 위해선 ClassLoader 자체를 삭제하고, ClassLoader을 다시 생성하는 방법이 있다.




1-6 Name Space(네임 스페이스)

네임 스페이스란 각 클래스 로더들이 가지고 있는 공간으로써 로드된 클래스를 보관하는 공간이다.

클래스를 로드할 때 위임 모델을 통해서 상위 클래스 로더들을 확인하는데 그 때 확인하는 공간이 바로 네임 스페이스이다. 

네임 스페이스에는 FQCN(Fully Qualified Class Name)을 기준으로 보관되는데 FQCN이란 패키지명까지 포함되어 있는 식별자를 뜻한다. 

각각의 클래스 로더가 각자 네임 스페이스를 가지고 있기 때문에 패키지명까지 같은 

즉, FQCN이 같은 클래스라도 네임스페이스가 다르면(다른 클래스 로더가 로드한 클래스이면) 다른 클래스로 간주하는 것이다.

(이 특성을 이용하여 로드한 클래스 로더를 제거하면 마치 언로드한 것과 같은 효과를 줄 수 있다고 한다.)


뭐 쉽게 말하면 각 클래스 로더들은 클래스가 로드될 때 클래스에게 각자 네임 스페이스 할당하는 것 같다. 

그래서 나중에 똑같은 FQCN을 가진 클래스가 나타나도 네임 스페이스가 다르기 때문에 구분이 되는 것이다.



클래스 로더의 구조에 대해 알아 보았다. 위는 클래스가 로드되는 과정 중 로딩의 과정이다.

하지만 클래스가 클래스 로더에 의해 메모리상에 올려지기 까지는 아직 두 가지 과정이 더 있다.

바로 링크와 초기화이다.



링크란

로딩이 클래스 파일에서 클래스 이름, 상속관계, 클래스의 타입(class, interface, enum) 정보,

메소드 & 생성자 & 멤버변수 정보, 상수 등에 대한 정보를 로딩해서 Binary 데이터로 변경하는 과정이었다면

링크는 Verification(검증) 과 Preparation(준비), Resolution(분석) 단계를 거치며 바이트 코드를 검증하고 필요한 만큼의 메모리를 할당한다. 


검증 : 클래스 로드의 모든 과정 중에서 가장 복잡하고 시간이 많이 걸리는 과정으로 

읽어들인 클래스가 자바 언어 명세(JAVA Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.


준비 : 클래스(로딩으로 변환된 바이너리 데이터들)가 필요로 하는 메모리를 할당하고 

클래스에서 정의된 필드, 메소드, 인터페이스를 나타내는 데이터 구조를 준비한다. 



분석(Resolve) : 클래스의 상수 풀 내 모든 *심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.


*symbolic references란 클래스 파일 내에서 참조되는 대상의 이름만을 지칭한 것. 

클래스 파일에는 constant pool(상수 풀)이 존재하는데 그 곳에는 symbolic references가 담긴다. 

즉, 클래스 파일내에서 사용(참조)되는 모든 다른 클래스 파일에 대한 이름, 그 클래스 파일 안의 변수 이름, 메소드,인터페이스 등등의 

정보를 기억하기 위해 그것들의 symbolic references, '이름'을 constant pool에 저장해 놓는 것이다.



Constant pool(상수 풀)


클래스 파일은 모든 symbolic references를 constant pool에 저장한다.

Class 파일이 JVM에 올라가게 되면 Symbolic Reference는 그 이름에 맞는 객체의 주소를 찾아서 연결하는 작업을 수행한다.

이 과정이 바로 링크의 분석(Resolve) 과정이다. 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 실제 메모리 레퍼런스로 교체하는 것.

그리고 그렇게 변경된 레퍼런스 값은 런타임 상수 풀에 저장되는 것이다. 런타임 상수 풀은 상수 풀을 맵핑(대응)한 것이다. 

한 마디로 현재 런타임 중에 사용된 모든 클래스 파일은 링크 과정에서 그 클래스 파일들의 constant pool에 저장된 정보가 불려와지고

symbolic references들이 실제 메모리 주소값(direct reference)으로 변환된 후 런타임 상수 풀에 저장되는 것이다.

JVM은 Runtime Constant Pool을 통해 해당 메소드나 필드의 실제 메모리 상 주소를 찾아 참조한다.


이 과정은 환경에 따라 구동하기도 하지 않기도 한다고 한다.



초기화란

초기화 클래스 변수들을 적절한 값으로 초기화 한다. 즉, static 필드들이 설정된 값으로 초기화한다.

잘 이해는 안 되는데 대충 예상을 하자면 클래스 내에 static 변수가 있다면 이 변수는 클래스의 로드와 상관없이 

프로그램 생성 즉시 메모리에 저장되기 때문에 아마 이 클래스가 호출되기 전에 사용된 적이 있을 수도 있다. 

그리고 그 값이 바뀌었을 수도 있고. 

하지만 클래스 로드를 하면 있는 그대로 값을 불러오기 때문에 바뀐 값이 아닌 소스코드에 있는 값을 그대로 초기화하겠지

하지만 이 과정에서 변경된 static필드의 데이터 값들을 변경된 값에 맞게 초기화 해 주는 과정이 아닐까 싶다.



클래스 로더에 대해서 알아 보았으니 다음은 JVM의 메모리 영역에 대해 알아 보자