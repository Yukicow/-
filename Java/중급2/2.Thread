



1. 스레드


스레드에 대해서는 c언어를 공부할 때에 다룬 적이 있다.

거기에서는 물리 스레드와 논리 스레드의 개념, 프로세스의 개념 등을 다뤘다면

여기서는 그 지식을 바탕으로 java가 멀티 스레드를 구현하는 방법에 대해 다뤄보도록 하겠다.


먼저 여기서 스레드라고 한다면 논리 스레드에 해당할 것이다.

프로세스 내에서의 명렁어 블록이며 시작점과 종료점을 갖는다. 

실행 중에 멈출 수도 있으며 동시에 수행이 가능하다.

줄여서 프로그램(프로세스) 내에서 실행되는 작업 흐름의 단위라고 할 수 있겠다.

java는 프로세스라는 개념이 없고 모두 스레드 단위이다.


멀티 스레드란 위의 여러 작업(스레드)이 동시에 일어나는 것을 말한다.

먼저 하나의 프로세스는 기본적으로 하나, main스레드에 해당하는 작업이 수행된다.

하지만 우리는 스레드를 생성해서 여러 작업을 동시에 수행하도록 할 수 있다. 

그럴 경우 멀티 스레드가 되는 것이다.

멀티 스레드 작업은 병렬적으로 일어날 수도 병행적으로 일어날 수도 있다.


java에서는 이런 멀티 스레드, 즉, 작업을 동시에 일어나게 하는 방법은 

Thread 클래스를 상속 받거나 Runnable 인터페이스를 구현해서 Thread 클래스를 만드는 것이다.

Thread 클래스의 가장 중요한 점은 Runnable인터페이스의 run 메소드의 유무이다.

따라서 원래 존재하는 Thread 클래스를 이용해도 되고 Runnable 인터페이스를 상속받은

새로운 Thread 클래스를 구현할 수도 있는 것이다.


Thread 클래스를 만들었다면 우리가 멀티 스레딩할 클래스를 만들고 Thread 클래스를 상속시킨다.

그리고 그 안에 run() 메소드를 오버라이딩 하여 수행할 로직을 안에 작성하면 된다.


위의 과정이 모두 끝났다면 이제 스레드의 로직을 실행히시키면 된다.

바로 생성한 객체를 이용해 start() 메소드를 사용하는 것이다.

그럼 run()에 작성한 로직이 멀티 스레드 방식으로 구동한다.

main 스레드의 작업이 진행되면서 run에 정의된 로직도 동시에 수행이 이루어진다.

이 때 main 스레드의 작업이 Thread 객체의 로직이 끝난 다음 수행하길 원한다면

join()메소드를 이용할 수 있다.

join() 메소드를 사용하면 join() 메소드를 사용한 객체의 작업이 끝날 때 까지 대기한다.

그리고 그 객체의 작업이 끝나면 그 이후에 이어서 작업을 수행한다.



스레드의 특징


1. run()메소드가 종료하면 스레드는 종료된다.

- 스레드를 계속 실행시킬려면 run()메소드를 무한루프 속에 실행되어야 한다.


2. 한번 종료한 스레드는 다시 시작시킬수 없다.

- 스레드 객체를 다시 생성해야 한다.


3. 한 스레드에서 다른 스레드를 강제 종료할 수 있다.




스레드에는 두 가지 방식이 존재한다.

하나의 객체가 n개의 스레드를 공유하는 경우, 그리고 하나의 객체가 하나의 스레드를 사용하는 경우이다.

위의 경우는 Thread객체를 Runnable 인터페이스를 상속 받는 객체를 이용해서 만들 때에만 발생한다.

Thread 자체를 상속 받는 경우에는 일어날 수 없다. 그 이유는 이해하고 나면 알 것이다.

어려운 내용은 아니지만 말이 좀 길어질 수 있으니 잘 읽어 보도록 하자.


먼저 첫 번째 하나의 객체가 n개의 스레드를 공유하는 경우이다.

Runnable 인터페이스를 상속 받는 ThreadTest 라는 객체를 만들었다고 해 보자.

Thread()의 생성자에 인자로 ThreadTest의 객체를 넘겨 주는 방식으로 Thread 클래스의 객체를 만들 수 있다.

ThreadTest threadtest1 = new ThreadTest() 이처럼 ThreadTest 객체를 하나 만들었다.

그리고 Tread thread1 = new Tread(threadtest1, "One") 를 통해 threadtest1를 인자로 보내 Tread 객체를 하나 만들었다.

이렇게 되면 start() 메소드를 사용할 때 ThreadTest의 run() 메소드를 사용하는 Tread 객체가 되는 것이다.

# "One"은 thread1의 이름이 된다. 이름을 지정하지 않으면 0,1,2,3 순으로 이름이 매겨진다.


여기서 우리가 thread1.start()를 실행하면 threadtest1에 정의된 run() 메소드 로직이 잘 실행될 것이다.

근데 이 때 내가 Thread thread2 = new Thread(threadtest1, "Two") 를 통해 새로운 Thread 객체를 만들었다

그리고 thread1.start(), thread2.start()로 동시에 스레드를 실행 시켰다.

그럼 여기서 어떤 일이 발생했는가. 바로 두 스레드가 같은 객체를 이용하는 일이 발생한 것이다.

new Thread()의 인자로 같은 객체 threadtest1를 넘겼기 때문이다. 

그러니 실행되는 로직도 같은 객체의 로직이 실행되는 것이다.

이런 경우를 바로 하나의 객체가 여러 스레드를 공유하는 경우라고 하는 것이다.

예를 들어 run() 메소드에 threadtest1에 정의된 변수의 값을 1 증가시키는 명령어가 있다고 해 보자.

만약 위처럼 두 스레드를 동시에 실행한다면 값은 2가 증가할 것이다.

하나의 객체를 두고 각 스레드별로 한 번씩, 총 두 번의 run() 메소드 호출이 있었기 때문이다.


위가 첫 번째 경우이고 두 번째 경우는 아주 간단하다.

threadtest1을 두 Thread 객체가 공유하는 것이 아니고 각각의 Thread 객체를 위한

ThreadTest 객체를 만들어 주어 인자로 넘기는 것이다.

ThreadTest threadtest1 = new ThreadTest(), ThreadTest threadtest2 = new ThreadTest()

Tread thread1 = new Tread(threadtest1, "One"), Tread thread2 = new Tread(threadtest2, "Two")

위의 예제처럼 Tread 객체 하나당 인자로 넘길 ThreadTest 객체를 하나씩 생성하면

하나의 Thread 객체가 하나의 스레드를 가질 수 있다.



첫 번째 경우는 데이터가 종종 엉키는 경우가 있을 수 있다.

위의 예제를 예시로 로직이 실행될 때 마다 변수값에 1을 증가시키는 로직에서 값이 5가 될 때까지로 제한했다고 해 보자. 

둘이 동시에 일어나다 보니 한 쪽이 1을 올려서 5가 됐는데 그것과 거의 완벽하게 동시에 다른 한 쪽도 1을 올려서 

한 쪽의 결과가 반영이 안 된 상태로 나머지 쪽도 1을 올려 버리면 최대값 5를 넘어 6이 변수에 담길 것이다.

위와 같은 경우를 막기 위해 java에는 synchronized라는 것이 있다.

synchronized는 이런 경우에만 국한되는 내용이 아니기 때문에 다음 장에서 다루도록 하겠다.





2. Deamon Thread


데몬 스레드는 다른 모든 스레드가 종료되기 전까지 절대 종료되지 않는 낮은 우선 순위 스레드이다.

JAM은 데몬 스레드가 구동하는 지는 관심이 없다. 사용자 애플리케이션이 종료될 때 

모든 스레드가 끝나야만 JVM프로세스가 종료한다. 하지만 JVM은 데몬스레드의 종료는 기다리지 않는다.

데몬 스레드가 아직 구동 중이라면 강제로 종료시켜 버린다.

보통 다른 스레드를 보조하는 역할로 사용된다. 데몬 스레드의 대표적인 예로 가비지 컬렉터가 있다.


새로 생성되는 스레드는 항상 부모 스레드의 속성을 상속받는다. 

데몬 스레드라는 특성도 마찬가지라서 일반 스레드에서 생성된 스레드는 일반 스레드이고 

데몬 스레드에서 생성된 스레드는 데몬 스레드의 특성을 갖는다. 

JVM이 실행되어 사용자 애플리케이션 로직을 실행하는 메인 스레드는 항상 일반 스레드로 생성된다. 

따라서 메인 스레드에서 생성되는 스레드는 기본적으로 일반 스레드로 생성된다.

그래서 우리가 일반적으로 스레드를 만들면 setDeamon()이 Flase로 되어 있다.

그렇기 때문에 데몬 스레드로 만들어 주기 위해 인자로 true를 넘기는 것이다. 

# 반대로 말하면 false를 넣어 주면 일반 스레드로 만들 수 있다.


데몬 스레드 사용 방법은 아주 간단하다.

스레드의 start() 메소드를 호출하기 전에 setDeamon(true)를 선언하는 것이다. # 후에 선언하면 오류남

어떤 스레드이건 데몬 스레드로 사용할 스레드를 setDeamon(true)로 선언하면 데몬 스레드가 된다.




3. 우선 순위

2개 이상의 스레드가 동작 중일 때 우선 순위를 부여하여 우선 순위가 높은 스레드에게 실행의 우선권을 부여할 수 있다.

참고로 main()스레드의 우선 순위 값은 초기값이 5이다.


java는 우선 순위를 지정하기 위한 상수를 제공한다.

- static final int MAX_PRIORITY : 우선순위 10 - 가장 높은 우선 순위

- static final int MIN_PRIORITY  :  우선순위 1 - 가장 낮은 우선 순위

- static final int NORM_PRIORITY : 우선순위 5 - 보통의 우선 순위


상수 말고 우리가 직접 지정해서 사용할 수도 있다.

- void setPriority(int priority)

- int getPriority()


JVM의 스케쥴링 규칙

- 철저한 우선 순위 기반

- 가장 높은 우선 순위의 스레드가 우선적으로 스케쥴링

- 동일한 우선 순위의 스레드는 돌아가면서 스케쥴링(*라운드 로빈)


*라운드 로빈 스케줄링은 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서 

프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘이다.

쉽게 말해서 그냥 시간 단위로 공평하게 병렬처리 한다는 것이다.

