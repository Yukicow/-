





지역변수와 전역변수 개념은 전에도 많이 공부했지만 부족한 부분을 더 공부해 보자.


알고 있겠지만 클래스,함수,반복문,조건문 등등 {}로 둘러 쌓이는 이 친구들은 각자 영역을 갖는다.

그리고 당연하게도 그 영역 안에서 선언되는 모든 변수들은 지역변수가 된다.

전역변수라는 개념도 사실 어떻게 보면 지역변수일 수도 있는 것이다.

다만 어떤 지역의 상위에 선언된 변수라서 범위가 더 넓어 

그 변수가 선언된 {}영역 안의 다른 {}영역에서도 사용될 수 있는 것이다.


한 마디로 상대적인 개념이라는 것이다. 그 변수의 영역에서 더 넓은 공간을 보면 지역변수이지만

자신이 포함된 지역에 있는 다른 지역들의 입장에서는 그 변수는 전역변수인 것이다.

하지만 일반적으로는 클래스의 멤버 변수를 전역변수라고 칭한다.

왜냐면 클래스 내에서는 어디서든 사용 가능하기 때문이다. 특히 이 때 static을 사용하면 더욱 전역변수 다워진다.

메모리상에 고정되기 때문에 클래스.변수이름 으로 호출하면 객체를 만들지 않아도 어디서든지 그 값에 접근할 수 있기 때문이다.

심지어 클래스와 변수 모두 public으로까지 선언됐다면 같은 디렉토리 또는 다른 패키지에서 그 패키지를 임포트한 경우에

진짜 혼모노로 맘대로 사용할 수 있다. 이 정도면 전역변수가 아니고 글로벌 변수다. # 글로벌 나쁜놈

메소드도 위와 같은 형식을 따른다.


하여튼 중요한 것은 이 선언이라는 개념이다.

이름이 같아도 영역이 다르다면 서로 다른 변수로 본다.

근데 이게 그렇게 작동하려면 그 영역 내에서 변수를 새롭게 선언했을 때의 이야기이다.


예제를 보자.


public class Ex{

    int Ex1 = 0;

    public Ex(){

        Ex1 = 50;
    }
}

Ex exaple = new Ex();

System.out.println(example.Ex1);


위의 예제에서 example.Ex1의 출력 값은 몇일까?

정답은 50이다.


엥? 함수에서 Ex1의 값이 바뀐 것이니까 인스턴스 변수 Ex1이랑 생성자에 있는 Ex1은 다른 거 아닌가요?

라고 헷갈릴 수 있는데 이 차이를 만드는 것이 바로 변수 선언이다.


Ex1은 현재 Ex클래스의 인스턴스 변수이다. 즉 클래스로 만들어진 인스턴스 안에서는 전역변수라는 것이다.

그럼 그 인스턴스의 메소드 안에서 Ex1를 호출하면 당연히 전역변수이기 때문에 Ex1이 사용된다.

하지만 함수 안이니까 이름이 같은 다른 Ex1을 만들 수도 있다.

그러기 위해서 변수 선언을 해서 새로운 Ex1을 만든다는 것을 알리는 것이다.

생성자 내에서 int Ex1 = 50; 이라고 변수 선언과 초기화를 했다면 밑의 example.Ex1의 값은 50이 아닌 0이었을 것이다.


결국 특정한 영역 내에서만 작용하는 변수를 만들기 위해서는 그 내부에서 변수를 선언해야 한다는 것이다.

변수의 선언과 초기화의 차이를 인지해야 한다. 선언은 앞에 자료형을 함께 적어 준다.

컴파일러는 함수와 같은 특정 영역의 지역변수를 먼저 찾아 밖으로 그 범위를 넓힌다.

즉 함수 안에 사용하려는 변수가 선언된 적이 있다면 그 변수를 먼저 사용하고 더 이상 찾는 걸 그만 둔다.

만약 영역 내에 사용하려는 변수와 같은 이름이 없다면 범위를 넓혀 더 넓은 영역으로 이동하고 거기에 있는 변수를 사용하는 것이다.

참고로 범위를 넓힌다는 것은 더 큰 범위로만 이동한다는 것이지 넓은 범위에 있는 다른 함수나 반복문 조건문은 건들지 않는다.


아주 기본적인 이론이지만 헷갈릴 수 있으니 정확히 알아 두자.


