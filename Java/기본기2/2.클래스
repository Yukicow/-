



파이썬의 클래스와 다를 게 없다.

쓰임이 어떻게 다른 지만 확인해 보자.




1. 접근 제한자


java에는 접근 제한자라는 개념이 있다.

말 그대로 접근을 제한하는 역할을 해서 코드의 보완성을 높이는 것이다.


public : 접근에 제한이 없음

public은 말 그대로 public으로 자유롭게 접근이 가능하다.

참고로 클래스에 public을 붙이는 것은 파일과 같은 이름의 클래스에만 붙일 수 있다.

한 마디로 메인이 될 클래스 말고는 public 사용이 불가하다.

메인 클래스 안의 클래스에는 public을 붙이는 것이 가능하다.

다른 default클래스의 안에는 public을 못 쓰나요?

상식적으로 써도 의미가 없다. 애초에 클래스 자체가 default인데 

다른 곳에서 그 안에 있는 클래스가 쓰일 수가 없다.



protected : 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용

protected는 같은 패키지(폴더)에 존재하거나 다른 패키지에 있어도 클래스가 부모 클래스에서 파생된 것이면 접근이 가능하다.

상속 받은 클래스 내부에서 부모 클래스의 protected된 것들을 호출할 수 있다는 뜻이다.

상속 받은 클래스가 있는 파일안에서 마음대로 호출되는 게 아니고 상복 받은 클래스 네임 스페이스 내에서만 ㅇㅇ

쉽게 얘기하면 자식 클래스 내에서 private처럼 사용되는 느낌?

그래서 소스 코드 파일 내의 메인 메소드에서 어떤 클래스의 상속 받은 클래스가 그 클래스의 

protected된 메소드를 사용하려 하면 동작하지 않는다. 상속 받은 클래스 내부에서만 그 메소드가 작동을 허용하기 때문.

하지만 사용방법이 있다. 바로 그들을 속이는 것이다. 상속 받은 클래스 내부에 그 protected된 메소드의 결과값을 사용하는

새로운 메소드를 정의하거나 protected된 메소드를 오버라이딩 해서 결과값을 반환하도록 만드는 것이다.

그럼 새로 만들거나 오버라이딩한 메소드는 (private로 선언하지 않은 이상)메인 함수에서 잘 작동할 것이다.

그리고 그 안에서 반환값으로 사용된 protected메소드는 위의 메소드가 사용되면 그 함수의 내부적으로 사용된 것이기 때문에

자신을 상속받은 클래스에서 사용된 것으로 포함되기 때문이다. 한 마디로 직접 호출이 아니고 간접 호출해서 눈속임 하는 것이다.

이런 기능은 java에서 아주 유용하게 쓰이기 때문에 편법이 아니고 응용이라고 볼 수 있다. 잘 기억해 두자.




default : 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지(폴더) 내에서만 접근이 가능

접근 제한자를 적지 않으면 default가 된다고 했는데 default는 같은 패키지 내에서만 접근이 가능하다.

한 마디로 패키지 단위로 작용한다는 것이다. 참고로 default는 인터페이스 외에는 모두 생략해야 한다.

portected와 default에서 같은 패키지라는 것은 import한 패키지는 같은 패키지로 안 친다는 뜻이다.



private : 자기 자신의 클래스 내에서만 접근이 가능

private는 그 클래스 내에서만 접근이 가능하다. 

쉽게 말하면 클래스 내에 있는 메소드나 명령어에만 사용될 때 만든다는 것이다.

여기서 클래스는 클래스 파일이 아니고 진짜 우리가 정의한 class임 ㅇㅇ

그래서 같은 파일 내에서 그 클래스를 제외한 곳에서 접근을 하려 해도 안 됨.

주의해야 할 것은 같은 클래스의 메소드를 통해 호출하면 문제없이 잘 작동한다.

가끔 클래스로 만들어진 인스턴스가 있으면 인스턴스 메소드에서만 작동하는 줄 아는데 그렇지 않다.

같은 클래스에 정의된 메소드라면 언제든지 그 안에서 사용될 수 있다.

예를 들어 인스턴스 1,2를 만들고 private로 선언된 인스턴스 변수가 있다고 해 보자.

인스턴스 1의 private 변수의 값을 2가 자신의 인스턴스 메소드로 변경하려 하면 잘 작동한다.

헷갈리는 내용이니 잘 알아 두도록 하자.


일반적으로는 public과 private가 많이 쓰인다 

밑은 경우별 사용 가능 접근 제한자이다.



클래스 : public, default

생성자 : public, protected, default, private

멤버 변수 : public, protected, default, private

멤버 메소드 : public, protected, default, private

지역변수 : 접근제한자 사용 불허


https://kephilab.tistory.com/53

이 사이트에 접근 제한자별 예제를 잘 만들어 두었으니 헷갈리면 참고할 것.


쉽게 정리하면 

public -> 아무 곳이나 허용

protected -> 같은 패키지면 모두 허용, 다른 패키지면 자식 클래스 내부에서만 사용 가능

default -> 같은 패키지면 모두 허용, 다른 패키지 불가

private -> 같은 클래스만 가능

여기서 같은 패키지라는 건 상위 패키지 또한 하위 패키지에 대해 접근을 허용하지 않는다는 것이다.

하위 패키지가 상위에 소속되는 개념이 아니라는 것이다.



근데 public을 언제 쓰고 언제 안 쓰는 게 좋을까요.. 헷갈리네요.

일단 뭐라고 딱 정할 수는 없지만 일반적이 예시를 하나 들어보겠다.

클래스 변수(클래스 내에서는 전역변수)같은 경우는 다른 클래스(다른 패키지)내에서 사용될 수도 있죠?

# 특히 static을 사용한 경우 public은 거의 덤이라고 볼 수 있다.

그리고 그 클래스로 만들어진 인스턴스의 인스턴스 변수들도 그런 경우가 있을 것이고?

만약 그렇게 다른 곳에서 쓰일 일이 있을 것 같은 경우에 뭐 정확히 어느정도까지 사용되는 지 알고 접근 제한자를 붙여 주면 더 좋지만

일반적으로는 public을 쓰면 되고 만약 그 클래스 내부적으로만 뭔가가 일어나야 한다 싶으면 private를 쓰는 거고.

그리고 또 다른 예로는 만약 클래스 내에 메소드를 만들었는데 다른 사람이 이 메소드에 접근하는 건 싫고 메소드를 통해 나온 결과값만

다른 사람이 이용하게 하고 싶다. 라고 한다면 private과 같은 것을 이용할 수 있는 것이다.

계산을 하는 메소드를 private으로 지정하고 같은 클래스 내에 그 메소드의 결과값을 응용한 메소드를 public으로 하나 더 만들면

사람들은 private으로 지정한 그 메소드의 결과값을 public으로 지정한 메소드로 접근할 수 있는 것이다.

계산 메소드의 실체는 꽁꽁 숨겨둔 채 다른 메소드를 통해 그 기능은 이용할 수 있도록 설계하는 것이다.

예를 들면 내 라이브러리의 메소드를 오버라이딩을 금지하고 싶을 때 위의 방법을 사용할 수 있겠다.

실제 동작하는 메소드는 private로 막아 두고 그 결과만 반환하는 메소드를 만들어 public으로 지정하면 

오버라이딩이 불가능한 원하는 기능을 하는 메소드 구현! public 메소드는 오버라이딩이 가능하지만

어차피 그 메소드는 실제 기능을 가진 메소드의 결과만 반환하기 때문에 내부적 기능의 구조까지 변환은 불가능하다는 뜻.

솔직히 코드를 보지 못 하는 이상 원래 코드를 바꾸는 오버라이딩 하려 한다 해도 쉽지 않겠지만 아주아주 운이 좋아서 

겹치는 코드를 작성해서 오버라이딩 할 수 있으니까. 애초에 원천 차단하는 느낌?

이게 메소드라서 잘 이해가 안 될 수 있는데 반대로 필드라고 생각해 보자. 필드는 필드이름만 알면 쉽게 접근할 수 있다.

근데 만약에 외부에서 필드에 접근해서 값을 바꿔버리면 문제가 생긴다고 한다면 private으로 선언해서

외부에서 필드를 사용할 수 없게 할 수 있다는 것이지. 클래스이름.필드이름 = 5; 이런 식으로 다른 사람이 마음대로 바꿀 수 없다는 거야.




2. 생성자

java에서 생성자를 만드는 법은 파이썬과 다르다.

파이썬은 __init__으로 통일했지만 java는 자신이 만든 클래스의 이름과 똑같은 함수를 만들면 그 것이 바로 생성자가 된다.

# 생성자는 반환값에 대한 자료형 없이 클래스 이름 하나만 적어 준다.

생성자는 인스턴스가 생성되는 순간 가장 먼저 호출되며 인스턴스 변수 등을 초기화 하는데 사용된다.

참고로 java는 생성자를 만들어 두지 않으면 자동으로 생성자를 만든다.

그 기본 생성자는 클래스와 같은 이름인 함수이고 매개변수를 갖지 않는다.

생성자도 오버라이딩이 가능하기 때문에 여러개의 생성자를 만들 수 있다.


생성자를 선언할 때에 조심해야 할 것이 있다.

java는 기본적으로 생성자를 만들지 않으면 알아서 기본 생성자(default constructor)를 하나 만들어 준다.

하지만 생성자를 오버로딩하는 경우는 이야기가 다르다.


기본 생성자를 만들지 않고 매개변수를 갖는 오버로딩 생성자를 하나 만들면 java는 기본 생성자를 만들어 주지 않는다.

프로그래머가 작성한 오버로딩된 생성자가 기본 생성자로 쓰이게끔 하기 위해서이다.

만약 위의 경우에서 java가 기본 생성자를 만들어 준다면 자식 클래스도 자연스럽게

부모 클래스의 기본 생성자를 상속 받아 갖게 된다. 이는 프로그래머의 의도와 어긋날 수 있다.

무조건 인자를 받아야만 객체를 만들 수 있게 하고 싶은데 인자 없이도 객체가 생성이 돼버리는 것이다.

이런 경우를 방지하기 위해서 오버로딩된 생성자가 있을 경우 기본 생성자를 강제로 만들지 않는다.

물론 그런 부모 클래스를 상속받는 자식 클래스는 기본 생성자가 없기 때문에 

오버로딩된 생성자를 super()를 통해 필수적으로 호출해야 한다. 

그냥 오버로딩된 생성자를 또 오버라이딩 해서 나만의 생성자로 만드는건..?

안 된다. 무조건 super()를 통해 자식 클래스는 부모 클래스의 생성자를 한 번은 호출해야 한다.

이것은 java에서 생성자의 호출을 강제하기 위한 것이다. 어떤 경우라도 말이다.

기본 생성자에 대한 호출은 java 내부적으로 알아서 해 주지만 매개변수를 갖는 오버로딩된 생성자는 그렇지 않다는 것.

즉, java는 부모 클래스의 생성자를 자식 클래스에서 무조건 호출하게 한다.








