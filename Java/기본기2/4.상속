






java의 상속은 파이썬과는 살짝 다르다.


파이썬은 상속하려는 내용들을 지정해서 클래스 내에 다시 정의해 주는 과정을 거치는데

java는 상속하면 그 과정 없이 그냥 모든 메소드와 변수들을 상속한다.

# 물론 private으로 정의된 것들(private 변수,메소드)은 상속 못 받는다.

그리고 java에서는 상속을 하면 부모 클래스의 생성자가 필수(강제)적으로 실행된다.

super()를 사용하지 않아도 자동으로 호출해서 실행되는 것이다.




오버라이딩 과 오버로딩

예전에 배웠지만 다시 배워 보자.


오버라이딩은 원래 있는 함수에 기능을 추가하거나 변화시킨 것이라고 볼 수 있다.

오버라이딩을 하기 위해서는 아래의 조건을 충족시켜야 한다.

1. 메소드의 이름이 같아야 함

2. 메소드 매개변수의 숫자와 데이터 타입 그리고 순서

3. 메소드의 리턴 타입


오버로딩은 아예 새로운 같은 이름의 함수를 만들어 내는 것이다.

근데 좀 의문이 드는 게 같은 이름을 같는 함수를 만든다는 게 원래 부모클래스의 함수를 완전히 재정의 해서

다른 식으로 동작하게 한다는 것인 지 아니면 진짜 이름은 같은 다른 동작을 하는 새로운 함수를 만들고

같은 이름의 함수가 여러개 공존하는 것인 지 궁금할 것이다.

오버로딩의 경우 후자다. 전자는 어떻게 보면 오버라이딩에 조금 더 가깝다.

물론 조건이 충족한다는 전재 하에 이지만.

하여튼 오버로딩은 오버라이딩의 조건을 충족하지 않는 같은 이름의 함수를 만드는 것이다.

즉 1번의 조건 이름만 같다는 조건만 같고 완전 다른 함수를 정의하는 것. 그것이 오버로딩이다.


아니 근데 어떻게 같은 이름의 함수가 여러개 존재하죠..? 오류나지 않나?

아니다. 물론 패러메터(인자)의 모양새까지 완전히 똑같다면 그건 오류가 나겠지만

인자의 타입이나 개수가 다르다면 같은 이름의 함수를 여러개 생성할 수 있다.

함수를 호출할 때 인자를 확인하고 그것에 맞는 함수가 알아서 호출되는 것이다.


예를 들어 public static add(int a, int b){} 라는 함수가 있고

같은 이름의 함수 public static add(char a, char b){}가 있으면

둘은 다른 동작을 하는 이름이 같은 함수라고 볼 수 있다.

약간 클래스 별로 같은 이름의 서로 다른 함수를 만들고 클래스 이름으로 구분하듯이

인자값을 통해 같은 이름의 함수를 구분해서 사용이 가능하다는 것이다.


오버로딩과 오버라이딩의 개념을 확실하게 기억해 두자.




super 와 this


super는 상속을 받은 클래스가 부모 클래스를 호출할 때 사용할 수 있다.

예를 들어 부모 클래스에 있는 add 메소드가 있고 자신은 그 add를 오버라이딩 하고 있다고 해 보자.

이 때 자신의 add 메소드의 반환값으로 부모 클래스의 add의 반환값을 그대로 반환하고

자신은 특정 기능만 추가하고 싶다고 한다면 return 값에 super.add()를 사용하면 된다는 것이다.

그럼 return 값으로 부모 클래스에 있는 add메소드를 실행하고 반환한다.

이처럼 super는 this처럼 사용가능한데 가장 최근 상속받은 부모 클래스에 접근할 때 사용한다.



반대로 this는 자기 자신을 말한다. 파이썬의 self와 비슷하지만 사용 범위가 좁다.

이번에는 자신의 add 메소드를 오버로딩해서 새 add함수를 만들었다고 해 보자.

그리고 반환값으로 자신의 add 메소드의 값에 인자를 하나 받아 더해 주는 함수를 만든다고 하면

오버로딩한 add 함수의 return 값으로 'this.add() + 인자로 받은 데이터'를 해 주면

자신의 (오버라이딩x)add함수에 오버라이딩한 add함수가 받은 인자를 더한 값을 return 해 준다.

이렇게 같은 이름을 가지는 메소드라도 인자나 반환 데이터 타입을 달리해 주면 

같은 이름의 다른 기능을 하는 함수를 만드는, 오버로딩이 가능하다.



파이썬은 super 뿐만 아니라 '클래스.메소드'를 통해서도 부모 클래스의 메소드를 사용할 수 있었는데

java는 super를 통해서만 가능한 듯 하다. 그리고 이러한 문제는 다중 상속에서도 나타난다.


java는 다중 상속을 지원하지 않는다. 클래스 메소드가 아닌 이상 '클래스.메소드 이름'을 통해 

함수 호출이 안 되는 것만 봐도 그 이유를 알 수 있을 것이다.

여러개의 클래스를 상속 받은면 생성자에 대해 어떤 클래스의 생성자를 사용해야 할 지 구분을 못한다.

파이썬은 self 라는 것을 통해서 self를 사용하지 않는 변수와 함수는 '클래스.변수 함수 이름()'으로

self를 사용하는 변수와 함수는 '클래스.변수 함수 이름(self)'를 통해 그 클래스를 상속 받은 모든 

클래스에 대해서 접근을 허용하게 만들어 두었기 때문에 생성자도 각 상속받는 클래스별로 따로 지정해줄 수 있다.

예를 들어 생성자를 두 개 써야 한다면 '클래스.생성자(self)'를 두 번 사용하여 각각의 클래스 생성자를 실행해 주면 된다.

하지만 super라는 것은 하나의 클래스에 대한 생성자만 가져올 수 있기 때문에 파이썬에서는 마지막에 적은 부모 클래스의

생성자를 실행하도록 설계되어 있지만 java에서는 아예 그런 일을 못 하게 막아 두었다.

쉽게 말해서 상속 받는 부모 클래스에 서로 같은 함수가 있을 때 파이썬은 그것을 원하는 함수를 지정해서 실행할 수 있는

기능이 마련되어 있어서 그것을 이용해도 되고 그것을 이용해 새롭게 오버라이딩해도 된다. 

하지만 java는 그런 기능이 없기 때문에 애초에 그런 일이 발생하지 못하게 다중 상속을 아예 차단한 것이다.

# 충돌할 게 있든 없든 아예 차단됨 그런 기능 자체가 없게 되어 있음.

# 그러나 상속(extends)과 인터페이스의 implements는 동시에 가능

super를 통해 자신이 최근 상속받은 부모 클래스 하나에 대해서만 접근을 허용하도록 구성되어 있는 것이다.




인터페이스는 다중 상속이 된다던데..?

인터페이스는 다중 상속은 허용해 두었다. 하지만 java 8에 오면서 그것도 충돌이 안 일어나는 경우에만 가능하게 되었다.

예전에는 인터페이스 내에서는 구체화,초기화 개념이 없고 선언만 가능했기 때문에

어차피 구체화랑 초기화가 인터페이스로 구현되는 클래스 내에서 이루어지기 때문에

이름이 겹쳐도 상관이 없었다. 어차피 클래스가 구현하고 나면 하나로 통합될 테니까.

하지만 java 8 부터 구현도 가능하도록 만들어졌다.

그래서 같은 이름에 구현까지 된 메소드가 있다면 자바는 위의 다중상속 처럼

어떤 것을 사용할 지 감을 못 잡고 오류를 발생시킨다.




클래스의 자료형


자식 클래스의 객체를 생성할 때 자료형을 부모 클래스로 지정할 수 있다.

예를 들어 A를 상속 받는 B가 있다고 하면 A a = new B()가 가능하다는 것이다.

하지만 당연하게도 A는 B만 가지는 변수나 메소드가 없기 때문에

원래 A가 가지고 있던 것들에만 접근이 가능하다.

여기서 신기한 것은 A가 가지고 있던 함수가 B에서 오버라이딩 되면 

A에 있는 함수가 아닌 오버라이딩된 함수가 출력된다는 것이다.

변수도 되는 지 시험해 보았지만 변수는 안 됐다. 메소드만 오버라이딩 되면 바뀌나 보다.


이게 어떨 때 사용되느냐.

특정 메소드를 사용할 때에 부모 클래스에 대한 데이터 타입을 매개변수로 하는데 그게 아주 중요하다면

우리는 그 중요한 메소드의 사용을 위해 자식 클래스를 만들어도 데이터 타입을 부모 클래스로 해서 선언하는 것이다.

그럼 오버라이딩된 함수에 대해서 새롭게 사용도 가능하고 그 중요한 함수에 인자로도 넘길 수 있다.

또 자식 클래스의 특정 기능을 제한하고 부모 클래스에 있던 것만 사용하게 할 때도 사용 가능하다. 

뭐 완전히 자식 클래스를 데이터 타입으로 쓰는 것 보다는 제한사항이 있지만 이런 사용 방식도 있다는 것이다.

이게 바로 다형성의 예라고도 할 수 있다.
