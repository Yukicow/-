





형변환이란 말 그대로 자료형이 변화되는 것을 말한다.

기본적으로 java나 c같은 경우는 정수는 int를 실수는 double을 기본 자료형으로 한다.

효율면이나 세부적인 면에서 두 가지가 가장 좋기 때문이다.

기본 자료형이라는 것은 프로그래밍 언어가 어떤 숫자 데이터에 대해 기본적으로 저녀석들을

기준으로 받아들인다는 것이다.


그래서 int가 받아들일 수 있는 최대값 보다 많은 수를 데이터로 넣으려고 하면 변수의 공간이 충분히 넓어도 오류가 발생한다.

그래서 자료형 자체를 바꾼 후에 그 공간에 넣어 주어야 한다. 위의 경우 int데이터를 long자료형으로 바꾼다는 것을 알려야 하는데

그게 바로 형변환이다.


실수와 정수는 표현방법이 다르니 자료형을 나눈 건 알겠는데 정수와 실수 내에서는 왜 또 나누죠?

그건 메모리를 효율적으로 관리하기 위해 크기별로 자료형을 나눈 것이다.

하지만 데이터를 저장하는 방식은 실수와 정수만 차이가 있지 같은 실수와 정수라면 차이는 없다.

같은 정수끼리라면 차지하는 메모리 공간만 다른 자료형인 것이다.

그래서 정수를 예로 들면 int형을 기본 자료형으로 한다고 했는데

만약 1이라는 값을 short 자료형 변수에 초기화하면 데이터를 short로 형변환을 안 해주어도 초기화가 되는 이유이다. 

int 자료형이지만 1은 데이터를 집어 넣고 나면 나머지 메모리 공간은 남아 돈다.

그리고 남는 공간은 short 형의 최대 자리를 건들지 않을 정도로 충분히 작다.

데이터 저장방법도 똑같기 때문에 굳이 형변환을 해줄 필요가 없는 것이다.

있는 그대로 그냥 short 변수에 갖다 쳐박아도 문제가 되지 않기 때문이다.

쉽게 말해서 데이터 손실이 발생하지 않는다는 뜻이다.

물론 short가 받아들일 수 있는 수 보다 큰 값을 넣으려 하면 오류가 나겠지만.



이런 원리로 기본 자료형 보다 작은 값을 초기화할 때에는 int에서 작은 자료형으로 자동 형변환이 된다 라고 표현하지만

사실상 그냥 데이터를 넣는 것이다. 작은 자료형들의 데이터는 모두 int형이 표현할 수 있는 데이터들이기 때문에 

int > short > byte 즉 short나 byte형 변수의 메모리에 데이터를 갖다 집어 넣는 것이다.

그래서 우리는 자동 형변환이 있는 덕분에 기본 자료형 보다 큰 값을 다룰 때에만 형변환에 신경 쓰면 된다.

정수는 int를 기본 자료형으로 하기 때문에 int가 받아들일 수 있는 최대값 보다 큰 값을 넣으려 하면

맨 위에서 말한 것처럼 문제가 생긴다. 그래서 더 큰 데이터를 가질 수 있는 자료형으로 변환해 준다는

형변환을 해주어야 한다. 그게 앞에 (자료형)을 붙이거나 뒤에 L,F 등등 을 붙여서 알리는 것이다.



자동 형변환은 작은 쪽에서 큰 쪽으로 이루어진다.

위에처럼 int가 short나 byte를 표현할 수는 있지만 short나 byte는 int를 전부 표현할 수 없다.

그래서 int가 short나 byte가 될 수는 없다. 데이터 손실이 발생할 수도 있기 때문이다.

그래서 자동형변환은 작은 쪽을 아예 큰 쪽으로 만들어서 대등한 위치로 만든다.

예를 들면 실수와 정수의 연산을 할 때에 발생한다.

정수 10을 실수 5.0으로 나누면 어떻게 될까?

정수를 실수 5.0으로 자동 형변환한다. 그리고 연산이 이루어진다.

그럼 값은 실수 10.0을 5.0로 나눈 것과 같은 결과값을 가진다.


자동 형변환이라는 말은 이 쪽에서 더 맞는 말인 것 같다.

위의 int가 short와 byte로 표현되는 것은 그냥 int가 둘을 모두 표현할 수 있고 표현된 값을 저장하는 것 뿐이고

밑에 연산에서의 자동 형변환은 잠시 연산과정에서 데이터를 형변환(아마도 정확히는 새로운 메모리 공간을 가질 듯)

원래 변수를 형변환 해서 바꾸는 것 보다 받은 데이터를 형변환한 값을 다른 곳에 따로 저장해서 쓰고 지우는 게 효율적일 듯 함.

하여튼 그런 식으로 자동 형변환 해서 연산에 도움을 주는 것. 이게 진짜 자동 형변환이라고 볼 수도 있을 것 같다.





+ 여기서 부터는 기본기 2의 내용을 모두 알고난 후에 알 수 있는 내용

큰 것에서 작은 것으로 형 변환은 자동으로 해 준다는 논리는 위의 자료형뿐만 아니라 객체들끼리도 사용이 된다.

이게 무슨 말이냐. 객체는 객체를 자료형으로 갖는다는 것은 이제 알 것이다.

Add a = new Add(); 이런 식으로 말이다.

이 때 자식 클래스를 부모 클래스 자료형으로 선언하는 것도 가능하다는 것을 알 것이다.

근데 그 원리가 사실은 자동 형변환이었던 것이다. 어차피 부모 클래스 보다 자식 클래스가 갖고 있는 내용이 많고

자식 클래스의 내용 중에 부모 클래스에 없는 것만 감추면 되기 때문에 어려울 것이 없다는 것이다.

그래서 큰 것에서 작은 것 -> 자식 클래스에서 부모 클래스로의 형변환은 자동으로 이루어진다.

하지만 부모 클래스가 자식 클래스로 선언될 수 있을까? 아마 상식적으로라면 안 될 것이라고 생각할 것이다.

왜냐하면 없는 내용이 많으니까. 하지만 이렇게 생각하면 말이 된다. 작은 것에서 큰 것으로 바뀌는 것.

이게 형변환이라는 개념이라고 생각하면 가능하다. 형변환을 해 준다는 것만 명시하면 가능하다는 것이다.

위의 float -> double이 되기 위해서는 형변환을 한다는 것을 명시해서 double a = (double) b;

이런 식으로 사용했다. 클래스도 마찬가지이다. 부모 클래스 A가 있고 자식 클래스 B가 있다고 가정해 보자.

A의 인스턴스 a를 만들고 이를 B로 만들어 주고 싶으면 B b = (B) a; 라고 하는 것이다.

그러면 A클래스인 a가 B클래스로 형변환이 될 수 있다.

라고는 했지만 사실 그렇지는 않다. 캐스팅(타입,형변환)에도 조건이 있다. 

다운캐스팅은 업캐스팅이 일어난 값에 한해서만 다운캐스팅이 가능하다. 라는 조건이다.

한 마디로 형변환을 통해 없는 것을 만들어 주는 기능은 없다는 것이다.

원래 한 번 업캐스팅이 된, 예를 들어 자식 클래스를 부모 클래스 자료형으로 선언한 경우 처럼

원래 갖고 있는 정보를 감추고 다운 그레이드(업캐스팅)한 경우에만 다시 업그레이드(다운 캐스팅)가 가능하다는 것이다.

# 말은 그레이드로 하는 게 편하지만 언어에서는 상속관계로 표현하기 때문에 그레이드와 반대로 표현됨. 부모가 업이고 자식이 다운이기 때문.


정 헷갈리면 캐스팅이 가능한 지 여부를 불리안 형태로 반환하는 함수도 있다. instanceof 이다.

instanceof 연산자는 A(Object) instanceof B(Class, Interface) 형태로 사용한다.

오브젝트 A를 클래스 B나 인터페이스 B로 casting가능유무(Boolean)를 확인한다.
