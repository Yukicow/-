



java에서는 string이라는 자료형과 객체에 대한 자료형이 있다.

c에서는 string은 배열을 이용해 '표현'한 것일 뿐이지만 

string은 이런 번거로움을 아예 자료형으로 지정해 주었다.

c에서 string을 표현한 형식을 이용한 것 뿐이겠지만 자료형이라는 건

그런 불편함을 없애 주는 좋은 역할을 한다.

string을 사용할 때에 포인터를 사용해 ""를 저장하면 안에 있는 요소의 값을

바꿀 수 없다는 단점. 그렇다고 []을 이용해 배열로 쓰기에는 보기 불편하다는 점 등등

자료형이 되었다는 것은 내부적으로 그런 과정들을 자체적으로 해주기 때문에

우리는 쉽게 보이는 대로 자료형을 사용할 수 있다. 그냥 문자열 자료형이라고 선언만 해 주면

저런 번거로운 과정 없이 안에 있는 요소에도 쉽게 접근하고 이것저것 응용이 가능하다는 것이다.

# 물론 primitive 데이터 타입에 속하는 건 아니고 자체적으로 만든 객체 자료형에 속한다.


예를 들면 string이 자료형이 되면서 연산자를 허용한다는 것이다.

string 변수 두 개를 +로 더하면 두 문자열은 하나로 합쳐진다.

System.out.println(""+"") 에서 ""+""은 다른 1+1 처럼 더하기 역할을 한다.

그래서 앞의 ""와 뒤의 ""를 더해서 합쳐진 결과값을 출력한다 라는 것이다.


정수형,실수형과 문자열도 연산이 가능한데

다음 챕터에서 배울 자동 형변환이 일어나기 때문이다.

"hi"+ 3를 하면 3은 자동 형변환으로 문자열로 변환된다.

그럼 "hi"+"3"과 같아져서 "hi3"이 된다.


문자열이 아닌 문자와 숫자의 연산은 어떻게 될까?

문자 같은 경우는 문자가 숫자로 자동 형변환된다.

왜냐면 문자 같은 경우는 원래 숫자를 데이터로 받아서 

아스키 코드에 맞게 변환하는 것이기 때문에 사실 숫자 데이터라고 할 수 있다.

그래서 문자를 숫자로 변환하는 게 훨씬 편하고 애초에 문자는 숫자다.

문자열은 문자의 모임이지만 이미 문자의 모임이기 때문에 연산이 허용될 수 없는 구조이다.

그래서 문자열은 당연히 숫자가 문자열로 변환되어야 한다.


나중에 숫자랑 문자 또는 문자열이랑 더해지는 경우가 있을 수 있는데 당황하지 말고 위의 경우를 이해해 두자.



+ java 다 배우고 읽어야 할 내용

객체의 자료형

객체의 자료형이라는 것은 자바에서는 만들어지는 모든 객체가 그 자체로 자료형을 갖는다.

예를 들어 Add라는 클래스를 만들면 Add는 클래스이자 자료형이 된다.

그래서 Add라는 클래스를 통해 만들어지는 인스턴스는 Add를 자료형으로 하거나 또는 

Add가 상속 받은 부모 클래스들 중 하나를 자료형으로 가져야 한다.

그리고 이런 객체가 자료형이라는 것은 함수 등의 리턴값으로 객체의 자료형이 사용될 수 있다는 것이다.

특정 부모 클래스의 메소드 중에는 이런 객체 자료형을 리턴값으로 갖는 메소드가 많다.

이는 '2.형변환'의 맨 밑부분을 보고 나서 이해하면 되는데 이렇게 특정 객체 자료형으로 업캐스팅되어 리턴되는 것을

우리는 다운 캐스팅을 해야 하는 경우가 생길 수 있다.


메소드의 뒤에 갑자기 객체가 나온다고 놀라지 말고 "아..특정 객체 자료형이구나" 라고 생각하면 된다.

ex)

public Object clone() {

}

이것은 clone()이라는 메소드가 Object 타입으로 복제한 객체를 반환한다는 것이다.

그렇기 때문에 우리는 이렇게 복제된 객체를 원하는 객체 타입으로 다운 캐스팅 해야 한다.



+ java 다 배우고 읽어야 할 내용2

java의 자료형에는 원시타입(primitive type)과 레퍼런스 타입(reference type)이 있다.

레퍼런스 타입은 c언어의 포인터 보다는 파이썬의 레퍼런스의 개념과 비슷하다. 아니 같다고 보는 게 맞을 지도.

그래서 java는 c언어와 파이썬이 섞인 중간 언어같은 느낌이다.

c언어의 포인터는 변수 안에 메모리 주소를 저장하여 참조하는 스타일이라면 레퍼런스라는 것은

변수에 메모리 주소를 저장하여 참조하는 개념이 아니고 변수 자체가 메모리 주소를 따라가는 개념이다.

변수가 메모리 주소를 가리키게 한다는 개념이 맞는 듯 하다.

이게 왜 중요하냐면 만약 레퍼런스 타입인 객체를 하나 생성했다고 해 보자.

A라는 클래스의 인스턴스 a를 만들었다.

그리고 나는 A자료형 인자를 필요로하는 메소드에 a를 넘겨 주었다. 그리고 그것을 b라고 칭하자.

그러면 레퍼런스 타입이기 때문에 b가 함수 내에서 이용되어 내부의 값이 변하면 a라는 인스턴스의 값 자체가 변한다. 

근데 이 때 함수 내에서 b = new A(); 라고 선언하면 어떻게 될까.

b가 바라보는 레퍼런스가 새로 만들어진 클래스 A의 인스턴스로 변경되는 것이다. 

c언어 였다면 b의 메모리 주소 안에 있는 데이터가 new A()로 인해 생성된 인스턴스의 메모리 주소로 바뀌겠지만

java는 그렇지 않다는 것이다. 뭐 결과적으로 작동은 c나 java나 똑같이 새로운 인스턴스를 가리키겠지만 그 원리가 다르다.


이게 java가 레퍼런스 타입에서는 메모리 주소를 따라가는 형식인가를 알 수 있냐면

c언어에서는 변수가 메모리 주소를 참조하는 경우 그 변수를 출력하면 메모리 주소를 출력해 주었다.

하지만 java에서는 변수의 데이터가 레퍼런스 타입이고 그 객체를 출력하려 하면 그 객체의 toString 메소드를 출력한다.

변수가 메모리 주소를 갖고 그 안에 데이터가 있다는 개념이 없으니 출력해줄 수 있는 것이 없는 것이다.

그래서 toString 메소드를 자동으로 출력하게 설계해 놓은 것이다. 그 객체의 정보라도 알 수 있게끔.

뭐 이건 개인적인 의견이면서도 거의 99% 확신하는 내용이다. 하지만 맞는 지는 java를 설계한 사람이 아닌 이상 알 수 없다.