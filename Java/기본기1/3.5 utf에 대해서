


먼저 Unicode에 대해 알아야 한다.

어렵게 생각하면 끝도 없다. 하지만 단순하게 생각해서 코드 테이블 인덱스 값이다. 

모든 문자에 대해서 Unique한 넘버를 부여한것이 Unicode이다. 이 Unicodes는 플랫폼, 운영체제, 언어에 독립적이다. 

아스키 코드의 전세계 호환 버전이라고 생각하면 된다.



옛날옛날 컴퓨터가 세상에 나왔을 때는 ‘영어’와 몇가지 ‘특수문자’만 사용했고 이를 저장하기 위해서 1 byte면 충분했다.(0~255) 

# 아스키 코드를 사용하고 있던 시기

시간이 흘러 다른 국가 사람들이 컴퓨터를 이용하다보니 자국어도 컴퓨터로 표시하고 싶어졌다. 

그래서 1 byte 안에 임의대로 알파벳 대신 자기나라 글자를 할당해서 그럭저럭 쓸 수는 있었다. 

그러나 네트워크가 발전하고 다른 사람 홈페이지를 들어갔더니 글자가 와장창 깨지고 만다.

아스키코드를 이용해 다른 언어를 표현하기에는 7비트로는 부족했다. 그래서 8비트로 확장한 아스키 코드가 나왔다.

사람들은 이 코드를 ANSI 코드라고 부르기 시작했다.

# ANSI 코드를 사용하고 있던 시기

그러나 한글은 자음과 모음의 조합 가능 개수만 따져도 가뿐히 128개를 넘는다.

중국어 역시 한자의 개수가 만 개가 넘는데, 이를 어떻게 아스키 코드에 담을 수 있을까?

그리하여 국제적으로 전세계 언어를 모두 표시할 수 있는 표준코드를 만들기로 했다. 바로 유니코드(Unicode)다. 

용량을 크게 확장한 2byte (2의 16승 = 65536)의 유니코드가 등장하게 된 것이다.

# 각 많은 언어들의 코드 인덱스를 겹치지 않고 구분하기 위해서 바이트의 길이를 늘려 약속 가능한 경우의 수를 늘린 것이다.

물론 그래도 부족해서 그 2의 16승 짜리 세트(평면이라고 함)를 또 17개 쳐 만들어서 앞에 0~16을 붙여 사용했다.

이 평면 중에서 현대에서 쓰이는 문자들을 모두 0번 평면에 몰아 넣었는데 이 평면을 기본 다국어 평면(BMP)라고 한다.

하지만 그렇게 되면 모든 평면이 값을 가지기 때문에 겹치는 것들이 발생하게 된다. 예를 들어 1번 평면에서 'ㄹ'인게 2번 평면에서'a'라든가

그래서 평면을 구분하기 위해 앞에 'U+' 접두어를 붙여 구분해 준다. U+ 뒤에 오는 숫자에 따라 평면을 인식한다.



유니코드의 문제점

그런데 이 유니코드에서 문제점이 발생한다.

유니코드가 영어를 표현할 땐 1바이트로, 한글을 표현할 땐 2바이트로

다른 특수문자를 표현할 땐 3바이트로 표현하는 가변적인 표현의 문제가 생긴다.

어쩔 땐 1바이트를 읽고 어쩔 떈 2바이트를 읽으니 이는 컴퓨터에게 매우 큰 혼란은 준다. 

따라서 어떤 글자는 1바이트로, 어떤 글자는 2바이트로 읽을지 정해줘야한다.

유니코드로는 세상에 존재하는 거의 모든 문자를 표현할 수 있지만, 그만큼 바이트를 많이 사용하기 때문에 용량이 크다는 문제가 있다.

또, 첫 번째로 평면을 표시하는 숫자를 앞에 붙여야 하기 때문에 문자를 표시하는 바이트 외에 자리가 더 필요한 상황이 된다.



유니코드 인코딩 방식

앞서 나온 문제점을 보완하기 위해 유니코드에는 다양한 인코딩 방식이 존재한다.

인코딩 방식이란, 컴퓨터가 어떤 글자를 만났을 때 얼만큼씩 읽어야 하는지 미리 말해주는 것이다.

유니코드의 인코딩 방식으로는 코드 포인트를 코드화한 UCS-2와 UCS-4, 변환 인코딩 형식인 UTF-7, UTF-8, UTF-16, UTF-32 인코딩 등이 있다.

한 마디로 UTF는 Unicode Transformation Format의 약자로 유니코드 인코딩 방식 중 하나인 것이다.

쉽게 말해서 글자를 만났을 때 얼만큼씩 어떤 방법(평면?)으로 읽어야 하는 지 알려 주는 방식이다.




우리는 세 가지 방식만 알아 볼 것이다. UCS-2와 UTF-8, UTF-16이다.

기본기1 -> 3.입출력에서 배울 내용에 필요한 부분만 알 수 있게 간략화할 것이다.



1. UCS-2
 
UCS-2 방식은 유니코드의 모든 평면의 문자를 모두 인코딩 하지 않고, 0번 기본 다국어 평면 (BMP)만을 인코딩하는 방식이다.

0번 평면의 0x0000~0xFFFF까지의 문자를 그대로 고정 2바이트 형식으로 표현한다.

ex) 유니코드에서의 한글 “가”에 해당하는 16진수 숫자는 0xAC00을 UCS-2로 인코딩 하면 [0xAC 0x00]이 된니다.

UCS-2의 장점은 유니코드에서 평면을 나타내는 숫자를 떼어버렸기 때문에, 1글자의 크기가 딱 2바이트로 깔끔하게 떨어진다는 것이다.




2. UTF-8

UTF-8은 가장 많이 사용되는 가변 길이 인코딩이다. 문자에 따라서 1바이트 ~4바이트로 인코딩 될 수 있으며, 

UTF-16과 다르게 아스키 코드와 *하위 호환성을 가진다.

# 하위 호환이란 기술 및 컴퓨터 분야에서 새 제품이 이전 제품을 염두에 두고 만들어져 별도의 수정 없이 그대로 쓰일 수 있는 것을 뜻한다.


보통 유니코드가 널리 쓰이기 전에 형성된 문서나 프로그램이 아스키 코드를 기반으로 작성되었기 때문에 

UTF-8은 이 부분에서 많은 장점을 가지게 되어서 널리 쓰이게 되었다.


UTF-8은 아래 규칙에 따라서 유니코드 문자를 인코딩 한다.


ASCII코드 : 1바이트 

문자가 ASCII 코드인 경우에는 ASCII와 동일하게 1바이트로 표현을 한다.


아랍, 히브리, 대부분의 유럽계(조지안 문자 제외) : 2바이트

UTF-8에서는 U+0080 ~ U+07FF 사이의 아랍, 히브리, 유럽계 문자들을 2바이트로 표현한다.

여기서 앞의 바이트 앞에 110을 붙이고, 따라 오는 바이트의 앞에는 10을 붙이는 규칙을 적용한다.


기본 다국어 평면(BMP) : 3바이트

ASCII와 아랍, 히브리, 유럽계 문자들을 제외한 BMP 문자들은 모두 3바이트로 표현한다.

첫 바이트 앞에는 1110을 붙이고, 나머지 두 바이트 앞에는 10을 붙이고, 문자 비트들을 그 뒤에 적용시키게 된다.


모든 유니코드 문자 : 4바이트

0번 평면인 기본 다국어 평면을 제외한 모든 문자들은 4바이트로 표현한다.

4바이트중 첫 번째 바이트 앞에 11110을 붙이고, 나머지 바이트 앞에는 10을 붙인 뒤 나머지 문자에 해당하는 비트를 집어넣는다.




3. UTF-16
 
UTF-16은 너무 많은 용량을 사용하는 UTF-32 인코딩의 문제를 해결하기 위해 나온 가변 길이 인코딩 기법이다.

UTF-16은 기본 다국어 평면에 속하는 문자들을 표현할 때는 UCS-2와 같지만, 2바이트를 넘어서는 문자는 4바이트를 표현하도록 하여 문제를 해결했다.

그래서 기존의 UCS-2 16비트 인코딩과 호환이 되면서도 16비트를 넘어서는 문자를 가변 길이 인코딩으로 표현이 가능하게 되었습니다.

 
문자 표현

기본 다국어 평면(BMP) : 2바이트

2바이트를 넘어선 모든 유니코드 문자 : 4바이트



이제 입출력에 관한 내용을 이해하는데에 좀 더 수월할 것이다.