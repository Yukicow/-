




c언어에서의 printf와 scanf를 담당하는 함수가 java에서는 무엇인 지 알아 보자.

입력은 크게 문제가 없지만 입력은 이해가 필요한 부분이다.



1. 출력


1-1. System.out.printf()

System.out.printf()가 c의 printf()의 역할을 하는 출력 함수이다.

c의 printf()와 같다. 당연히 줄바꿈은 없다. \n을 %n으로 사용 가능하다.



1-2 System.out.print()

사용법은 위의 printf와 거의 같고 대신 줄바꿈을 포함한다.



1-3 System.out.println()

이놈은 파이썬의 print()와 비슷하다.

()안에 출력할 변수와 문자열 모두 사용 가능하다.

파이썬처럼 +를 이용해서 여러 변수 또는 여러 문자열, 문자열과 변수 등등

이어서 출력이 가능하다. 줄바꿈 기능을 포함한다.






2. 입력


자바의 입력은 여러 방법이 있는데 Scanner에 대해 알아 볼 것이다.

먼저 import할 내장 클래스 파일의 이름은 java.util.Scanner이다.

import java.util.Scanner; 를 해 주고

Scanner 객체를 생성한다. 일반적으로 sc라고 사용하는 듯 하다.

Scanner sc = new Scanner(System.in)

Scanner의 인자로 System.in 을 넘겨 준다.


JAVA에서는 스크린과 키보드를 통한 입출력 방법인 표준 입출력을 제공한다.

표준 입출력을 제공하는 클래스는 java.lang.System으로 멤버 변수인 in, out, err을 이용해서 표준 입력, 표준 출력, 표준 에러를 제공한다.


1. System.in


System은 Java의 아주 기본적인 클래스들이 저장된 java.lang의 패키지의 클래스이다.

그리고 in은 그 System 클래스의 InputStream 타입 객체이다.


System.in은 InputStream 데이터 타입이다.

# 이 말은 InputStream을 객체화 한 것이라는 거다. Add a = new Add() 처럼 

System 클래스는 자바 버추얼 머신을 구성하고 있는 표준 장치를 뜻하는 클래스이다. 


자바 버추얼 머신은 그 자체가 완벽한 하나의 컴퓨터 플랫폼을 가정하고 있기 때문에 독립적으로 동작할 수 있는 구조를 표현하기 위하여 

표준 입력과 표준 출력을 스스로의 System 클래스에 등록하여 사용한다.


여기서 System.in을 java의 소스 코드로 보면 바로 선언해서 사용하고 있는 것을 볼 수 있다.

하지만 in의 데이터 타입은 추상 클래스인 InputStream이다. 

그렇다고 추상 클래스를 상속받아 그 안에 구현된 메소드들을 따로 정의해 놓은 것도 아니었다.

어떻게 이런 일이 가능할까?

그것은 java의 원리를 알면 이해가 가능하다.

java는 low level 언어가 아니기 때문에 직접 하드웨어 단을 건들 수가 없다.

그래서 자바같은 경우 하드웨어를 제어하기 위해서는 low level 언어(C언어 등)로 구현된 메소드를 사용하게 된다.

java의 소스 코드를 보다 보면 native라는 키워드를 사용하는 초기화(static) 블록이 있을 것이다.

native가 보통 자바가 아닌 C, C++같은 언어로 구현한 라이브러리들을 자바에서 사용하려고 할 때 쓰는 키워드 이다.

System 이라는 클래스도 보면 static 블럭 안에 native키워드를 사용한 로직이 들어가 있다.

즉 System 클래스에서 java 소스 코드로 정의가 안 된 것들은 자바 언어로 작성 된 소스 코드에서 초기화를 해주는 것이 아닌 

어셈블리, C 같은 low level 언어로 작성 된 라이브러리에 의해 초기화가 되었다는 것이다. 

그래서 System.in이 저따구로 선언돼 있어도 사용이 가능한 것이다. low level 단에서 초기화가 되었기 때문.




바이트 기반 스트림 클래스

- 1차 스트림

입/출력 통로를 직접 만드는 클래스

- 2차 스트림

기존의 통로를 이용하여 새로운 기능을 더하는 클래스



스트림의 특성은 아래와 같다.

1.스트림은 데이터 소스로 부터 데이터를 읽기만 할 뿐, 변경하지 않는다.

2.스트림은 한번 사용하면 닫혀서 다시 사용할 수 없다.

3.스트림은 작업을 내부 반복으로 처리한다.



Scanner 클래스의 입력 메소드 종류

next() : 입력된 값을 문자열로 리턴

nextInt() : 입력된 값을 정수형으로 리턴

nextDouble() : 입력된 값을 실수형으로 리턴

nextLine() : 입력된 값을 '엔터(\n)'전 까지 리턴

hasNext() : 현재 입력된 값이 있으면 true, 아니면 새로운 값이 들어올 때 까지 무한정 기다려서 

새로운 입력값이 들어오면 그때 true 리턴, [ cmd+z ] 키가 입력 되면 입력 끝이므로 false 리턴



+ 추가

스트림을 통해 키보드에서 CPU로 데이터를 전달(흐름)한다.

모든 언어는 이러한 스트림에 연결할 수 있는 핸들을 제공하는데 

# 스트림은 데이터의 흐름을 의미. 스트림이 발생하는 통로에 연결해서 그 스트림을 읽어들이는 듯 함.

예를 들어 C-lang은 stdin 을 통해 연결된다. 마찬가지로 Java는 stream 클래스를 통해 이러한 스트림에 연결하는 것이다.

# 여기서 stream 클래스는 InputStream,OutputStream에 대한 것. CollectionFrame을 다루는 stream 클래스들과 다름.

InputStream은 입력 스트림과 연결하여 스트림을 byte 단위로 읽어들이는 메소드를 포함하는 추상 클래스이다.

그래서 InputStream과 OutputStream은 이러한 데이터의 흐름, 스트림에 대한 클래스이자 데이터 타입인 것이다.

저 두 가지 데이터 타입을 갖는 다는 것은 그 객체가 스트림에 접근할 수 있는 객체라는 뜻이다.

System은 표준 입출력에 해당하는 클래스인데 System 클래스 내부에 InputStream 데이터 타입을 갖는 in 필드를 선언해 두었다.

InputStream과 OutputStream은 추상 클래스이기 때문에 실체가 없어서 바로 사용할 수가 없다.

그래서 우리는 저런 두 추상 클래스를 상속 받는 자식 클래스의 실체 객체를 만들어야 비로소 그 안에 정의된 메소드들을 사용할 수 있는 것이다.

그래서 System 클래스에는 이러한 추상 클래스에 대한 실체인 in을 만든 것이다.

그래서 System.in은 InputStream에 정의된 스트림을 읽어들이는 메소드들을 사용할 수 있다.

그러나 거기에 있는 메소드들은 InputStream데이터 타입이기 때문에 스트림을 바이트 단위로 읽어들인다.

그렇기 때문에 우리가 아무리 입력을 많이 해도 많이 값을 담지 못하고 배열을 통해 값을 담는다고 해도

원하는 형식으로 값이 저장되지 않을 것이다. 실제 데이터를 저장할 때에 필요한 바이트 크기가 1바이트 보다 클 수 있기 때문이다.




좀 더 깊이 들어가자면 java는 내부적으로 utf-16 방식으로 문자를 저장한다.

그리고 문자열 송/수신을 위해 직렬화가 필요할 때에는 변형된 UTF-8 을 사용한다.

저장은 utf-16으로 하고 문자열을 입출력 할 때는 운영체제 기본 인코딩값, 또는 사용자가 지정한 인코딩 값으로 문자열을 인코딩한다는 뜻이다.

# 각각 인코딩 규칙이 있기 때문에 단순히 숫자를 대응시키는게 아니라 별도의 인코딩 변경 알고리즘이 있다. 그래서 변형되는 과정에 문제는 없는 듯 하다.

예를 하나 들어 보면 우리가 InputStream에 정의된 read()메소드로 '가'를 입력하고 스트림에서 읽어들이면, 

한글은 총 3바이트로 구성되고 read() 메소드는 int형으로 값을 출력하니 '가'에 해당하는 utf-8 인코딩 방식에 따른 숫자가 저장될 것이고

그 값은 3바이트에 각 1Byte씩 234, 176, 128 으로, 저렇게 구성된 3바이트가 합쳐져 '가'라고 표현된다.

근데 바이트 단위로 읽게 되면 234만 읽히고 나머지 176과 128은 스트림에 그대로 남게 된다.

여기서 234는 자바 내부적으로 utf-16 형식으로 저장되게 될 텐데.

234를 16진수로 변환하면 EA이고 자바의 인코딩 방식에 따라 0xc3 0xaa로 변환된다. 이에 대응되는 유니코드 테이블의 문자는 'ê'이다


정리하자면

1. UTF-8 로 입력을 받는다

2. read() 메소드는 1 byte만 읽기 때문에 나머지 byte는 스트림에 잔존하게 된다.

3. 읽어들인 byte 값은 메모리에 UTF-16 에 대응되는 문자의 인코딩 방식으로 2진수 값이 저장한다.

4. 출력시 메모리에 저장되어있던 2진수값이 UTF-8 인코딩 방식에 따라 대응되는 문자로 변환되어 출력된다.


위와 같은 단점을 보완하고자 우리는 Scanner와 같은 클래스를 이용해서 값을 입력 받는 것이다.

먼저 Scanner를 뜯어 보면 Scanner의 생성자가 엄청나게 많이 오버로딩 돼있는 것을 볼 수 있다.

우리가 흔하게 쓰는 Scanner(System.in)은  

public Scanner(InputStream source){
    this(new InputStreamReader(source), WHITESPACE_PATTERN);
} 

로 보내지는 것이다.

근데 잘 보면 저렇게 많은 오버로딩된 생성자들이 결국 다 하나의 생성자로 넘겨지게 되는데 

그 생성자는 바로 위의 this()메소드에 속하는 private Scanner(Readable source, Pattern pattern)이다.

그리고 여기서 바로 InputStreamReader가 나오는 거다.


우리가 InputStream.read()를 통해 입력을 받으려고 해도 1Byte만 인식하니 한글은 입력해 봤자 읽지도 못 하고 엉뚱한 문자만 나온다. 

이를 해결하기 위해 우리가 필요한 건 '문자를 온전하게 읽어들이기' 이다. 그리고 이를 위해 확장시킨 것이 InputStreamReader다. 

즉, InputStream 의 바이트 단위로 읽어 들이는 형식을 문자단위(character)로 데이터로 변환시키는 중개자 역할을 한다고 보면 좋다.

# Scanner의 어떤 Scanner()메소드를 사용하든 위의 Scanner(Readable source, Pattern pattern)생성자로 이동되며. Readable에는 InputStreamReader가 들어간다.


잘 생각해보자. 우리가 Scanner 로 입력받을 때 한글을 String이나 char 에 저장하고 출력할 때 한글이 깨지던가? 아니다.

중개자 역할을 하는 InputStreamReader가 온전한 문자형태로 변환 및 처리해주기 때문이다.

# 스트림을 charset에 지정된 방식으로 읽어들이기 때문. 따로 지정하지 않으면 default = utf-8 방식으로 읽는다.

 
즉, Scanner 객체를 이용해 문자를 제대로 출력하는 것도 결국에는 InputStreamReader덕분인 것이다.

그래서 InputStreamReader를 그냥 사용해도 Scanner를 사용한 것처럼 제대로 문자를 출력할 수 있다.

하지만 InputStreamReader는 문자단위로 읽어들이기 때문에 문자열 저장이 번거롭다. 

그래서 Scanner를 통해 읽어들이는 양을 조절하고 반환값을 지정하는 메소드를 사용하는 것이다.


Scanner의 과정을 나타내 보면 # 복잡하니 대충 봐도 된다.

1. InputStream (바이트스트림) 을 통해 입력 받음

2. 문자로 온전하게 받기 위해 중개자 역할을 하는 InputStreamReader(문자스트림) 을 통해 char 타입으로 데이터를 처리함

3. 입력받은 문자는 입력 메소드( next(), nextInt() 등등.. ) 의 타입에 맞게 정규식을 검사함

4. 정규식 문자열을 Pattern.compile() 이라는 메소드를 통해 Pattern 타입으로 변환함

5. 반환된 Pattern 타입을 String으로 변환함

6. String 은 입력 메소드의 타입에 맞게 반환함 (nextInt() - Integer.parseInt() / nextDouble() - Double.parseDouble() 등등..)


Scanner 는 속도가 느리다, 성능이 좋지 않다고 한 이유가 바로 위의 과정 중 정규식을 많이 검사하기 때문이다. 

물론 장점도 있다. 강력한 정규식 검사로 인해 여러 예외적인 입력 값에 대해서도 입력받은 값이 

특정 타입으로 변환 할 수 있는지를 정확하게 파악할 수 있다. 즉, 타입 변환의 안정성이 매우 뛰어나다는 점이다.


그럼 Scanner가 아닌 BufferedReader에 대해서도 이해해 보자.

BufferedReader 객체를 생성, 선언을 할 때 보통 우리는 다음과 같이 쓴다.

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

위를 해석하면 

1. 기본적으로 바이트 스트림인 InputStream을 통해 바이트 단위로 데이터를 입력을 받는구나

2. 입력 데이터를 char 형태로 처리하기 위해 중개자 역할인 문자스트림 InputStreamReader 로 감싸주는구나



여기까지는 이해가 될 것이다. 근데 BufferedReader 는 왜 필요할까.


앞서 Scanner에서 InputStreamReader을 설명할 때 '문자'를 처리한다고 했다. '문자열'이 아니다.

(그래서 Scanner를 사용했고 Scanner에서도 내부에서 임시 배열을 두어 문자열처럼 사용하고 있다.)


쉽게 말해서 InputStreamReader가 바이트 단위로 읽은 데이터를 문자 단위로 읽어서 출력해 주기 때문에

문자열에 대한 데이터 출력은 제한이 발생한다는 것이다.


그래서 쓰는 것이 Buffer(버퍼)를 통해 입력받은 문자를 쌓아둔 뒤 한 번에 문자열처럼 보내버리는 것이다.


BufferedReader를 쓸 때 우리는 입력 메소드로 readLine()을 많이 쓴다. 이 메소드는 한 줄 전체를(공백 포함) 읽기 때문에 

char 배열을 하나하나 생성할 필요 없이 String 으로 리턴하여 바로 받을 수 있다는 장점이 있다.


Byte Type = InputStream

Char Type = InputStreamReader

Char Type의 직렬화(String이라고 볼 수 있다.) = BufferedReader


이런 느낌인 것이다.



BufferedReader 의 특징은 크게 두 가지가 있다.

1. 버퍼가 있는 스트림이다.

2. 별다른 정규식을 검사하지 않는다.


위와 같이 두 개의 특징 덕분에 입력 과정에서 Scanner에 비해 성능이 우수할 수 밖에 없다.

그리고 BufferedReader의 경우 Scanner와 다르게 문자열 그대로 읽어 들이기 때문에 별다른 정규식을 검사하지 않는다.

그렇기 때문에 Scanner에 비해 성능이 좋을 수 밖에 없다는 것.



이렇게 입력에 대한 내용을 정리해 보았다. 위의 내용이 많으니 한 눈에 보이게 요약하면


1. InputStream은 바이트 단위로 데이터를 처리한다. 또한 System.in 의 타입도 InputStream 이다.


2. InputStreamReader은 문자(character) 단위로 데이터를 처리할 수 있도록 돕는다. 

InputStream의 데이터를 문자로 변환하는 중개 역할을 한다.


3. BufferedReader은 스트림에 버퍼를 두어 문자를 버퍼에 일정 정도 저장해둔 뒤 한 번에 보낸다.


Scanner는 데이터 타입이 입력받는 시점에 결정되기 때문에 별도의 Casting 필요 없고

BufferedReader는 무조건 버퍼에 담긴 값이 문자열로 저장되기 때문에 형변환이 필수이다.


또 Scanner를 사용할 때에 조심해야 할 것이 있다. Scanner의 read()메소드는 개행문자 이전까지만 읽어들이기 때문에 

\n에 대한 문자는 그대로 남게된다. 그래서 read() 사용을 할 때에는 조심해야 한다. 


이렇게 클래스로 만들어진 객체를 우리는 변수로 지정해 실체화를 하고 그것을 이용해 특정 기능을

복잡하게 함수의 호출 없이 바로바로 사용할 수 있는 거지. 특정 기능을 하는 모듈을 만들어 간편하게 사용할 수 있는 실체를 만드는 것.

이게 아마 객체지향 프로그램의 장점이 아닐까.