




java에는 데이터를 비교하는 .equals() 함수가 있다.

==과의 차이점이 있는데 어떻게 다른 지 알아 보자.


단순하게 말하면 == 연산자는 int,boolean과 같은 primitive type에 대해서는 값을 비교하고 reference type에 대해서는 주소값을 비교한다. 

사실 같은 상수를 참조하면 주소값이 같으니 결국 같은 primitive type도 동일한 주소인 지를 보는 게 아닐까 하는 개인적인 의견이 있다.

이건 java 내에서 가능할 지는 모르겠는데 나중에 다른 메모리 주소에 같은 값을 넣고도 한 번 비교해 봐야겠다.

어쨋든 왜 이렇게 둘을 나누어 놓은 것일까.

그 이유는 reference type의 특성을 보면 알 수 있다.

레퍼런스 타입은 주소값을 반환하고 서로 다른 메모리 주소에 같은 값이 저장되는 경우가 빈번하다.

근데 이 때 가리키는 메모리 주소를 비교할 것인지 그 안의 데이터의 값이 같은 지를 비교할 지 두 가지 경우의 수가 있다.

그래서 레퍼런스 타입의 데이터에 대해서는 그 '값'이 같은 지를 비교하는 .equals()를 제공하는 것이다.




예를 들면 


a와 b라는 똑같이 "코미클" 이라는 문자열을 갖는 변수가 있다고 하면

reference type 이기 때문에 문자열의 메모리 주소가 같은 지를 비교할 것이다.

==를 하면 true가 나올 것이고 a.equals(b)를 해도 true가 나올 것이다.

String 은 한번 사용이 되면 또다시 재사용될 확률이 높기 때문에 이에 대한 적절한 대처 방법으로 

Heap 영역 내에 문자열 상수의 Pool 을 유지하고 해당 Pool 로 사용자가 정의한 변수가 가지고 있는 value 들을 담게 된다.

그래서 litral로 선언, 즉 new없이 ""을 이용해 "코미클" 문자열을 데이터로 갖는 문자열 변수를 새로 만들면 

변수가 문자열 상수 풀(String constant pool)에 담아 놓았던 문자열 "코미클"을 참조하게 한다.

그래서 a와 b는 완전히 같은 것을 가리킨다고 볼 수 있다.


하지만 필요에 의해서 같은 문자열을 새로 만들어 주었다면 얘기가 다르다.

String b = new "코미클"을 통해 새로운 "코미클"이라는 문자열 객체를 만들었다고 해 보자.

이러면 문자 상수 풀에 있는 것과는 별개로 heap영역에 "코미클"이라는 문자열 데이터가 새로 생겨난다.

그럼 이제 a와 b 변수가 가리키는 "코미클"은 서로 다를 것이다.

그렇기 때문에 메모리 주소도 당연히 다르고 reference type에 대해 메모리 주소값을 비교하는 ==를 할 경우 false가 나온다.

하지만 .equals()는 그 메모리 주소안의 데이터인 문자열을 대조해 본다.

그리고 만약 값이 같을 경우 true를 반환한다.



