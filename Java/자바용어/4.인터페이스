





java에서 interface는 하나의 틀 같은 것이라고 생각하면 된다.


interface내에는 여러 메소드 같은 것들이 정의되어 있는데

우리가 그 interface를 implements(구현하다)

뭐 상속 비슷한 건데 그 인터페이스를 가져다 그대로 구현하겠다는 뜻이다.

하여튼 implements 하면 그 인터페이스의 형태를 그대로 따라야 하는 것이다.

인터페이스에 정의된 메소드의 이름이나 패러메터 등등 전부 똑같이 따라가야 한다는 것이다.


그냥 갖다 베끼는 것과 똑같다.

하지만 인터페이스에는 메소드의 정의는 되어 있지 않다.

한 마디로 이름이나 뭐 그런 것들만 가져다가 똑같이 사용하고 

안에 그런 메소드들의 정의는 내가 원하는 대로 하는 것이다.

*java8 부터는 메소드의 정의도 가능하게 바뀜


인터페이스는 이렇게 외부에 있는 클래스에 자신의 구현체를 전부 입히는 것이기 때문에

추상 클래스의 상속하는 개념과 조금 다르다. 인터페이스는 자신의 구현체를 그쪽에 그대로 구현하는 느낌이다.

코드를 복사하는 게 아니고 구현체를 구현하는 것이기 때문에 메모리상에 없는 것을 넣을 수 없다. 모두 구현이 돼 있어야 한다.

그러니 변수는 무조건 static으로 선언 되어야 하고 final인 이유는 인터페이스 값의 수정을 못하게 하기 위해서다.

애초에 인터페이스의 목적이 서로 변하지 않는 공통적인 인터페이스의 약속을 사전에 정의하는 개념이기 때문에 

변수의 값이나 메소드의 형태가 바뀌어서는 안 된다. 메소드는 어차피 못 바꾸니 변수만 못 바꾸게 설정하면 된다. 그래서 final을 쓰는 것.

메소드는 구현이 되어 있는 것으로 간주하나요?

인터페이스의 모든 메소드는 추상 메소드이다. 그렇기 때문에 정의만 안 돼 있고 구현은 되어 있는 상태라고 볼 수 있다.

결론은 인터페이스 안의 모든 변수는 public static final이고 생략이 가능하다. 

그리고 인터페이스 안의 모든 메소드는 public abtract이고 생략이 가능하다. 생략이 가능하다는 건 내부적으로 그렇게 간주한다는 뜻이다.

# 이런 점에서는 추상 클래스와 조금 차이가 있다. 추상 클래스는 멤버 변수를 만들 수 있기 때문.





추상 클래스와 인터페이스는 조금 다르다.


1. 인터페이스는 클래스가 아닌 인터페이스라는 고유한 형태를 가지고 있는 반면 추상 클래스는 일반적인 클래스다.

2. 인터페이스는 구체적인 로직이나 상태를 가지고 있을 수 없고, 추상 클래스는 구체적인 로직이나 상태를 가지고 있을 수 있다.


위와 같은 차이점이 있어서 인터페이스와 추상 클래스는 조금 명확하게 구분이 되었는데 

최근에는 인터페이스도 추상 클래스처럼 메소드나 변수를 선언할 수 있게 바뀌어서 조금 비슷해진 경향이 있는 듯 하다.


하지만 밑에 사용 예시를 보고 나면 조금 구체적인 차이점이 이해가 될 것이다.


계산기 기능이 필요한 프로젝트를 진행하는데 시간이 촉박하다고 해 보자. 

그래서 계산기 클래스는 개발자 A가 만들고, 개발자 B는 그 클래스를 사용하는 로직을 만들게 되었다. 

이런 경우 개발자 B는 개발자 A가 계산기를 잘 만들어서 나중에 제출할 것이라고 기대하고 개발을 진행할 것이다. 

그리고 B는 임시로 사용할 가짜 로직을 만들어서 코드를 작성했다.

이 가짜 로직은 나중에 A가 제출할 진짜 계산기와 똑같이를 불러왔을 때에 사용할 것과 똑같이 작동하도록 만들 것이다.

뭐 좀 구체적인 예시를 들면 계산기에 sum이라는 메소드가 있고 인자를 2개를 받을 것으로 기대가 된다면

가짜 로직에는 진짜 계산기에서 사용할 메소드 이름을 그대로 쓰고 인자를 두 개 받아 구현해 놓았을 것이다.

미리 프로젝트에 구현을 해 놓고 더미값으로 작동하도록 다 구현해 놓은 것이다.

이제 계산기가 만들어져 그걸 그대로 사용하기만 하면 더미값을 반환하던 계산기는 제대로된 계산기로 그대로 작동할 것이다.


근데 문제가 발생한다. A가 계산기를 만드는 중에 예상치 못하게 sum의 매개변수를 3개로 지정한 것이다.

그럼 B가 만들어 놓은 가짜 로직을 진짜 계산기로 바꾸어 실행했을 때 오류가 발생할 것이다.

이게 한 두개면 괜찮은데 ㅈㄴ 서로 아다리 안 맞아서 완전 개판이 났다고 해 보자.

그럼 감당이 안 되는 일이 발생할 것이다.


이런 일을 사전에 막기 위해 나타난 것이 인터페이스이다. 로직을 구성하는 사람과 실체를 구성하는 사람이

서로 미리 사전에 예약된 인터페이스를 통해 그 규격을 서로 맞추어 제작한다면 이런 일이 발생할 일이 없는 것이다.

A도 인터페이스의 규격대로 코드를 작성했을 것이고 B도 인터페이스의 규격에 맞춰 프로그램에 호출되도록 구현했을 것이다.

이렇게 되면 A가 계산기를 전부 만들고 나서 B에게 그대로 넘겼을 때 같은 인터페이스를 사용했으므로 문제없이 잘 작동할 것이다.


인터페이스는 상호간의 규격을 맞추기 위한 또는 기능을 하는 부품 생성을 위한 도구의 느낌이 강하고

추상 클래스는 만들려는 클래스의 최소 조건을 공통적으로 갖기 위한 부모 클래스 성향이 강하다.


인터페이스는 나중을 위한 올바른 상호작용을 기대하기 위해 사용되는 도구.

추상 클래스는 앞으로 만든 클래스에 공통적인 부분을 지정하고 최소 조건을 충족하도록 도와 주는 도구.

성향이 조금 다르다고 할 수 있다. 물론 인터페이스를 하나의 기능을 하는 단위(부품)으로 만들기 위해서도 많이 사용한다.

인터페이스를 이용해 기능을 부품 단위로 분리하여 사용하는 경우가 아주 많다는 것이다.



참고로 상속에서 클래스의 데이터 타입을 부모 클래스를 사용할 수 있다고 했는데

이건 인터페이스도 가능하다. 마찬가지로 인터페이스에서 정의하고 있는 메소드에 대해서만 사용이 가능하다.

여기서도 특정 클래스를 만들 때 필요한 인터페이스에 대한 정의들만 사용하는 클래스를 만든다면

데이터 타입을 인터페이스로 좁게 정의할 수도 있는 것이다.