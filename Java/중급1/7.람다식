



람다식이란 "식별자 없이 실행 가능한 함수"

함수인데 함수를 따로 만들지 않고 코드한줄에 함수를 써서 그것을 호출하는 방식이라고 생각하면 된다.

마치 익명 객체와도 같다. 람다식을 이용한 함수는 익명 함수라고도 한다.



람다식 사용법


(매개변수, ...) -> { 실행문 ... }의 형태를 갖는다.

(매개변수, ...)는 오른쪽 중괄호 { } 블록을 실행하기 위해 필요한 값을 제공하는 역할을 한다.

매개 변수의 이름은 개발자가 자유롭게 지정할 수 있으며 인자 타입을 명시하지 않아도 된다. 

'->' 기호는 매개 변수를 이용해서 중괄호 { } '바디'를 실행한다는 뜻으로 해석하면 된다.

{}에는 return될 값이 들어가게 되면 return을 명시적으로 사용할 때에는 {}를 꼭 써야하며

그렇지 않고 return될 값만 명시할 때에는 {}를 생략할 수 있다.

또 '()'는 매개변수가 하나일 경우 생략이 가능하다.

람다식을 통해 클래스, 객체를 생성하고 메소드를 호출할 필요 없이 메소드의 역할을 대신할 수 있다.

객체를 생성하고 메소드를 호출할 필요 없이 바로 return값을 반환하는 메소드로서도 사용이 가능하다는 뜻이다.



람다식의 기능에 중요한 기능이 하나 더 있다.

람다식을 이용하면 함수형 인터페이스의 추상 메소드를 람다식으로 구현 할 수 있다는 것이다.

함수형 인터페이스란 추상 메소드가 오로지 하나만 있는 인터페이스를 말한다.

추상 메소드를 하나만 갖는다는 것은 이미 구현이 완료된 default 메소드나, static 메소드는

있어도 문제가 없다는 것이다. 추상 메소드만 하나 있으면 함수형 인터페이스이다.

그리고 이러한 함수형 인터페이스의 유일한 그 추상 메소드를 람다식을 통해 구현할 수 있다.

그리고 그런 람다식으로 구현을 하면 객체가 만들어지는데 바로 익명 객체가 되는 것이다.

쉽게 말해서 함수형 인터페이스에 람다식을 이용하면 익명 객체를 만들어낼 수 있는 것이다.

예제를 보도록 하자.

interface MyFunction { 

int calc(int x, int y);

}

위에는 MyFunction이라는 인터페이스가 있고 calc라는 추상 메소드가 하나 만들어져 있다.

함수형 인터페이스인 것이다.

익명 객체를 만들 때를 기억하는가? 위의 인터페이스로 익명 객체를 만들면

MyFunction myf = new MyFunction(){
    public int calc(int x, int y){
        return 0;
    }
};

new를 통해 객체를 생성하고 뒤에 구현부를 {}안에 적어줌으로써 만들 수 있었다.

람다식을 이용한 객체 생성도 이런 비슷한 원리를 갖는다.

익명 객체에서 정의해야 할 추상 메소드의 매개변수와 return값이 람다식과 일치하면 익명 객체가 생성된다.

MyFunction myf = (int x, int y) -> {return 0;}

이 한 문장에 위의 모든 내용이 생략되어 있는 것이다.

람다식을 이용하는 이유이다. 훨씬 코드가 간결해 진다.

생략만 되었을 뿐 엄연한 객체 생성이기 때문에 myf 변수에는 레퍼런스값이 들어간다.


근데 뒤의 람다식 부분이 어떤 함수형 인터페이스에 대한 정의인 지는 어떻게 아는 거죠?

그건 앞에 타입에 명시가 되어 있기 때문에 알아서 인지를 한다.


그럼 이제 람다식을 통해 함수형 인터페이스의 객체 생성을 할 수 있다는 것을 알았다.

그러니 Runnable 같은 인터페이스도 람다식을 통해 객체를 만들어 줄 수 있는 것이다.

이 내용은 중급 2의 -> Synchronized와 이어지는 내용이다.


Runnable 인터페이스에는 run이라는 추상 메소드 하나가 선언되어 있는데

람다식을 통해서 바로 객체를 만들어 보자.

Thread 객체를 생성하기 위해서는 Runnable 인터페이스를 구현한 객체를 하나 필요로 한다.

하지만 람다식을 이용하면 Runnable 인터페이스를 구현하는 클래스를 생성할 필요 없이

바로 익명 객체를 만들어 Thread의 인자로 넘겨 줄 수 있다.

Thread thread = new Thread(() -> {
    run메소드에 들어갈 로직
})

이런 식으로 람다식의 바디('{}') 부분에 Runnable 인터페이스의 run메소드에 구현될

로직을 넣어 주면 바로 Runnable을 구현한 익명 객체를 만들 수 있다.

우리는 이렇게 생성된 thread 객체를 바로 이용할 수 있는 것이다.


이 경우에도 new Thread의 매개변수가 Runnable이라는 걸 컴파일러는 알고 있기 때문에

()안에 바로 람다식으로 정의해도 알아서 Runnable인터페이스 타입 객체를 생성하는 것이다

