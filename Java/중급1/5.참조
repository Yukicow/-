



reference라는 단어를 참 많이 사용하지만 아직도 그 정확한 의미를 잘 모른다.

그냥 단순히 메모리 주소값과 같다고만 생각하고 썼을 것이다.

심지어는 reference 변수가 단순히 객체를 가리킨다 라고만 생각했다.

내부적으로 reference라는 것이 어떤 의미이고 어떻게 동작하는 지 알아 보자.


먼저 reference(참조)는 reference value(참조 값, *해시코드)이다.

# 해시코드를 간단하게 말하면 해시 알고리즘에 의해 생성된 정수 값을 말한다.

이게 무슨 소리냐.

reference는 '참조'라는 말처럼 무엇인가를 참조하는 값이다.

무엇을 참조하는 지는 딱 감이 올 것이다. 바로 메모리 주소값이다.


java와 c++의 레퍼런스는 조금 다르게 동작한다. 

c++은 c언어의 포인터와 비슷하게 메모리 주소를 직접 가져다 사용하지만

java는 메모리 주소값을 참조하는 값을 매핑시켜 새롭게 맵핑된 값을 사용한다.

그 매핑된 값을 reference value, 참조값이라고 하는 것이고 reference value와 reference는 거의 같지만

참조하는 '값'의 관점에서는 reference value, '참조' 그 자체의 측면에서는 reference라고 할 수 있다.

java는 객체의 메모리 주소를 그대로 사용하지 않는다.

java에서 new 연산자를 사용하면 인스턴스의 메모리 주소 대신 주소에 연결된 참조값을 할당받게 된다.

참조값은 가상머신(Virtual Machine)에서 자동으로 생성되며, 객체구분을 위한 유일한 Key 값이 된다. 


reference variable(참조 변수)에는 이런 메모리 주소가 아닌 new연산자가 실행되고 나오는 참조값이 들어간다.

reference variable도 엄연히 메모리 공간을 차지하는 변수이고 안에는 참조값에 해당하는 데이터가 들어간다.

위에서 말했지만 참조값은 해시코드라고 했고 이러한 java에서 reference의 해시코드(value)는 4바이트짜리 정수값이다. 

그렇기 때문에 인스턴스 메모리를 할당할 때는 4바이트의 정수값을 객체변수에 할당하게 된다. 


Sun이라는 클래스를 만들었다.

public class Sun { 
    public int distance;  
    public int data; 
} 

Sun s1 = null; 

Sun s1 = null; 명령어로 s1이라는 reference 변수를 만들었다면 

단순히 메모리 공간이 없는 null을 가리키는 변수를 선언한 것일까? 아니다.

s1은 4바이트짜리 참조변수가 만들어진 것이다. s1 자체는 4바이트의 메모리 생성의 의미를 담고 있다. 

s1은 현재 4바이트의 메모리에 null값이 들어있다. 단순히 정수형 숫자를 담을 수 있는 4바이트짜리 메모리인 것이다.

s1에는 객체의 실제 메모리와 연결된 Sun형의 참조값(reference value)을 넣을 수 있다. 


s1.distance = 100; 

위의 명령어를 실행하면 일어나는 일을 풀어 쓰면

1. s1에는 참조값이 할당되어 있다. 

2. s1의 참조값과 연결된 주소를 검색하기 위해서 자바 시스템 내부의 인덱스 테이블을 검색한다. 

3. s1의 참조값에 연결된 주소를 인덱스 테이블에서 찾았다면 해당 메모리에 distance의 자리를 찾는다. 

4. s1의 [참조값]-[메모리]-[distance]를 찾았다면 데이터 1000을 할당한다. 

이것이 java 내부적으로 일어나는 것이다.


먼저 알아야 할 것은 자바에서 참조값을 만드는 방법은 연산자 new를 이용하는 방법밖에 없다는 것이다. 

참조값을 사용자가 직접 만들 수는 없고, 가상머신을 통해서만 참조값을 얻을 수 있다. 

그리고 가상머신에게서 참조값을 만들어 받는 방법이 바로 연산자 new를 사용하는 것이다.  


그럼 이제 아래와 같은 경우도 이해가 갈 것이다.

Sun s1 = new Sun();

Sun s2 = null;

s2 = s1;

이렇게 s2 = s1으로 초기화 하면 어떤 일이 일어날까?

참조값의 복사가 일어난다. 

위에서도 말했지만 객체를 참조하는 참조값을 유일한 해시코드이다.

특정 객체의 메모리 주소에 맵핑되는 참조값은 한 개 밖에 없다는 것이다.

그럼 s2가 s1으로 초기화 되었다는 것은 s2는 s1이 참조하고 있는 객체를 가리켜야 한다는 것이고

결국은 같은 참조값을 가져야 한다는 것이다. 그래서 s1의 참조값이 복사되어 s2의 메모리 공간 4바이트 정수값으로 들어간다.


위처럼 객체변수는 참조변수이며 참조변수끼리의 할당은 참조값 복사가 된다. 

참조값끼리 아무리 복사를 하더라도 객체 내부의 메모리 주소의 복사는 이루어지지 않는다. 단지 참조값만 복사된다. 

이러한 이유에서 자바에서는 값에 의한 호출(Call by Value)만 존재한다. 참조값 복사도 값복사에 해당하기 때문.

java에서는 절대로 메모리 주소가 직접 쓰이는 일이 없다는 뜻이다. 

하지만 메모리 주소를 참조하는 참조값을 통해 얼마든지 메모리 주소와 같은 효과를 가지고 사용할 수 있다.



이제 참조 변수도 엄연히 참조값이 담기는 메모리 공간을 갖는다는 것을 알았다.

그럼 이러한 참조값은 다른 곳에도 담길 수 있는 것이다. 예를 들면 배열같은 곳.

배열을 보면 특정 객체를 담는 배열이 있다. 이 때 배열에 객체를 전부 담을 수는 없다.

그리고 지금까지 알고 있던 잘못된 지식에 의하면 뭔가 머리가 복잡했다. 메모리 주소가 담긴다고 하기에는

데이터 타입이 설명이 안 되고.. 변수가 담기는 건 변수라는 개념이 담기는 개념이 아니고.. 뭔가 어리둥절했다.

하지만 이제 확실하게 배열 안에는 객체의 메모리 주소를 참조하는 참조값이 들어간다는 걸 알 수 있다.

그리고 모든 객체 변수는 참조값을 담는다는 것도. 데이터 타입이 객체로 지정한다고 해서 객체 자체가 담기는 것이 아닌

모두 4바이트 정수형의 참조값이 담기는 것이다. 하지만 그렇다고 데이터 타입을 int로 지정한다? 이건 말이 안 된다.

안에 있는 데이터가 정수형이여도 그것이 무언가를 참조하는 것이라는 걸 명시해야 한다. 그게 바로 데이터 타입을

객체로 지정해 주어서 어떤 객체를 참조하는 것인 지, 어떤 데이터 타입이 가능한 참조값인 지를 나타내는 것이다.

데이터 타입을 int로 해도 된다는 것은 c언어로 비유하면 메모리 주소값도 엄연히 숫자의 나열이니 포인터가 아닌 int형으로 지정해도

메모리 주소에 똑같이 접근할 수 있다는 개소리와도 같다.




