




SQL의 기본 문법에 대해 몇 가지만 알아 보자.

# 참고로 sql을 사용할 때에 앞에 붙는 숫자는 그냥 행을 나타내는 것이다. 두 번째 줄(행) 부터 숫자가 붙는다.

# 혹쉬 뒤에 가끔 ';'를 안 붙여서 명령어가 실행이 안 될 때가 있는데 그 상태로 엔터를 누르면 개행이 일어난다. 거기다 ';'를 붙여 주면 된다.


1. create table

테이블을 만드는 예약어이다. 

테이블이란 RDBMS의 기본적 데이터 저장구조이다. 한 개 이상의 열(column)과 0개 이상의 행(row)으로 구성된다.

관계형 데이터베이스(RDB)에서 열(colunm)은 속성(property),필드(field)라고도 불리며 행(row)는 레코드 또는 튜플로 불리기도 한다.


처음 테이블을 만들 때에는 속성을 지정한다. 만들 속성의 개수 만큼 속성의 이름을 지정하면 된다.

그럼 각 열에 대해 순서대로 이름이 지정되고 우리가 그 속성에 데이터를 넣을 때마다 행에 차례대로 데이터가 저장된다.


예를 들어 첫 번째 열을 id라고 지정하고 id열에 데이터 10개를 넣으면 id에 해당하는 열을 기준으로 총 10개의 행이 생기는 것이다.

그리고 각 행에는 id에 대한 데이터 값이 담기게 된다.


예시를 보고 이해해 보자.

먼저 테이블부터 만들어야 한다.

create table member (
    id varchar(20) primarykey,
    pw varchar(20),
    name varchar(20));


# 위처럼 가독성을 위해 개행을 많이 사용한다.


위는 3개의 속성(열)을 갖는 테이블을 만든 것이다.

create table을 통해 테이블을 생성하고 그 뒤에 테이블의 이름인 member를 적었다.

()안에는 각 속성과 속성에 저장될 데이터 타입, 데이터의 제약조건을 적는다.

각 요소는 ','를 통해 구분했고 맨 앞에 오는 문장이 속성이 된다.

뒤에 오는 varchar는 데이터 타입이고 id 뒤에 있는 primarykey 중복 불가를 나타내는 제약 조건이다.

# 데이터 타입과 제약 조건은 따로 정리해 두었다.


1열에는 id가 2열에는 pw가 3열에는 name이 속성으로 지정되었다.

앞으로 각 열의 행에는 그에 대응하는 데이터들이 들어갈 것이다.


id는 primary key 제약 조건을 갖기 때문에 같은 값을 갖는 데이터가 중복해서 id 행에 저장될 수 없다. 

id는 고유한 것이기 때문에 primary key로 지정했다. 

# primary key속성의 value는 한 번 지정되면 바꿀 수 없다.


*중요) 

행은 모든 속성에 대한 값을 갖는 가로열 전체를 하나로 본다.

이게 무슨 말이냐면 우리가 위에서 속성을 지정해 주고 table을 만들었다.

우리는 속성 하나에 행 하나 이런 식으로 인지했겠지만 사실 그렇지 않다.

속성을 모두 지정한 즉, 행 하나는 속성에 해당하는 값을 모두 갖는다는 것이다.


그림으로 이해하면 조금 편할 것 같다.

ㅡ열ㅡㅡ id ㅡㅡㅡ ps ㅡㅡㅡ name ㅡㅡㅡ
행1    ㅣ'comi' ㅣ'1234' ㅣ'comi1234'
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
행2    ㅣ'comco'ㅣ'12345' ㅣ'민우'
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
행3    ㅣ'oioi' ㅣ'43210' ㅣ'창수'
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

여기서 보통은 id속성 중에 행1이 'comi'이고 행2가 'comco'이고 이렇게 생각하겠지만

행1 전체가 하나의 레코드이다. id,ps,name 속성을 갖는 하나의 행(레코드)인 것이다.

레코드는 가로열을 나타내는 말이고 모든 속성에 대해 데이터가 들어가 실제 자료의 단위가 된 레코드는 개체(entity)라고 한다.




2. select

검색 기능을 하는 예약어이다.

만든 테이블이나 테이블에 있는 값을 보고 싶을 때 사용한다.

*는 '모든' 을 표현하는 특수문자이다.


select 열1,열2 from 테이블명 where 조건식

위와 같은 형태로 사용된다. 열1과 열2에 해당하는 필드를 모두 검색한다.


select * from table명

tableName에 해당하는 테이블의 데이터를 읽는다.


그럼 table이 뭐가 있는 지 궁금할 때에는 어떡하죠?

select * from tab 이렇게 사용하면 데이터 베이스에 저장된 모든 테이블명을 검색한다.


조건식에는 여러 조건을 넣을 수 있다. 조건식에 해당하는 레코드를 검색한다거나 말이다.


예를 들어 select * from table where id=1234; 

위와 같이 적으면 table 테이블에서 id열 중 그 값이 1234에 해당하는 행을 출력하는 것이다.

행 한 줄 전체를 보여 준다는 얘기이다. 레코드는 모두 모여서 하나이다.

행1 의 id 속성의 value는 뭐고 ps 속성의 value는 뭐고 이런 식으로 간다는 얘기다.

열에 따라 행을 가르는 게 아니고 열은 하나의 행이 갖게될 속성이다.


위를 이해했다면 밑에 오는 조건식도 이해할 것이다.

SELECT * FROM sample WHERE name='아무개';

sample 테이블에서 name 속성에 '아무개'를 값으로 갖는 모든 레코드 출력.


select는 검색으로 각 행에서 원하는 속성(필드)만을 볼 수도 있는데

조건식에 id = 'comi'에 해당하는 레코드에서 pw 속성(culumn)에 대한 value를 보고 싶다면

select pw from table명 where id = 'comi'; 이런 식으로 사용할 수 있다는 것이다.

# 사실 좀 더 정확히 말하면 select가 필드를 검색하는 기능인데 *가 필드 전체를 검색하기 때문에 하나의 레코드를 검색한 거라고 표현했다는 게 더 맞을 듯 하다.


조건식은 종류가 많으니 차차 알아가도록 하자.



3. insert into 테이블명 (속성,속성...) values ('값', 값...)


내가 만든 테이블에 값을 넣어 주는 예약어이다.

각 속성(열 = culumn)에 해당하는 key값을 적어 주고 순서에 맞게 값을 넣어 주면 된다.

값을 넣어 줄 때에는 속성이 문자에 해당하면 ''안에, 숫자(수치)형이라면 ''없이 적는다. 

이 규칙은 value에 대해 모두 적용되는 내용이다. 나중에 조건식을 쓸 때에도 문자와 숫자형을 잘 구분해서 value를 적어야 한다.


이 예약어는 행을 만드는 명령어이고 실제로 바로 적용되지는 않는다.

그래서 만들어진 행을 실제로 table에 적용하기 위해서는 commit이라는 명렁어를 사용한다.


이제는 행을 완전히 이해했을 것이다.

insert 예약어를 통해 행을 만들 때에는 당연히 모든 속성의 value를 넣어서 생성해야 한다.

안 넣어도 되던데요?

그건 NULL값이 자동으로 들어가서 그런 거다.

NULL값이 들어가지 못 하는 속성의 경우 에러가 나니 그런 속성이 있다면 꼭 넣어 주길 바란다.



4. delete


delete from 테이블명 where 조건식;

위와 같은 형태로 사용되며 조건식에 해당하는 레코드를 삭제하는 예약어이다.


이제 진짜 행에 대해 이해했다면 레코드를 삭제한다는 의미를 알 것이다.

레코드를 삭제한다는 것은 행 한 줄을 모두 삭제하는 것이다.

아예 행이 하나 사라지는 것이다.


여기서 행에 대한 이해가 중요한 이유가 나온다.

만약 행에 대해 이해를 잘 못 했다면 delete 속성 from table 을 통해서

속성에 해당하는 모든 행값을 지울 수 있겠지? 하고 생각했을 것이다.

행은 속성을 모두 갖는 것을 하나의 묶음으로 보기 때문에 

특정 속성에 해당하는 value들만 모두 삭제하는 건 불가능하다.


delete의 주의점.

delete는 테이블로 부터 완전히 레코드를 삭제하는 기능은 아니다.

따라서 나중에 데이터를 복구할 수 있다. 

하지만 만약에 UNIQUE나 primary key등으로 유일한 값을 지정한 속성이 있을 때 

delete한 행의 유일 속성의 value와 같은 value를 사용하는 다른 행이 있다고 해 보자.

나중에 delete한 행을 복구할 때 제약 조건에 위배된다는 에러가 발생할 것이다.

혹시 그럴 일이 있을 지 모르니 조심하자. 참고로 완전 삭제는 truncate라는 예약어가 있다.


commit을 사용한다.




5. update


update 테이블명 set 속성='값', 속성='값'.. where 조건식

위와 같은 형태로 사용되며 조건식을 만족하는 데이터를 변경하는 예약어이다.


예를 들어 

update table set password = '1234' where id = 'comi';

라고 한다면 id 속성의 레코드가 'comi'에 해당하는 행의 password 속성 값을 '1234'로 바꾸는 것이다.


조건식을 안 넣으면 deafult로 모든 행의 속성이 한 번에 변경된다.

예를 들어 

update table set ps='1234', name='comi';

위처럼 update 예약어를 사용하면 모든 행의 ps와 name속성의 value가 '1234'와 'comi'로 변경된다.


commit을 사용해야 한다.





6. truncate

truncate는 delete와 같지만 데이터의 완전 삭제라는 점과 테이블의 모든 행을 삭제한다는 차이점이 있다.

delete 명령어는 삭제할 행이 많을 경우 처리속도가 늦어질 수 있개 때문에

where 조건절 없이 모든 행을 삭제할 경우는 truncate table 명령어를 사용한다. 

truncate의 경우 테이블을 남겨 두고 테이블의 모든 레코드만 지운다.


TRUNCATE TABLE 테이블명; 의 형태로 사용할 수 있다.



7. drop

drop은 데이터(레코드)가 아닌 테이블 자체를 삭제하는 데에 사용하는 예약어이다.

하지만 오라클 10g부터는 테이블이 삭제되는 것이 아니라 윈도우의 휴지통 개념처럼 잠시 삭제된다고 한다.

# 복구 가능하다는 뜻일 듯.

DROP TABLE 테이블명; 형태로 사용한다.



commit은 모든 작업을 정상적으로 처리하겠다고 확정하는 명령어이다.

TRANSACTION(INSERT, UPDATE, DELETE)작업 내용을 실제 반영할 때에 사용한다.

하지만 commit을 하고 나면 복구하기가 어렵고 rollback도 commit 이전에만 가능하다.







8. ALTER

ALTER는 무언가 수정을 할 때에 사용하는 sql 예약어이다.

테이블,시퀀스 등등 모두 ALTER를 사용한다.


8-1 ADD

ADD는 필드를 추가할 때 사용하는 예약어이다.

ALTER TABLE 테이블명 ADD 삽입할 필드명 삽입할 필드 타입 옵션

ex) alter table mytable add name varchar(20);


위의 형태로 사용할 수 있다.


8-2 RENAME

RENAME은 테이블명 또는 필드명을 변경할 때 사용하는 예약아이다.

ALTER TABLE 테이블명 RENAME 새로운 테이블명

ALTER TABLE 테이블명 RENAME COLUMN 변경할 필드명 TO 새로운 필드명 타입




8-3 MODIFY INVISIBLE/VISIBLE

컬럼의 순서를 변경할 때 사용한다.

위로 올리고 싶은 순서 이후에 있는 모든 컬럼을 INVISIBLE을 통해 비활성화하고

원하는 컬럼이 올라가게 되면 다시 순서대로 VISIBLE을 통해 활성화 시켜 주면 순서가 변경된다.

ALTER TABLE 테이블명 MODIFY 컬럼명 INVISIBLE

ALTER TABLE 테이블명 MODIFY 컬럼명 VISIBLE



8-4 MODIFY 타입

속성의 데이터 타입을 변경시킬 때 사용한다.

ALTER TABLE 테이블명 MODIFY 걸럼명 데이터 타입




9. ORDER BY

ORDER BY는 SELECT에서 정렬의 순서를 정할 때 사용한다.

SELECT * FROM 테이블명 ORDER BY 컬럼명 

위의 형태로 사용하면 컬럼을 오름차 순으로 정렬한다.

숫자형의 경우 작은 숫자부터 첫 번째에 오고 문자형일 경우 a~z 순으로 정렬 날짜는 가장 오래된 날짜가 처음이 된다.


내림차 순으로 정렬하는 것도 가능한데 ORDER BY DESC 로 DESC(descending의 약자)를 붙여주면 된다.


또 정렬 조건을 여러개 붙일 수도 있다.

','를 통해 구분하면 된다. 기본적으로 왼쪽을 가장 우선순위로 취급한다.

즉, SELECT * FROM 테이블명 ORDER BY CLOUMN1 DESC, COLUMN2 

위처럼 하면 컬럼1에 대해서 일단 내림차 순으로 정렬을 하고 그 값들을 다시 컬럼2의 오름차 순으로 정렬한다.

컬럼1의 내림차 순 정렬의 조건을 유지하면서 컬럼2의 정렬을 한다는 것이다.

컬럼2의 조건에 의해 컬럼1의 내림차 순이 무시될 것 같은 경우 정렬되지 않는다는 것이다.
