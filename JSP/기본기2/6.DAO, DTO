



실무에서 많이 사용하는 기법이다.


DAO(Data Access Object)

데이터 베이스에 접속해서 데이터 추가,삭제,수정 등의 작업을 하는 클래스이다.

필요한 기능을 클래스 내에 필드나 메소드로 정의하여 만들어 사용해야 한다.


DTO(Data Transfer Object)

DAO 클래스를 이용하여 데이터 베이스에서 데이터를 관리할 때 데이터를 일반적인 변수에 할당하여 작업할 수도 있지만 

해당 데이터의 클래스를 만들어 사용한다. 데이터를 위한 클래스라고 볼 수 있다.



쉽게 말해서 지금까지 우리는 Driver 생성하고 Connection 연결하고 Statement,ResultSet 등등 해야할 것이 너무나도 많았다.

그렇게 일일히 사용할 때마다 그 로직들을 작성하지 않고 DAO와 DTO클래스를 만들어서 필요한 기능을 정의하고

만들어진 객체의 필드와 메소드를 이용해 데이터 베이스에 접근하고 데이터들을 다룰 수 있게 클래스를 만드는 것이다.



PreparedStatement

PreparedStatement는 Statement 객체를 생성하고 query문을 일일히 작성해서 중복되는 내용이 많아지고 
 
가독성이 떨어지는 단점을 보완하고 이를 최소화할 수 있도록 만들어진 것이다.


PreparedStatement 객체명 = Connection객체.prepareStatement("SQL문");

의 형태로 PreparedStatement객체를 생성하고 SQL문에 나중에 따로 넣어 줄 value 값은 '?'로 표현해 놓는다.


ex)

PreparedStatement pre = conn.prepareStatement("insert into member (name,id,pw) values (?,?,?);


문자형이 들어갈 지 숫자형이 들어갈 지 알 수 없지만 그냥 '?'로 통일한다.

어차피 메소드로 구분해서 안에 들어갈 값을 지정할 수 있다.


그럼 생성한 객체의 set<>() 메소드를 이용해서 '?' 안에 값을 넣어 줄 수 있다.

예를 들어 String 값을 넣을 때는 setString(1, "문자열")의 형태로 사용할 수 있다.

앞에 숫자는 '?'의 순서다. 가장 앞의 '?' 부터 index 1을 부여 받는다.


다 지정하고 나면 이제 위의 쿼리문은 '?'에 값이 들어간 상태가 된다.

그럼 이제 쿼리문을 실행하면 되는데 기존 Statement 객체를 사용하듯이 executeUpdate()를 사용하면 된다.

ex) pre.executeUpdate();

당연히 메소드의 반환값은 int이기 때문에 int형 변수로 받아줘야 한다.


한 번 인덱스로 지정받은 값들은 set<>()메소드를 통해 값을 계속 새로 지정해 줄 수 있다.

clearParameters()라는 메소드도 있다.'?' 안에 들어가 있는 인자들을 없애 주는(다시 '?'로 만듬) 메소드이지만

set을 통해 새로운 값을 설정해 주면 알아서 clear되기 때문에 굳이 필요하지는 않다.

하지만 몇몇 경우에서는 명시적으로 해 주는 것이 더 좋을 때가 있다고는 한다. # 써서 나쁠 건 없으니 쓰는 게 낫다는 뜻




*중요) 커넥션 풀과 일반 커넥션을 이용한 DTO prepareStatement 객체 만들기


DTO생성자에 DAO를 생성할 때 만들어둔 Connection객체와 Statement객체를 인자로 넘긴 다음

멤버 변수에 값을 초기화 해주고 따로 Connection,Statement 객체를 생성하지 않고 사용하려 했는데 안 되는 일이 발생했다.

왜 그런가 고민해 보니 DAO클래스에서 finally 문에서 != null 이 아니면 객체들을 연결을 다 닫았던 것이 생각났다.

DAO에서 ArrayList에 DTO 객체들을 다 저장하고 마지막에 Connection과 Statement,ResultSet객체 모두

null이 아니었기 때문에 연결을 다 끊어 준 것이다. 그래서 인자로 그 객체들(레퍼런스 주소)을 넘겨도

이미 없어진 객체들이기 때문에 사용할 수 없었던 것이다.

DAO 뿐만 아니라 모든 DB와의 연결 로직은 마지막에 finally로 닫아 주기 때문에 다른 곳에 보내 사용할 수가 없다.


커넥션 풀도 마찬가지이다.

결국은 로직 실행후 커넥션을 반납하기 때문에 재사용할 수 없다.

하지만 커넥션 풀의 경우 객체 자체가 사라지는 것은 아니니 DTO에서 메소드가 계속 호출을 해도 

완전히 새로 커넥션을 연결하는 것 보다는 부담이 좀 덜하지 않을까 싶다.



위의 원리를 이용해서 Connection를 연결하는 로직을 따로 만들어 메소드로 사용하기도 한다.

연결을 끊어 주어서 사용을 못 한다는 것은 연결을 끊지만 않으면 사용이 가능하다는 것이다.

finally 문을 생략하여 연결을 안 끊고 Connection 객체를 return으로 반환하는 메소드를 만들어서

다른 로직들에서 그 메소드를 호출해 Connection 객체 생성 과정을 빠르게 만들 수 있다.