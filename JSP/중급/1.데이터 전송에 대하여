





Method 종류

GET : 서버에게 조회할 리소스를 요청한다. (READ, 조회)

POST : 서버에게 본문(body)에 생성할 데이터를 삽입하여 전송한다. (CREATE, 생성)

PUT : 서버에게 본문에 수정할 데이터를 삽입하여 전송한다. (UPDATE, 수정)

DELETE : 서버에게 삭제할 리소스를 요청한다. (DELETE, 삭제)

PATCH : PUT과 비슷하지만 일부만 수정한다는 점에서 다르다.

그외에도 HEAD, CONNECT, OPTION 이 있다.


메소드의 종류는 여러 가지가 있지만 오늘은 do와 get에 대해서만 알아 보겠다.



GET 이란?

GET 은 클라이언트에서 서버로 어떠한 리소스로 부터 정보를 요청하기 위해 사용되는 메서드이다. 

예를들면 게시판의 게시물을 조회할 때 쓸 수 있다.

GET을 통한 요청은 URL 주소 끝에 파라미터로 포함되어 전송되며, 이 부분을 쿼리 스트링 (query string) 이라고 부른다.

방식은 URL 끝에 " ? " 를 붙이고 그다음 변수명1=값1&변수명2=값2... 형식으로 이어 붙이면 된다.

예를들어 다음과 같은 방식이다. 

www.example.com/show?name1=value1&name2=value2

서버에서는 name1 과 name2 라는 파라미터 명으로 각각 value1 과 value2 의 파라미터 값을 전달 받을 수 있다.



GET의 특징

1. GET 요청은 캐시가 가능하다. 

GET을 통해 서버에 리소스를 요청할 때 웹 캐시가 요청을 가로채 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. 

HTTP 헤더에서 cache-control 헤더를 통해 캐시 옵션을 지정할 수 있다.


2. GET 요청은 브라우저 히스토리에 남는다.


3.GET 요청은 북마크 될 수 있다.


4. GET 요청은 길이 제한이 있다.

GET 요청의 길이 제한은 표준이 따로 있는건 아니고 브라우저마다 제한이 다르다고 한다. 


5. GET 요청은 중요한 정보를 다루면 안된다. ( 보안 )

GET 요청은 파라미터에 다 노출되어 버리기 때문에 최소한의 보안 의식이라 생각하자.


6. GET은 데이터를 요청할때만 사용 된다.



POST 란?

POST는 클라이언트에서 서버로 리소스를 생성하거나 업데이트하기 위해 데이터를 보낼 때 사용 되는 메서드다. 

예를들면 게시판에 게시글을 작성하는 작업 등을 할 때 사용할 된다.

POST는 전송할 데이터를 HTTP 메시지 body 부분에 담아서 서버로 보낸다. ( body 의 타입은 Content-Type 헤더에 따라 결정 된다.)

GET에서 URL 의 파라미터로 보냈던 name1=value1&name2=value2 가 body에 담겨 보내진다 생각하면 된다.

POST 로 데이터를 전송할 때 길이 제한이 따로 없어 용량이 큰 데이터를 보낼 때 사용하거나 

GET처럼 데이터가 외부적으로 드러나는건 아니라서 보안이 필요한 부분에 많이 사용된다.

( 하지만 데이터를 암호화하지 않으면 body의 데이터도 결국 볼 수 있는건 똑같다. )

보안면에서 GET보다는 낫지만, 개발자 도구에 의해서 노출되기 쉽기 때문에 암호화해서 전송해야 한다는 것이다.

POST를 통한 데이터 전송은 보통 HTML form 을 통해 서버로 전송된다.



POST의 특징

1. POST 요청은 캐시되지 않는다.


2. POST 요청은 브라우저 히스토리에 남지 않는다.


3. POST 요청은 북마크 되지 않는다.


4. POST 요청은 데이터 길이에 제한이 없다.



GET 과 POST 의 차이점 

GET과 POST의 특징만 보아도 차이가 나긴하지만 추가적으로 차이점을 정리해보면 다음과 같다.


사용목적 : GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다.

DB로 따지면 GET은 SELECT 에 가깝고, POST는 Create 에 가깝다고 보면 된다.


요청에 body 유무 : GET 은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없다. 

POST 는 body 에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재한다.


멱등성 (idempotent) : GET 요청은 멱등이며, POST는 멱등이 아니다.


멱등이란?

멱등의 사전적 정의는 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.

GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같을 것 이다. 

반대로 POST는 리소스를 새로 생성하거나 업데이트할 때 사용되기 때문에 멱등이 아니라고 볼 수 있다. 

(POST 요청이 발생하면 서버가 변경될 수 있다.)


쉽게 정리하면 get은 요청을 하고 데이터를 받아오는 경우에 많이 사용하고

post는 뭔가 수정을 하거나 업데이트 해야 하는 경우에 사용한다는 것이다.




HTTP


http 프로토콜의 데이터 전송 방식은 조금 복잡하지만 지금 우리에게 필요한 것만 뽑아서 얘기하면


요청하는 클라이언트 PC, 브라우저정보, 사용자 언어 환경, 쿠키 등의 다양한 클라이언트 환경에 대한 정보를 가지고 있는 header와

실제 우리가 전달하는 데이터의 내용이 담기는 body가 있다.



content-type이란 

HTTP 통신에서 전송되는 데이터의 타입을 나타내는 header정보 중 하나이다.

Content-Type에 따라 데이터를 받는 측에서는 데이터를 어떻게 처리해야 할 지 판단한다.

body에 데이터가 담겨서 전송되는 경우 content type에 대한 속성 정의가 꼭 필요하다.



get 방식의 경우 url에 데이터가 담겨서 전송되기 때문에 content type에 대한 정의가 필요가 없다.

"Content-Type HTTP header should be set only for PUT and POST requests."

긴 내용을 좀 줄여서 갖고와 보았다. content-type은 put과 post 요청 방식에서만 설정해 주면 된다고 한다.



우리가 다음에 배울 내용이 파일 업로드이기 때문에 파일 업로드에 필요한 post방식을 이해하고 넘어가자.

파일 업로드는 데이터 베이스를 건드는 일이다. 업데이트에 해당하기 때문에 post방식을 사용하고 content-type에 대한 설정이 필요하다.


타입에 대한 정의는 type/subtype 으로 할 수 있는데 type은 주타입, subtype은 확장자와 같은 부가 타입에 해당한다.

예를 들어 img파일을 넘긴다고 한다면 type에는 img가 들어갈 수 있고 subtype에는 png,jpg 등등이 들어갈 수 있다.

우리가 <script type = "text/javascript"></script> 태그에서 type을 지정해 주는 형식도 이런 원리이다.

저기서 type이랑 enctype의 타입 모두 *MIME의 타입에 해당한다. 

스크립트 태그에 type을 정의하는 것은 웹 브라우저에서 스크립트 안의 내용을 해당 type으로 파싱해야 함을 알리는 것이다.
 



*MIME

MIME은 Multipurpose Internet Mail Extensions의 약자로 파일 변환을 뜻한다고 할 수 있다.

전자 우편을 위한 인터넷 표준 포맷이다. 그러나 MIME 표준에 정의된 content types은 

HTTP와 같은 통신 프로토콜에서 사용되며, 점차 그 중요성이 커지고 있다.

MIME는 이메일과 함께 동봉할 파일(이진 파일)을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되었기 때문에 

이름이 Internet Mail Extension이다. 그렇지만 현재는 웹을 통해서 여러 형태의 파일 전달하는데 쓰이고 있다.

즉, 우리는 MIME을 통해 여러 형태의 파일들을 웹 상에서 주고 받을 수 있는 것이다.

이렇게 MIME에 의해 인코딩된 파일들에는 각각 타입이 있는데 이를 'MIME 타입'이라고 한다.

# 현재는 Media type(미디어 타입)이라고 부른다.

원래 어떤 파일이었고 현재 그 파일이 인코딩된 상태임을 알리기 위해 MIME 타입을 이용한다.

enctype을 정의한다는 것은 파일이 인코딩되어 어떤 MIME Type이 된 것인 지를 수신 측에 알리는 것이다.



우리는 다음에 배울 내용은 form태그에서의 enctype을 다루는 것이다. encoding type을 말한다. 

여기서 인코딩과 디코딩 개념을 다시 잡고가면 인코딩(encoding)은 정보의 형태나 형식을 변환하는 처리나 처리 방식이다.

MIME에서의 인코딩은 바이너리 파일을 텍스트 파일로 만드는 것을 말한다.

이메일이나 기타 네트웍 상에서 데이터를 교환할 때 MIME에 의해 인코딩되어 텍스트의 형식으로 보내진다.

디코딩은 그런 텍스트 파일을 다시 바이너리 파일로 바꾸는 것이다.

enctype은 데이터가 보내질 때 어떤 형태로 인코딩될 지에 대한 것을 부여해 주는 속성이다.

전달될 데이터를 인코딩하는 형식을 지정하기 때문에 전달될 데이터의 형식에 맞게 설정해 주는 게 바람직하다.



근데 왜 인코딩을 통해 바이너리 파일을 텍스트 파일로 바꿀 필요가 있는가.

https://ltvw.tistory.com/entry/%EB%A7%88%EC%9E%84-%ED%83%80%EC%9E%85-MIME-Type-%EB%AF%B8%EB%94%94%EC%96%B4-%ED%83%80%EC%9E%85Media-Type-%EA%B0%9C%EA%B4%84

이 사이트에 잘 정리되어 있으니 이걸 보도록 하자.

대충 정리하면 

이메일이나 기타 네트웍 상에서 데이타를 교환하는 시스템은 최초 아스키 문자로 이뤄진 파일만을 전송하는 것을 전제로 제작되어서

아스키 문자로 표현 못 하는 다른 나라 문자나 1바이트 단위로 저장되는 바이너리 파일 등은 데이터 교환이 안 됐다.

그래서 7비트 체계인 아스키 코드로 표현할 수 없는 그런 파일들을 특정 인코딩 기법을 통해 아스키 코드로 표현하여 

문자로 만든 다음 보내고 보내진 문자를 디코딩하여 바이너리 파일 등으로 다시 만들어 그 컴퓨터에서 쓸 수 있게 했다. 

뭐 이런 느낌인 것 같다.



그렇다면 encoding type이 뜻하는 것은 현재 내가 form을 통해 전달할 파일은 ~~형식이였기 때문에

그 파일 종류에 해당하는 MIME 인코딩 방식을 통해 인코딩해서 보냈다! 를 알리는 것이다.

그래야 받는 쪽에서도 "아 이건 이 파일이었었구나", "이 방식으로 인코딩한 거구나"를 알고 

다시 그에 맞는 디코딩 방식을 이용하거나 해석하여 운용을 할 수가 있다.



MIME타입에는 종류가 여러 가지가 있다.

개별파트와 멀티파트 타입으로 나뉜다.


개별파트 타입

1. text : 텍스트를 포함하는 모든 문서를 나타낸다.

2. image : 모든 종류의 이미지를 나타낸다. 애니메이션되는 이미지는 이미지 타입에 포함되지만 비디오는 포함x

3. audio : 모든 종류의 오디오 파일들을 나타낸다.

4. video : 모든 종류의 비디오 파일들을 나타낸다.

5. application : 모든 종류의 이진 데이터를 나타낸다.


멀티파트 타입

multipart를 말한다. 

MIME Type들이 개별적인 파트로 나누어지는 문서에서 MIME Type들이 각 Type에 맞게 파트별로 나누어지는 것을 말한다.

개별파트 타입의 파일이 단일이 아닌 여러개로 보내어질 때 이것을 사용한다.

그래서 보통 파일 전송에서 사용하는 것이다.



위에 저렇게 많은 미디어 타입이 있지만 enctype에는 사용할 수 있는 미디어 타입은 총 3가지이다.

enctype을 설정해 주지 않으면 default로 application/x-www-form-urlencoded가 속성값으로 들어가는데

이 방식은 데이터가 하나의 큰 query string 형태로 서버에 전송된다. 

get 방식에서 url 뒤쪽에 key와 value를 담아서 데이터를 넘기던 것을 기억하는가?

그것과 똑같이 key와 value를 일렬의 문자열로 &로 구분해서 나열하고 데이터를 보내는 형식이다.


application/x-www-form-urlencoded의 인코딩 방식은 일렬로 모든 데이터를 key와 value로 구분해 표현하고

아스키 코드에 해당하지 않는 문자들은 특유의 인코딩 방식으로 처리를 하다 보니 %3A 이런 식으로 바뀌어 데이터로 전달된다.

그래서 아스키 코드에 해당하지 않는 문자를 많이 사용하거나 바이너리 파일을 데이터로 넘겨야 할 경우에 문제가 생긴다.

%3A가 진짜 %3A를 넘기려고 한 것일 수도 있고 특정 문자가 %3A로 변환된 것일 수도 있다.

그리고 key에 대해 하나의 value만 갖기 때문에 파일을 예로 들면 파일 이름에 대한 value와 파일 자체의 value 등등

하나의 key에 다 담을 수가 없다. 파일이 담고 있는 각 value에 대한 key가 구분이 안 된다는 것이다.

이런 경우의 수가 겹쳐져 디코딩 시 정확도가 떨어질 확률이 높아지게 되기 때문에 

application/x-www-form-urlencoded 방식은 파일을 업로드하는 데에 적합하지 않다.


그래서 multipart/form-data가 필요하다.

multipart/form-data 방식은 각 데이터의 content-type에 맞는 인코딩 방식을 사용하도록 한다.

이미지 파일이면 이미지 파일, 영상 파일이면 영상 파일, input 태그에 대한 key value를 필요로 한다면

그에 맞는 application/x-www-form-urlencoded 방식 등등을 block으로 구분해 각 데이터에 맞는 인코딩 방식을 사용한다.


multipart/form-data 방식을 통해 input태그와 이미지 파일 하나를 보낸다고 가정하면

input태그에 대한 각 key와 value 값들이 block단위로 application/x-www-form-urlencoded 방식으로 진행되고

이미지 파일은 그 이미지 파일에 대한 block에서 이미지 파일에 대한 인코딩 방식으로 구분되어 데이터가 전송된다.

이런 블럭을 형성하는 문자열이 존재하는데 이러한 경계를 boundary라고 하고 시스템 내부적으로 해시코드마냥 랜덤하게 구현된다.

이미지 파일에 대한 인코딩 방식을 구체적으로 보면 

------WebKitFormBoundarykZUO6ei4rflEsHOK
Content-Disposition: form-data; name="uploadedFiles"; filename="1618976872.png"
Content-Type: image/png

weklnfinfiqenfiqgb~~~...


------WebKitFormBoundarykZUO6ei4rflEsHOK 이부분이 boundary이고

그 밑으로 Disposition부분에 key와 value에 해당하는 각 데이터가 분리되어 있다.

그리고 content-type이 명시되어 있다. 저 content-type 덕분에 이 블록에 해당하는

데이터가 어떤 형식인 지 구분이 가능한 것이다. 데이터를 받는 쪽은 그에 맞는 수행을 할 것이다.

그 밑으로는 이미지 파일에 대한 바이너리 데이터가 문자로 인코딩되어 저장되어 있다.


application/x-www-form-urlencoded 방식이었다면 위의 이미지 파일의 바이너리 데이터와

이미지 파일의 이름에 대한 데이터가 저렇게 각각 따로 존재할 수가 없었을 것이다.

name="uploadedFiles" 이 부분의 uploadedFiles이 key값이 되고

이미지 파일 이름과 이미지 파일 바이너리 데이터가 value값이 됐어야 할 텐데

하나의 key에 둘의 데이터가 모두 담길 수 없으니 input태그에 바로 올라와 있는

이미지 파일 이름이 value값으로 선택되어 들어갔을 것이다.


구체적인 예시를 보면

POST /board/write HTTP/1.1
Host: localhost:8080
...
Content-Type: application/x-www-form-urlencoded
...

writer=writer&...&uploadedFiles=1618976872.png

이런 형태를 가졌을 거란 것이다.


이러한 이유 때문에 아스키에 해당하지 않는 문자나 여러 파일을 다룰 때에는

application/x-www-form-urlencoded이 아닌 multipart/form-data 방식을 사용하는 것이다.


근데 application/x-www-form-urlencoded 방식으로 인자 넘길 때 한국어 ㅈㄴ 썼는데요.

얼마 ㅈ도 안 되는 한국어 그거 조금 갖고는 위의 경우의 수에 겹칠 확률은 ㅈ도 없다.

ㅈㄴ 긴 바이너리 데이터나 아스키 코드에서 벗어난 문자를 쓸 때에나 multipart/form-data를 사용하면 된다.


그리고 마지막으로 위의 두 가지 말고 form 태그에서 사용되는 형식이 text/plain인데

실제로 쓰일 일은 거의 없다고 한다.

