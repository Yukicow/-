







jsp에서 많이 사용되는 패턴 몇 가지에 대해 알아 볼 것이다.



1. url 패턴

url 패턴이란 그냥 url을 어떤 형태로 매핑할 것인 지에 대해 다루는 것이다.


1-1 디렉토리 패턴

우리가 서블릿이나 web.xml 파일에서 실제 url이 너무 길어서 매핑 값을 설정하기 위해 사용했던 그것을 말한다. 

좀 더 자세히 정리하면 일단 이름처럼 디렉토리 패턴이기 때문에 매핑 방식이 디렉토리 형식이다.

예를 들어 우리는 그 전에는 보통 @WebServlet("/매핑값")의 형태로 가장 최하단의 디렉토리 형태로 지정했기 때문에

그냥 이름을 딱 하나로 매핑하는 거구나 라고 오해하고 사용했지만 사실 그렇지 않다.

@WebServlet("/test/*") 이런 식으로 사용하면 url을 디렉토리 처럼 이용이 가능해 진다. 

http://호스트:port/프로젝트 폴더명(context path)/ 이 부분은 생략해도 되고 안 해도 된다.

# 이걸 안 쓰려고 매핑했는데 쓸 이유가 없다.




디렉토리 방식은 말 그대로 디렉토리별로 매핑을 할 때에 유용하다.

예시를 들면 @WebServlet("/test/**")과 @WebServlet("/test/test2/*")로 매핑한 

서블릿 파일 2개가 있다고 가정해 보자. 

@WebServlet("/test/*")파일은 패키지1에 @WebServlet("/test/test2/*")파일은 패키지1의 안의 패키지2에 있다고 하면

이 때 test/test2/가 포함된 url를 넘기면 어떻게 될까. 

@WebServlet("test/test2/*")로 매핑된 서블릿이 실행된다.

/*는 바로 하위 디렉토리 즉, test의 밑에 해당되는 디렉토리까지만 해당되고

/**는 하위의 모든 형태를 포함하는 것이다.


url 매핑은 기본적으로 더 구체적인 것이 우선순위를 갖는다.

위의 경우도 



1-2 확장자 패턴

확장자 패턴은 디렉토리 패턴과 같은데 그 기준이 확장자인 것이다.

쉽게 말해서 확장자를 통해 url을 매핑하는 것이다. 

특정 확장자를 갖는 모든 url에 대해서 확장자로 매핑한 서블릿 파일로 이동하게 된다.


확장자 패턴은 @WebServlet("")의 ()안에 '.'을 통해 확장자를 정의한다.

@WebServlet("*.확장자")

확장자는 자신이 원하는 확장자를 지정하면 된다. sex,comi 아무거나 된다.

이렇게 확장자로 구분할 수 있게 만들었다면 우리는 url을 원하는 형태로 만들어 사용하면 된다.

특정 jsp 파일에서 <a></a> 태그를 이용해 @WebServlet("*.comi")가 사용된 파일로 이동시키고 싶을 때

href ="" 의 값으로 확장자가 comi이게만 적어주면 어떤 형태의 url이든 

모두 @WebServlet("*.comi")로 매핑된 서블릿 파일로 이동된다.

사실상 디렉토리도 최상위 디렉토리 이름만 쓰면 확장자와 다를 게 없긴 하다.

디렉토리 패턴이 조금 더 범용성이 높은 느낌이다.

그러니 디렉토리 방식은 이동시키고 싶은 서블릿 파일의 위치에 따라 구분할 때에 사용할 수 있겠고

확장자 패턴은 한정적인 그 기능에 맞게 밑에서 배울 FrontController 패턴이나 Command 패턴에서 많이 사용한다.


중요*) 참고로 디렉토리,확장자 패턴 모두 같은 @WebServlet("*.comi")값을 갖는 서블릿 파일을 여러개 만들 수 없다.

그리고 만약 디렉토리 패턴과 확장자 패턴이 모두 포함되는 url이 있을 때

디렉토리 패턴이 우선이 된다. 하지만 위에서도 말했지만 디렉토리 패턴의 ""안의 값이

/* 이런 식으로 되어 있을 때 /* 을 넘어서 

asd/test/sadw.comi 이런 식으로 안에 담겨 있는 형식을 갖는다면

이건 그냥 확장자 패턴의 이름인가 보다 하고 확장자 패턴에 대한 서블릿 파일로 넘어간다.


조금 더 쉽게 정리하면 우선순위가 이렇다.

url 패턴 중에서 /test/test2/test3.test

이런 식으로 패턴이 구체적이고 넘어오는 url 패턴도 이와 똑같이 구체적인 형태라면 이게 1순위

그 다음은 '/','/*' 와 같은 디렉토리 형식이 2순위

그 다음이 '*.test' 와 같이 확장자가 3순위이고

그 다음은 default 패턴이라고 위의 경우를 제외한 모든 패턴에 대해 받는 서블릿이 존재한다.

/**의 경우 default 보다도 우선순위가 낮다.


하여튼 위의 url패턴이 '/*'로 되어있을 때 asd/test/sadw.comi 를 확장자로 이해하는 것은

/*가 하위 디렉토리까지만 인지하기 때문에 asd에서 끝났어야할 url 패턴이 뒤에 /test/sadw.comi로 이어지니

/*로 인식한 것이 아니라 확장자 패턴으로 인식한 듯 하다.

이 때 디렉토리 패턴이 우선이 되려면 디렉토리 url 패턴이 '/asd/test/*'로 되어 있어야 한다.


2. FrontController 패턴

클라이언트의 다양한 요청을 한 곳으로 집중시켜, 개발 및 유지보수에 효율성을 극대화 한다.

각각의 요청마다 그에 맞는 서블릿이 존재하는데 이를 하나로 통합시켜 일을 분산시키지 않고

중복 코드를 줄일 수 있다.


예시를 들어 보면 

위의 url패턴을 이용해서 구현할 수 있다.

만약 <a>태그를 4개 만들었다고 가정해 보자.

각 url마다 각각의 서블릿 파일을 만들어서 url을 지정해 주는 것 보다

하나의 서블릿 파일 안에 url에 따라 각각의 기능을 수행하도록 하는 게 더 코드도 짧아지고 파일 개수도 줄 것이다.

그래서 확장자 패턴을 이용해서 각 태그마다 같은 .comi라는 확장자를 붙이고 앞에 url에

insert.comi, update.comi, delete.comi, select.comi 라고 서블릿 이름을 지정해 주었다.

다들 같은 @WebServlet("*.comi") 서블릿 파일로 이동하기 때문에 url 자체에 이름을 붙인 것이다.

그럼 각 url 마다 같은 서블릿 파일에 도착하면 같은 기능을 수행할 것이다.

이래서는 의미가 없다.

그래서 각 파일마다 다른 수행을 할 수 있도록 함수를 하나 만들었다.

바로 위에 지정해 준 서블릿 이름을 구분하는 함수이다.

String uri = request.getRequestURI();

String conPath = request.getContextPath;

String command = uri.subString(conPath.length());


위의 로직이 들어가 있는 함수가 실행되면 우리가 지정한 서블릿 파일 이름까지만 값을 뽑을 수 있다.

request.getRequestURI() 함수는 Context path와 파일명까지의 주소를 반환하는 함수이다.

request.getContextPath()는 ContextPath의 주소를 가져오는 함수이다.

그럼 getRequestURI로 가져온 uri에서 ContextPath의 길이만큼 빼면 실제 우리가 지정했던 파일명만이 남는다.

# 앞에 '/'도 함께 남는다 꼭 기억하자!!!


근데 우리는 매핑한 값을 이용했는데 어떻게 request 객체에 Context path나 URL 값이 있지?

사용할 때에는 http://호스트:port/프로젝트 폴더명(context path)/ 를 생략했지만

request객체는 매핑한 값이 아닌 실제 URL주소를 갖기 때문에 문제없다.


하여튼 위처럼 파일명을 얻었으면 우리는 if문을 통해 각 파일명에 맞는 로직을 수행시켜 주면 된다.

로직은 우리가 위에서 구분을 위해 호출한 함수 내부에서 해도 되고

각 파일에 따른 기능을 수행할 함수를 따로 만들었다가 doGet과 doPost에 if문을 사용해서 정의해도 된다.


이런 원리를 통해서 FrontController 패턴을 구현하는 것이다.

그리고 이러한 FrontController는 spring에서 사용되는 패턴이기도 하다.




2. Command 패턴

클라이언트로부터 받은 요청들에 대해서, 서블릿이 작업을 직접 처리 하지 않고, 해당 클래스가 처리하도록 한다.

위의 FrontController 패턴에서 각 파일명에 대한 로직이 다 하나의 서블릿에 들어가면 너무 코드가 복잡해진다.

따라서 각각의 수행에 필요한 클래스 파일을 따로 만들어서 데이터 베이스의 접근과 관련된 DAO DTO 가져오기 등등은

그 클래스에서 실행하도록 하는 것이다. 보통 Command 패턴을 사용하기 위해 각 클래스들이 공통으로 구현할 받을 인터페이스를

하나 만들어 두고 그 인터페이스에 중요한 수행 로직들을 넣어 놓는다. 그리고 서블릿에서는 클래스 파일을 통해 얻은

객체들을 이용해 특정 기능을 수행하는 로직만 짜는 듯 하다. 

정확히는 잘 모르겠으니 쓰면서 감을 익히자.

