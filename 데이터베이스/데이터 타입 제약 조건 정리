




create table 명령어에서 사용 가능한 데이터 타입과  

제약 조건에 해당하는 조건들을 정리했다.

SQL은 예약어와 DB 객체의 이름은 대소문자를 구분하지 않는다.



데이터 타입


1. 문자형 데이터 타입

CHAR(n [BYTE | CHAR])
고정 길이 데이터 타입(최대 2000byte) - 지정된 길이보다 짧은 데이터가 입력될 시 나머지 공간은 공백으로 채워짐

VARCHAR2(n [BYTE | CHAR])
가변 길이 데이터 타입(최대 4000byte) - 지정된 길이보다 짧은 데이터가 입력될 시 나머지 공간은 채우지 않는다.

# [BYTE | CHAR]는 단위 BYTE 단위로 할 지 CHAR 단위로 할 지 결정. 생략시 BYTE 단위. CHAR 선택시 UTF-8 기준으로 한 글자당 3바이트 차지.

NCHAR(n)
고정 길이 다국어 문자열 타입 UTF-16사용(문자당 2바이트, 최대 2000byte)

NVARCHAR2(n)
가변 길이 다국어 문자열 타입 UTF-16사용(문자당 2바이트, 최대 4000byte)

# MAX_STRING_SIZE 설정을 EXTENDED로 바꾸면 최대 크기를 늘릴 수 있으나 그럴 바에는 밑의 데이터 타입을 사용하는 것이 바람직함

LONG
가변 길이 텍스트 데이터 타입(최대 2Gbyte)

-> 속성에 한 번밖에 못 쓰는 데이터 타입

CLOB
대용량 텍스트 데이터 타입(최대 4Gbyte)

-> 사용제한 없음. 요즘은 LONG 안 쓰고 CLOB을 보통 사용함

NCLOB
대용량 텍스트 유니코드 데이터 타입(최대 4Gbyte)

# varchar와 nvarchar의 차이는 varchar는 데이터의 크기를 지정하고 nvarchar는 입력 가능한 문자 수를 지정하여 사용한다.

# varchar는 어디갔나요? varchar은 앞으로 다른 용도로 사용될 예정이라고 한다. 따라서 varchar2를 사용해야 한다.



2. 숫자형 데이터 타입

BINARY_FLOAT
부동 소수형 데이터 타입(4byte) - 32bit 부동 소수

BINARY_DOUBLE
부동 소수형 데이터 타입(4byte) - 64bit 부동 소수

NUMBER(P,S)
P(정밀도), S(스케일)로 표현 숫자 데이터 타입 P: 1 ~ 38, S: -84 ~ 127 

P(Precision): 최대 유효 십진 자리수

S(Scale): 최하위 유효자리수까지의 자리수

- Scale의 경우 지정한 수만큼 소수점 자리를 확보하기 때문에 사용에 주의해야 한다.

- NUMBER는 그 자체로 정수와 실수의 표현이 가능하기 때문에 요긴하게 사용된다.

- P와 S에는 *를 사용할 수 있고 P에 *를 쓰면 자동으로 최대값 38이 들어가고 S에 *를 쓰면 소수점이 없는 것으로 판단.

- scale이 양수일때는 소수점의 오른쪽에 있는 자릿수로 최하위 유효 자릿수를 포함한 자릿수가 된다.

정밀도 > 스케일 일 때
    : 정밀도 : 소수점 포함 최대 자릿수(최대 유효 십진 자리수)
    : 스케일 : 소수점 자리를 확보하기 때문에 꼭 포함해야 하는 소숫점 자리수. (뒤의 숫자가 0일 경우 생략됨 -> 1.50 = 1.5)
    : [정밀도 - 스케일] : 정수부로 올 수 있는 자리수('최상위 유효 자리수'라고도 함)
    (소수점 자리를 Scale만큼 확보하기 때문에 '최대 자리수[정밀도] - 스케일 = 정수부'이다)

    이 경우는 위의 P와 S가 의미 그대로 사용된다.

정밀도 <= 스케일 일 때
    : 정밀도 : 소수점 이하에서 0~9까지 자유롭게 입력될 수 있는 수의 개수('0'이 포함되기 때문에 혼동와서 유효자리수라고 안 할거임)
    : 스케일 : 소수점 이하의 최대 자리 수 
    : [스케일 - 정밀도] : 소숫점 이하에서 맨 처음에 존재하는 '0'의 개수
    : '스케일 - 정밀도' 에 해당하는 값만큼 소수점 처음에 0이 강제로 들어가야 한다.

    이 경우는 소수점이 더 커서 '정밀도 - 스케일'이 항상 음수이므로 정수부에 숫자가 올 수 없어 늘 '0'이 된다.
    그리고 당연스럽게 최대자리수는 정밀도가 아닌 스케일이 표현하는 소수점 자리까지가 된다.
    그럼 정밀도가 나타낼 것이 없게 된다. 그래서 정밀도는 이 경우 소수점 이하에서 0~9까지 자유롭게 입력될 수 있는 수의 개수를 나타낸다.
    쉽게 말하면 '정밀도 = 소수점 이하에서 유효자리수 = 최하위 유효자리수(0을 포함하는, 소수점 고정 0 제외)'라고 생각하면 된다.
    정밀도의 값만큼의 소수점 이하에서 0~9까지 자유롭게 입력될 수 있는 수의 개수를 포함하면서 
    스케일의 값만큼의 소수점 이하의 자리 수를 유지하려면, 최소한 소수점 앞 부분은 [스케일 - 정밀도]만큼 0으로 채워져야 한다.
    만약 그렇지 않고 앞 부분에 0이 아닌 다른 수가 오고 그 뒤를 입력하지 않으면 정밀도의 값보다 유효자리를 넘는 경우가 생긴다.
    # 그 뒤를 전부 0으로 입력하더라도 그 0을 유효자리로 보는 게 아닐까 함
    이런 경우를 방지하고자 [스케일 - 정밀도]의 값만큼은 반드시 소숫점 이하에서 맨 처음에 '0'으로 채워져야 한다.
    # 반드시 채워져야 한다기 보다는 이 규칙을 안 지키면 입력이 안 된다.
    그 이외의 남는 나머지 자리(=정밀도의 값)에 0~9까지 자유로운 수가 올 수 있다.

    어떻게 보면 '정밀도 > 스케일' 의 경우가 살짝 반대가 되었다고 생각하면 된다.
    뭔가 복잡해 보이지만 원리는 갖기 때문이다. 단어의 의미가 달라지고 소수점에서 일어나서 조금 복잡해 보일 뿐.
    그냥 두 경우의 수에 따라 연결하려 하지 말고 아예 다른 의미로 쓰인다고 생각하고 보면 좀 편하다.


    그럼 여기서 문제 NUMBER(3,5)일 때 입력값이 0.0000091234라면 저장되는 값은? 
    정답은 0.00001이다. Scale이 5이기 때문에 소수점 다섯번째 자리까지 자리를 확보한다.
    즉, 반올림이 일어나는 지점은 그 다음 자리수인 6번째 자리이다.
    소수점 6번 째 자리가 9이므로 반올림 +1이 되어 0.00001이 되는 것이다.

    문제2
    NUMBER(4,7)일 때 입력값이 0.0012345라면 저장되는 값은?
    정답은 오류가 난다 이다. Scale - 정밀도가 3이기 때문에 입력되는 값은 0.000xxx...이어야 한다.


- scale이 음수일때는 소수점의 왼쪽(정수부)에 있는 자릿수이다.

이 경우 정밀도 < 스케일 의 경우의 수는 나올 수 없다.

정밀도 > 스케일 일 때
    : 정밀도 : 스케일 제외 최대 자리수
    : 스케일 : 소수점 이상(정수부분)에 대한 자리수 -> 10.5의 경우 0이 -1, 1이 -2 자리수임. 스케일이 -1일 경우 0을 반올림하여 1에 반영
    : [정밀도 - 스케일] : 최대 자리수(소수점 이상을 소수점 자리수로 확보하기 때문에 정수부에 자리수가 오히려 추가됨)
    예시) NUMBER(4,-2) -> 123456 입력 시 -> 123456 = 123456.0 -> 소수점 윗부분으로부터 2자리인 56 부분을 스케일에 의해 확보 
                        거기에 1234는 정밀도에 해당하는 자리수. 이 때 56부분에서 소수점 -2번째 자리인 5에서 반올림
                        5는 반올림시 1이 증가하므로 4에 1이 증가, 따라서 123456을 입력시 123500이 출력됨

    보면 알겠지만 위에서 P의 입력값은 1~39이고 S는 -84~127이다.  
    그 말은 위의 경우를 이용하면 NUME(39,-84)로 정수부를 123까지의 자리수로 만들 수 있는 건가?            

    NUMBER(4,-2)일 때 다른 예시                  
    123456.99999 입력시 -> 12345 출력 -> 소수점 
    1234567 입력시 -> 최대자리수 6자리(4 - (-2))를 넘어가므로 오류

    
    문제1 NUMBER(6,-4)일 때 1234567 입력시 출력되는 값은?
    정답 : 1230000 -> 소수점 -4번 째 자리(4)에서 반올림되어 3에 반영 나머지는 0으로 채움

    문제2 NUMBER(5,-3)일 때 123456789 입력 시 출력되는 값은?
    정답 : 오류 -> 입력될 수 있는 최대 값은 5 - (-3)인 8이기 때문에 9자리수는 입력받지 못 함
    소수점 밑의 값은 반올림 되면서 없어지기 때문에 무한대로 받을 수 있음 EX) 1234578.912345678912345789
    # 실제로 넣어봤는데 됐음ㅋㅋㅋㅋ 너무 많은 숫자 넣으면 안 될 줄 알았는데 잘 됨


EX) NUMBER(6,2) -> 소수점 두 자리 포함 최대 6자리 숫자

    NUMBER(6,-5) -> 소수점 기준 왼쪽 5번 째 자리에서 반올림하는 최대 6자리 숫자(그렇기 때문에 소수점 없다고 봐도 무방)

    # 음수로 넘어가면 0을 거치기 때문에 음수 자리까지 표현이 아니고 그 자리 숫자를 반올림해서 다음 수 까지 표현이다.

    NUMBER(2,6) -> 소숫점 이하에서  자릿수는 6개이며 0을 제외한 숫자 4개를 포함하는 숫자. 예시 : 0.001234

    NUMBER = NUMBWE(38, *) -> 최대 38자리 숫자

    NUMBER(*,5) -> 소수점




3. 날짜형 데이터 타입

DATE
년 월 일 고정 길이 날짜

INTERVAL_YEAR
날짜(년도, 월)형태의 기간 표현 데이터 타입

INTERVAL_DAY
날짜 및 시간(요일, 시, 분, 초)형태의 기간 표현 데이터 타입

TIMESTAMP
밀리초(ms)까지 표현 데이터 타입

TIMESTAMP_WITH TIME ZONE
날짜 및 시간대 형태의 데이터 타입

TIMESTAMP_WITH LOCAL TIME ZONE
저장 시 데이터베이스 시간대를 준수, 조회시 조회하는 클라이언트 시간 표현 데이터 타입



4. 이진 데이터 타입

RAW(n)
가변 길이 이진 데이터 타입(최대 2Gbyte)

LONGRAW
가변 길이 이진 데이터 타입(최대 4Gbyte)

BLOB
대용량의 바이너리 데이터를 저장하기 위한 데이터 타입(최대 4Gbyte)

BFILE
대용량의 바이너리 데이터를 파일형태로 저장하기 위한 데이터 타입(최대 4Gbyte)


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


제약조건

키워드는 MySQL이냐 ORACLE이냐 등 DBMS에 따라 차이가 있다.


NOT NULL
값이 꼭 입력되어야 할 때 사용한다. NULL을 허용하지 않음. 


UNIQUE
해당 컬럼에 중복 값을 허용하고 싶지 않을 때 사용한다.


PRIMARY KEY
기본키를 지정할 때 사용하는 조건이다. 테이블 당 한개의 기본 키만 생성 가능하다.

PRIMARY KEY와 UNIQUE키의 차이점은 UNIQUE는 NULL을 허용하고 PRIMARY KEY는 NULL을 허용하지 않는다.

# 아직은 이 정도만 알아도 사용하는 데에는 문제 없는 듯 하다.


FOREIGN KEY 
외래키를 지정할 때 사용한다. (references 키워드랑 같이 쓰임) 테이블 내의 열 중 다른 테이블의 기본키를 참조하는 열이다.


CHECK
컬럼에 입력되는 데이터를 체크해 특정 조건에 맞는 데이터만 입력받고 싶을 때 사용한다.


DEFAULT
만약 값이 없이 입력되면 디폴트에 지정된 값으로 입력한다.


INDEX
인덱스를 지정할 때 사용한다.
