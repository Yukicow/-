




ROWNUM은 SELECT/WEHRE절을 실행하고 얻은 결과에 sort(정렬),aggregation(집합)되기 전에 할당된다.

근데 이게 ROWNUM에 대해서만 동작을 다르게 하게 만든 건지 아니면 내가 이해를 못 하는 건지 모르겠는데

일단 ROWNUM의 동작을 보면 FROM에서 가져온 데이터들이 WHERE절에 의해 구분되고

그 구분된 데이터들을 한 레코드씩 가져와서 ROWNUM을 매긴다.

근데 이 때 WHERE 절의 ROWNUM에 대한 조건을 함께 검사하는 듯 하다.

이게 ROWNUM만 뿐만이 아니라 조건문 자체가 그렇게 동작하는 듯 하다.

원래 존재하는 테이블의 레코드를 하나씩 갖고와서 조건에 맞는 지 확인하고 맞으면 결과집합에 넣는 것 같다.

하여튼 ROWNUM의 할당과 ROWNUM에 대한 조건처리는 가장 마지막에 일어나는 듯 하다. 그래야만 설명이 된다..

어쨋든 ROWNUM과 관련된 모든 조건을 제외하고 만들어진 테이블에서 이제 레코드를 하나씩 가져와서 ROWNUM을 부여하는데

WHERE에 ROWNUM에 대한 WHERE ROWNUM > 1 이라는 조건이 있다고 해보자.

그럼 ROWNUM이 할당되고 조건을 볼텐데, 이 때 부여한 ROWNUM은 1이다.

근데 조건은 ROWNUM > 1 이다.

당연히 조건에 부합하지 않으니 레코드를 버린다.

그럼 다음 라인 레코드를 가져와서 대입해야 할 텐데, 아직 ROWNUM 1을 사용한 레코드가 없기 때문에 ROWNUM의 증가가 일어나지 않는다. 

ROWNUM 1을 부여해야 다음 번호인 2를 부여하는데 방금 부여하려던 레코드가 조건에 부합하지 않기 때문에 버렸기 때문이다.

근데 다음으로 오는 레코드도 그 다음에 오는 레코드도 모두 ROWNUM 1을 부여받을 것이기 때문에 

이 경우의 수는 ROWNUM > 1 에 걸려서 결국 아무 결과집합을 만들어 내지 못 한다.


이러한 원리 때문에 ROWNUM을 사용할 때 최상위 SELECT 절에서는 ROWNUM을 무조건 1부터 호출할 수 있는 것이다.

이것을 방지하기 위한 방법은 서브쿼리 SELECT문을 사용하는 것이다.

ROWNUM이 애초에 있었던 것처럼 동작한다면 우리는 최상위 SELECT문에 ROWNUM의 조건을 마음대로 사용할 수 있다.

그래서 ROWNUM을 1부터 호출할 것이 아니라면 보통 SELECT문 안에 ROUNUM을 포함하는 SELECT문을 넣어서 그 결과를 가지고 사용한다.

