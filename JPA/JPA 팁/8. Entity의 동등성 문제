







동등성과 동일성은 다르다. 

동일성은 완전히 같은 객체인 지, 즉 자기 자신인 지를 따지는 것이고,

동등성은 정보가 일치하는 지를 따지는 것이라고 볼 수 있다.

'==' 비교 같은 경우가 같은 레퍼런스를 가리키는 지를 비교하기 때문에 동일성 비교라고 할 수 있다.


equals() 메소드는 동등성을 비교하는 메소드이다. 

Object타입에 기본 정의되어 있는 equals()는 '=='를 이용해서 비교한다.

이것 때문에 마치 equals()를 동일성 비교라고 오해하는데, 그렇지 않다.

동등성을 비교할 때 최대 한도로 잡을 수 있는 기준점은 '동일'한 지에 대해서 비교하는 것이다.

마치 사각형을 찾을 때 정사각형을 찾는 것과도 같다. 사각형 중 최대로 조건이 구체적인 사각형을 찾는 것과 같은 원리이다.

'동등'성을 비교하는 기준은 '동일'성을 비교하는 기준 보다 더 포괄적으로 잡거나 최대 같게 잡아야 하지만 더 높게 잡을 수는 없다.

# 이 예시가 어렵다면 이렇게 생각하면 된다. 나와 같은 것을 찾는 기준을 진짜 '나'로만 잡느냐, 나와 똑같이 생기기만 하면 같다고 하느냐이다.

Object에 정의된 기본 equals() 메소드는 동등성 비교의 최대 기준인 동일성 비교를 비교의 default 조건으로 잡은 것일 뿐이다.


hashCode()라는 메소드는 equals()와 다르게 동일성을 비교하는 메소드이다.

Object 클래스에서 제공하는 기본 hashCode()로직은 heap에 저장된 객체의 메모리 주소를 정수형(int)으로 변환한 값을 그대로 반환하거나

추가로 로직을 수행해 조금 더 변환해서 int로 반환하도록 되어 있다. 

이게 로직이 java가 업데이트 될 때마다 달라지는 건지 뭔지는 모르겠지만,

여기서 중요한 것은 '메모리 주소'를 기반으로 한 로직이기 때문에 사실상 한 객체당 하나의 고유한 값을 반환한다는 점이다.

어떤 객체든 hashCode() 메소드는 레퍼런스를 기준으로 값을 생성하기 때문에 언제나 같은 고유한 값을 반환한다.

즉, 동일성을 비교하는 메소드라고 볼 수 있다.


이 hashCode()라는 것은 '동일'한 데이터가 중복되는 것을 막는 hashSet,hashMap 등의 컬렉션에서 비교를 위해 사용된다.

그래서 이러한 컬렉션들은 가장 먼저, 컬렉션에 들어갈 객체가 동일한 객체인 지를 판단한다.

그래서 컬렉션 내부 객체들의 hashCode()와 인자로 받은 객체의 hashCode()값을 비교해 동일한 객체라면 컬렉션에 추가되는 것을 막는다.

hashCode() 비교 연산이 false를 반환할 경우 동일하지 않은 객체로 판단하고 바로 그냥 추가해 버린다.


만약 서로의 hashCode()를 비교한 결과가 true인 경우가 있다면, 그 다음은 equals()를 호출해서 동등성을 비교한다.

동일한 객체더라도 동등하지 않을 수 있기 때문이다.

# 지금은 그래 보이지 않지만 뒤에 예시를 보면 알 것이다.

그래서 equals()를 비교하는 것이다.



이런 말을 들어 봤을 것이다.

equals()를 오버라이드 하면 hashCode()도 함께 오버라이드 해야 한다.

왜 그런 것일까?



기본적으로 제공되는 equals() 메소드의 구현 로직을 보면, '동일성' 비교를 '동등성'을 비교하는 조건으로 사용하고 있다.

사실상 그냥 기본으로 제공되는 equals()를 사용하면 hashCode()와 equals()는 같은 '동일성' 비교라고 볼 수 있다.

그런데 우리가 로직상에서, '동등'한 객체를 '동일'한 객체처럼 동작하게 하고 싶을 때가 있다.

하지만 물리적으로 서로 다른 객체를 같은 레퍼런스를 갖는 객체처럼 동작하게 하는 건 불가능하다.

서로 다른 객체는 '=='을 비교했을 때 무조건 false이기 때문이다.


그래서 이런 물리적인 한계점을 해결하고자 java내에는 대부분 논리적으로 동등하면 물리적으로 동일한 객체처럼 동작할 수 있게

객체를 비교할 때 '==' 연산 비교만 하지 않고, equals() 메소드를 통해 논리적으로 동등한 지를 검토하도록 로직이 작성되어 있다.

그렇기 때문에 우리가 단순 '=='연산을 수행하는 equals() 메소드를 오버라이드해서 사용하면

대부분의 로직에서 물리적으로 동일한 객체처럼 사용할 수 있다.

내부적으로 객체의 데이터들을 비교하고 서로 완전히 일치하면 '동등'한 객체로 판단하고 true를 반환하게 하면 되는 것이다.

사실 이 정도만 해 두어도 논리적으로 '동등'한 객체가 물리적으로 '동일'한 객체처럼 동작하기 때문에 문제가 없다.

근데, Hash컬렉션을 사용할 때 문제가 발생한다.


Hash컬렉션은 hashCode()를 이용해 레퍼런스를 갖고 '동일성'을 '먼저' 비교하는 형태로 동작한다.

동일성에서 이미 동일하지 않다고 판단되면 바로 Hash컬렉션에 데이터가 추가되어 버린다.

근데, 우리는 equals()를 오버라이드하면서 서로 다른 객체라도 특정 데이터가 같으면 같은 객체라고 판단하기를 기대하고 있다.

이런 상황에서 같은 데이터를 갖는 서로 다른 두 객체를 Hash컬렉션에 추가한다고 해 보자.

그럼 첫 번째 객체가 컬렉션에 담기고 두 번째 객체가 담길 때에는 동일,동등성 비교를 하게 된다.

우리는 객체의 데이터를 똑같이 맞춰 놓았으니 동일한 객체로 판단해 당연히 객체가 안 들어가기를 기대하지만 정말 슬프게도 들어간다.

왜냐하면 hashCode()를 따로 오버라이드 하지 않았기 때문에이다. 

데이터는 같지만 서로 다른 객체이기 때문에 서로 다른 고유 주소를 가질 것이고, hashCode() 연산에서 false가 나와

equals() 연산을 하기도 전에 동일하지 않은 객체로 판단하고 바로 컬렉션에 때려박기 때문이다.


우리가 물리적으로 동일하지 않은 것들을 동일한 것처럼 맞추다 보니 발생한 문제이다.

정말로 물리적으로 동일한 객체인 지를 판단하고 동작하는 경우에서는 이렇게 문제가 발생하는 것이다.

그래서 이런 경우에는 진짜 물리적 동일함을 비교하는 hashCode()를 끌어내려서 우리의 기준에 맞춰야 한다.

그렇지 않으면 물리적 동일함과 논리적 동일함 사이에서 불일치가 발생해 문제가 생긴다.

실질적으로 서로 다른 것을 물리적으로 갖게 만들 수 없으니 hashCode()를 논리적으로 동일한 지를 따지게끔 만드는 것이다.


원래라면 '동일성'에 대한 기준에 맞춰 그 보다 같거나 낮은 조건으로 '동등성'의 조건이 맞춰지는 게 상식적이다.

하지만 위의 경우는 '동등성'이 강제로 '동일성'으로 동작하는 형태가 되었다.

그래서 '동일성'이 '동등성'보다 구체적인 조건을 가지면 안 되는 상태이다.

그럴 경우 불일치가 발생하기 때문이다.



예를 들어 이제는 equals()가 이제는 동일성의 기준이 되기 때문에 의도한 동작은 id만 같으면 같은 것으로 동작해야 한다.

그런데, hashCode()는 id값 뿐만 아니라 name까지 같아야 같은 객체로 판단하게 구현하면, id와 name이 다르면 서로 다른 객체로 판단해 버린다.

그럼 우리가 의도한 대로 '동일성'이 동작하지 않게 된다. 

hashCode()가 동작할 때 id값이 같아도 name이 다르면 다른 객체로 판단하기 때문이다.

그래서 이럴 경우 hashCode()의 비교 조건은 equals()와 같거나 더 포괄적이어야 한다.


즉, 쉽게 생각하면 이렇다.

equals()를 오버라이딩하는 것은 대게 '동일성'의 기준을 논리적으로 바꾸기 위해서다.

그럴 경우에는 hashCode()가 새로운 동일성의 기준이 되는 equals()에 맞춰 기준점을 잡아야 하는 것이다.

그게 아니고 그냥 equals()를 '동등성' 비교로서 그대로 사용하면서 오버라이딩 하는 거라면 따로 hashCode()를 건드릴 필요는 없다.

완전히 같은 데이터를 가져도 레퍼런스가 다른 객체라면 아예 다른 객체로 보게끔 동작하는 게 의도한 게 맞다면 그냥 냅두면 된다.

equals()를 어떤 의도로 오버라이딩 하느냐에 따라 달라지는 것이다.

하지만 보통은 '동일성'의 기준을 바꾸기 위해 오버라이딩 하는게 99.9999%이다.


여기서 팁을 주자면 hashCode()의 기준점은 equals()와 똑같이 갖고 가는 게 좋다.

예시를 하나 들자, hashCode()는 id값이 같으면 같은 해시코드를 반환하게 작성했고,

equals()는 id값과 name값이 같아야 true를 반환하게 했고 id는 같은데 name값이 다른 두 객체가 있다고 해 보자.

우리는 HashSet에 이 두 객체를 넣을 것이다. 

그럼 처음에 한 객체가 들어가고 두 번째 객체는 hashCode()를 먼저 거친다.

id값이 같기 때문에 통과한다. 그리고 equals()를 비교한다. name값이 다르기 때문에 서로 다른 객체로 판정이 난다.

어차피 equals()에서 서로 다른 객체로 판정이 날 거였다면 hashCode()에서 판정이 나는 게 성능상 이득이다.

hashCode()는 equals()의 조건 보다 포괄적이거나 같을 수 있기 때문에 무조건 같게 하는 게 이득이다.

그리고 조건을 같게 하는 것이 hashCode()를 '동일성'비교로 사용할 때와 equals()를 '동일성'비교로 할 때 

어느 쪽을 선택하든 모두를 만족하는 지점이다.

# hashCode() >= equals() ,  hashCode() <= equals()  두 경우의 수가 있다면 hashCode() = equals()가 가장 안정적인 지점

# hashCode()와 equals() 모두가 '동일성'이자 '동등성'비교인 지점이기 때문이다.



이것이 왜 equals()를 오버라이드 할 때에 hashCode()도 함께 오버라이드 해야 하는 이유이다.

물론 위에서 얘기한대로 물리적으로 동일한 객체인 지를 판단하는 로직이 정말로 하나도 포함되지 않은 경우,

쉬운 예시로 Hash컬렉션을 사용하지 않는 경우는 equals()만 오버라이드하고 사용해도 문제가 없다.

하지만 언제 요구사항이라는 것이 바뀔 지 모르고 로직을 바꿀 지 알 수 없다.

이런 것은 미리 대비해서 함께 바꾸어 놓는 것이 나중에 생길 위험에 대한 비용을 절약할 수 있다.



참고로 hashCode()를 오버라이드 하기가 어려울 수 있다.

왜냐하면 hashCode()는 아무 인자도 받지 않기 때문이다.

뭔가 비교할 대상이 없기 때문에 == 연산을 할 수도 없다.

그럼 어떻게 비교하죠?

자신이 갖고 있는 필드 데이터들의 hashCode()값을 이용하는 것이다.

자신이 갖고 있는 필드들 중 동일성 비교에 사용할 필드들의 hashCode()값을 모두 더하면 된다.

null이면 0을 더하고 null이 아니라면 해당 객체의 hashCode()값을 하나의 변수에 계속 더한다.

다른 객체의 hashCode()도 그 객체의 필드들에 대한 hashCode()값을 더한 값을 가질 것이다.

그럼 서로 다른 객체의 hashCode()를 비교했을 때 이게 일치하면 서로 같은 데이터를 갖고 있다고 볼 수 있다.

이게 primitive타입은 자동으로 WrapperClass로 변환되기 때문에 문제 없다.

그리고 WrapperClass는 같은 값을 가지면 같은 레퍼런스를 바라보기 때문에 값만 같다면 서로 다를 문제도 없다.

하여튼 위 방식은 실제로 hashCode()를 구현하는데 유용하게 사용하는 알고리즘이다.

그리고 이 방식은 Objects라는 유틸클래스에 hash()라는 메소드에 알아서 정의되어 있다.

만약 위의 로직을 직접 짜는 게 조금 어렵다면 그냥 Objects.hash(Object...o) 메소드를 호출해서 return값으로 사용하는 것도 좋은 방법이다.







그럼 이제 JPA와 관련된 본문이다.

Entity는 동등성을 비교하는 일이 많다.

예를 들면, ToOne 연관관계에 있는 컬렉션 필드에서 entity를 새로 넣거나 뺄 때,

로직상 영속 상태의 Entity와 준영속 상태의 Entity가 비교될 경우도 있고,

이럴 때 외에도 동일성, 동등성 비교는 비즈니스 로직에 따라 일어나기도 한다.


단순히 일반 컬렉션에서 Entity를 빼고 넣을 때만을 고려한다면 pk를 이용해서 equals와 hashCode를 오버라이드해도 문제 없다.

하지만 일반 컬렉션 중에서 set을 사용할 때에는 조금 문제가 될 수 있다.

일반적으로 pk를 사용하면 영속성 컨텍스트에 담기기 전에는 pk값이 초기화되어 있지 않기 때문에

set과 같이 중복이 허용되지 않는 컬렉션에 넣을 때에는 조금 문제가 될 수 있다.

pk값이 null인 상태로 넣으려 하면, 아직 pk가 초기화가 안 돼 null인 다른 Entity들이 들어갈 수가 없기 때문이다.

List같은 경우는 어차피 같은 데이터여도 중복으로 들어갈 수 있기 때문에 들어가 있다가 persist되고 그 때 초기화돼도 되지만

set은 중복이 허용되지 않으니 문제다.

그러니 pk를 사용하는 것은 set을 사용하지 않을 때에는 문제가 없지만 set을 사용하는 로직이 있다면 조심해야 한다.


그렇다면 pk를 제외한 다른 필드들에 대해서 