






Spring Data JPA에서도 벌크연산이 가능하다.

그냥 쿼리 메소드에 @Query 어노테이션을 사용하고 수정 쿼리 등을 작성하면 된다.

그리고 딱 한 가지만 더 하면 되는데 @Modifying 어노테이션을 추가로 달아 주는 것이다.

이 어노테이션은 해당 쿼리 메소드가 데이터 수정에 대한 작업을 한다는 것을 명시하는 것이다.

이게 없으면 조회 작업으로 인지하기 때문에 JPQL을 getResultList() 수행을 해 버린다.

@Modifying이 있어야 executeUpdate()작업이 수행되는 것이다.



이런 JPQL을 통한 벌크 연산을 할 때에 조심할 점이 있다고 기본편에서 배웠다.

JPQL을 수행하고 나서 뒤에 더 로직이 있는 경우에 값을 다시 조회해야 한다는 것이다.

JPQL은 SELECT나 UPDATE 쿼리를 수행할 때에 영속성 컨텍스트를 한 번 flush()하고 나서 수행하기 때문에

그 전의 내용들이 DB에 반영되지 않을 일은 없지만, 영속성 컨텍스트에 담겨 있는 데이터들의 수정에 대해서는 관여를 하지 않는다.

그래서 JPQL로 UPDATE를 수행하면 영속성 컨텍스트의 데이터들은 DB의 데이터와 불일치가 발생한다.


우리가 직접 JPQL을 작성할 경우야 em.clear()를 해 주고 다시 조회하면 되는데 Spring Data JPA를 사용할 때에는 어떻게 해야 할까?

@Modifying의 옵션을 이용하면 된다.

@Modifying(clearAutomatically = true)를 사용하면 해당 쿼리가 수행되고 나서 em.clear()가 자동 수행된다.


예전에도 말했지만 이 주의사항은 아주 중요하다.

다른 기술들과 사용할 때에도 주의해서 적절하게 clear()해야 한다는 것을 꼭 기억하고 사용하자.



