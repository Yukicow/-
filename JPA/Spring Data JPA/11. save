






Spring Data JPA에서 자동으로 생성해 주는 구현체는 Interface에 명시되어 있는 여러 가지 메소드들은 기본으로 제공한다.

예를 들면 save(), findById(), findAll()등 아주 기본 적인 것들은 모두 바로 사용이 가능하다.

이 때 save()를 조금 조심해야 하는데, save()는 Entity가 DB에 없는 데이터라면 persist()로 동작하지만

DB에 이미 있는 데이터라면 merge()로 동작한다는 것이다.



그럼 DB에 데이터가 있는 것이라고 어떻게 판단할까?

if (entityInformation.isNew(entity)) {
			em.persist(entity);
			return entity;
		} else {
			return em.merge(entity);
	    }

실제 구현체의 로직이다.

isNew()라는 메소드를 통해서 DB에 있는 지 없는 지를 판단하는데,

저 메소드는 아주 간단하다.

그냥 entity의 id, 즉, pk값이 존재하는 지 안 하는 지(초기화가 되어 있는 지)를 본다.

존재한다면 기존에 있는 데이터라고 생각을 하고 false를 반환하고 존재하지 않는다면 새로운 데이터라고 생각하고 true를 반환한다.

여기서 WrapperClass의 경우는 null을, primitive타입은 0을 기준으로 값의 존재 유뮤를 판단한다.



로직상 의도한 게 아니라면 웬만하면 그럴 일이 없겠지만 Entity에 id값이 잘못 들어가거나 하면 

merge가 발생해서 데이터가 완전히 덮어 씌어질 수 있으니 조심해야 한다.

또, 이 merge를 이용해서 데이터의 변경을 하려는 경우가 있는데, 그건 기본편에서도 말했지만 좋지 않은 방법이다.

merge는 데이터를 덮어 씌우기 때문에 원하지 않는 데이터까지 변경되어 버릴 수 있어 좋지 않기 때문이다.

데이터의 수정을 변경 감지를 통해서만 하는 것이 바람직하다.



별 거 없네요?

맞다. 위의 내용만 보면 솔직히 크게 문제 없어 보이는데, 이게 문제가 되는 경우가 있다.

바로 pk값을 GeneratedValue로 사용하지 않고 직접 할당하는 형태로 사용할 때이다.

정말 가끔 DB의 자동 생성값을 통해 pk를 할당하지 않고 이렇게 사용하는 경우가 있다고 하는데,

이런 경우에 Spring Data JPA의 save를 호출하면 문제가 발생할 수 있다.

em.persist만 사용하면 id값이 겹칠 때 알아서 예외를 터트리고 rollback이 되니 문제가 없는데,

Spring Data JPA의 save는 merge도 함께 제공한다는 게 문제이다.


이런 상황이라고 해 보자.

id값을 Entity를 생성할 때에 직접 초기화 시키는 방식으로 구현했다고 해 보자.

그럼 Entity가 생성되면 id값에 대한 필드가 초기화된 상태이다.

이 상태에서 Spring Data JPA의 save()를 호출해서 저장했다고 해 보자.

그럼 isNew() 메소드가 호출되면서 id값 필드에 값이 존재하는 지 확인한다.

근데 우리가 Entity를 생성하면서 id값을 초기화해 버렸기 때문에 isNew() 새로운 Entity가 아니고 원래 DB에 있던 데이터라고 생각할 것이다.

그럼 em.persist()가 아니고 em.merge()가 호출되는 불상사가 발생한다.


물론 em.merge() 또한 DB에서 실제로 Entity를 불러온 다음에 그 값을 병합하는 형태이고,

만약 DB로부터 불러와진 데이터가 없으면 em.persist를 호출하기 때문에 문제될 건 없다.

근데, 이게 여러 데이터를 persist()하는 경우라고 가정해 보자.

처음부터 새로운 Entity라는 가정으로 persist()가 이루어 졌다면, 즉, ID값을 우리가 직접 초기화하는 경우가 아니라면
 
Entity는 isNew를 통해 기존 DB에 없는 Entity로 인식되어 바로 영속성 컨텍스트에 저장되고, 

DB에 insert할 쿼리를 준비만 해 놓았다가 flush()될 때 몰아서 보내게 될 것이다.

하지만 우리가 직접 id를 초기화하면서 isNew에서 id값이 존재하는 걸로 보기 때문에 merge()가 호출되어 버리고,

DB로부터 SELECT를 통해 Entity를 한 번 조회하는 작업을 한 뒤에 없으면 다시 em.persist()가 일어나게 된다.

그럼 여러개의 데이터를 persist()하면 데이터의 개수만큼 SELECT쿼리가 나가는 것이다.

이렇게 DB로부터 계속 N번 만큼 SELECT를 호출하는 건 성능이 미친듯이 안 좋다.


이런 문제를 해결하는 방법이 존재한다.

우리가 isNew() 메소드를 직접 오버라이딩해서 사용하는 것이다.

isNew()의 알고리즘을 id값이 존재하는 지로 기준을 잡는 게 아니라 다른 방식으로 접근하도록 해서

em.merge()가 호출되는 것을 막는 것이다.

isNew()를 오버라이딩 하는 법은 간단하다.

Entity 클래스에 Persistable<>이라는 함수형 인터페이스를 구현하면 된다.

이 함수형 인터페이스는 isNew()라는 메소드를 구현하도록 되어 있다.

이 메소드를 오버라이딩하면 된다.


그럼 어떻게 isNew()를 작성하는 게 가장 바람직할까?

우리에게는 마치 id처럼 동작하는 데이터가 존재한다.

바로 createDate이다.

createDate는 persist가 발생하기 직전에 초기화되기 때문에 persist가 일어나기 전에 초기화 될 일이 없다.

또, createDate는 겹칠 일도 존재하지 않는다. 밀리세컨드 단위까지 정확하게 일치할 일이 없다. 불가능하다.

심지어는 한 번 초기화되면 바뀔 일도 없다.

# 근데 사실 겹치고 안 겹치고랑 바뀌고 안 바뀌고는 isNew()에서 중요하진 않다.


하여튼 이정도 수준이면 거의 id값이나 다름이 없다.

이 createDate를 이용해서 isNew()를 오버라이드할 수 있다.

바로 createDate == null 인 지를 보는 것이다.

null일 경우 처음 생성된 Entity라고 보면 되고, 그렇지 않을 경우 DB에 반영된 적 있는 Entity라고 볼 수 있다.



우리는 em.merge는 그냥 아예 없는 녀석이라고 생각하는 수준으로 배제해야 한다.

정말 아주 가끔 쓸 일이 있다고 하는데, 그건 그 때 가서 생각하면 된다.

em.merge를 사용할 생각을 머리에서 지워야 한다.

그러니 Spring Data JPA에서도 save를 호출했을 때 em.merge까지 가지 않게 만드는 게 좋은 방식이다.

정말 만약에 GeneratedValue로 id값을 사용하지 않는 경우가 생기고, Spring Data JPA를 함께 사용하는 경우라면

위와 같은 방식으로 문제를 해결해서 사용하면 된다.

물론 그럴 일이 크게 많지는 않겠지만, 나중에 혹시라도 이런 일이 있을 때 성능에 왜 문제가 있는 지 고민하게 될 수 있으니 알아 두자.







