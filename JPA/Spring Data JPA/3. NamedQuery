







JPA를 배울 때 NamedQuery에 대해서 배운적이 있을 것이다.

Spring Data JPA는 이런 NamedQuery와 연동도 되어 있다.

쿼리 메소드 위에 @Query 어노테이션을 사용하고 네임드 쿼리에 명시한 네임드 쿼리 이름을 name값으로 주면 된다.

그럼 해당 메소드는 Entity에 작성된 네임드 쿼리를 수행한다.

이 때 @Query 어노테이션을 생략할 수도 있는데, 

쿼리 메소드는 기본적으로 인터페이스에 명시된 제네릭타입을 보고 메소드의 이름과 일치하는 네임드 쿼리가 있는 지 먼저 확인한다.

그리고 네임드 쿼리가 존재한다면 해당 네임드 쿼리를 실행한다.

이 때 네임드 쿼리를 사용할 때에는 @Param 어노테이션을 통해서 parameter이름을 명시하고 넘겨야 동작한다.

만약 네임드 쿼리가 존재하지 않는다면 메소드 이름을 보고 자동 쿼리 메소드 생성하는 방식을 선택해서 동작한다.


하지만 실제로 Entity에 작성된 네임드 쿼리를 쿼리 메소드에서 직접 사용하는 경우는 거의 없다고 한다.

애초에 Entity에 작성하는 형태의 네임드 쿼리 자체를 거의 사용하지 않기 때문이다.

하지만 이런 네임드 쿼리는 아주 강력한 장점이 있는데, 바로 컴파일 시점에 쿼리 문법 오류를 잡아 준다는 것이다.

또 단순히 메소드 이름만으로 해결하기에는 애매한 쿼리들이 있을 때에도 사용하기 좋다.

그래서 뭔가 이 네임드 쿼리를 잘 이용하면 참 좋을 것 같은데 방법이 없을까?


위의 @Query 어노테이션에는 사실 한 가지 기능이 더 있다.

Entity의 네임드 쿼리를 직접 가져다 사용하는 것도 가능하지만 @Query 어노테이션에 직접 네임드 쿼리를 작성하는 기능도 제공한다.

그래서 그냥 쿼리 메소드 위에 @Query 어노테이션을 작성하고 바로 쿼리문을 작성해 넣으면 

해당 쿼리 메소드는 @Query 어노테이션에 작성된 쿼리를 수행하게 된다.

네임드 쿼리를 Entity가 아닌 메소드 위에 바로 작성해서 사용할 수 있는 것이다.

@Query를 사용했기 때문에 parameter를 넘길 때에는 @Param 어노테이션을 꼭 넣어 주어야 한다.


이렇게 JPA interface를 구현하는 인터페이스에 @Query 어노테이션으로 네임드 쿼리를 사용하면

컴파일 시점에 쿼리 문법도 잡을 수 있고, 메소드 이름만으로는 한계가 있는 쿼리를 직접 작성하는 큰 장점이 있다.




