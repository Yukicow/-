







Spring Data JPA에서 Entity를 조회하는 게 아니고, 값 타입이나, DTO로 바로 데이터를 조회할 때 new 쿼리를 사용해야 하는 불편함이 있었다.

이런 new 쿼리 없이 바로 조회되는 데이터들을 원하는 타입으로 뽑아 주는 기능이 있는데 바로 Projection이다.

프로젝션 방법에는 여러 가지가 있는데, 인터페이스 방식의 프로젝션만 설명하겠다.

이게 개인적으로 제일 편하고 좋아 보이기 때문.


방법은 간단하다.

인터페이스를 하나 만들고 프로퍼티 방식의 getter를 만드는데, 이름을 꼭 조회하고자 하는 Entity의 필드명으로 적어야 한다.

예를 들어 Member Entity의 String타입 username을 조회하고 싶다면 인터페이스에 String getUsername()이라는 메소드를 추가하는 것이다.

이런 식으로 반환받고자 하는 모든 데이터들에 대한 프로퍼티 방식 메소드를 만들어 두면 된다.

그리고 그냥 Spring Data JPA에서 반환타입을 해당 인터페이스로 받아버리면 끝이다.


코드로 예시를 보여 주면

public interface MemberDto{

    String getUsername();
    Integer getAge();
}

public interface MemberRepository extends JpaRepository{

    List<MemberDto> findAllByUsername(String username);
}


위 처럼 작성된 findAllByUsername() 메소드를 호출하면 반환타입인 MemberDto에 맞춰 

m.username, m.age와 같이 username과 age에 대한 조회 쿼리만 나간다.

그래서 메소드명을 조회하려는 Entity 필드의 프로퍼티 방식으로 지어야 한다는 것이다. 

이게 단순히 원하는 이름으로 지으면 안 되고 Entity의 필드명에 맞춰서 지어야 한다.


위에서 Spring Data JPA에서 자동생성해 주는 쿼리를 사용해도 되지만 

우리가 직접 @Query로 JPQL을 작성할 수도 있다.

하지만 이럴 경우 버그가 하나 있다.

자동 생성해 주는 쿼리와 다르게 column명을 인식을 못 한다는 것이다.

그래서 이런 문제점을 해결하기 위해 'as' 문법을 사용해서 조회 컬러명을 프로퍼티의 get을 제외한 이름으로 맞춰 주어야 한다.


예를 들어 모든 Member를 조회하는 쿼리 메소드를 만들고 싶은데 findAll은 이미 있어서 어떻게 구현이 불가능하다.

그래서 @Query를 이용해서 직접 만들기로 했다고 해 보자.


public interface MemberRepository extends JpaRepository{

    @Query(value = "SELECT m.username as username, m.age as age FROM member")
    List<MemberDto> findAllMemberDto(String username);
}

위와 같이 as를 이용해서 alias를 설정해야 한다. 

직접 쿼리를 작성할 때에는 alias 설정하지 않으면 제대로 초기화가 안 되는 문제가 있으니 조심해야 한다.

여기서 진짜 꼭!!!!!!!!! 주의해야 할 점이 하나 있다

alias를 사용할 때 대소문자를 구문해서 적어야 한다는 것이다.

프로퍼티 메소드의 get을 제외하고 첫 문자를 소문자로 바꾼 형태의 column명으로 정확하게 적어야만 제대로 조회가 된다.

즉, 필드명을 대소문자 구분해서 정확히 똑같이 적어야 한다는 것이다.

만약 조회가 되지 않아 초기화 되지 않은 데이터는 null, primitive타입이라면 0을 집어 넣는다.


그리고 연관관계에 있는 Entity의 필드도 조회하고 싶으면 연관관계 Entity의 필드명을 적고 

그 다음 해당 Entity의 필드명을 적는 식으로 규칙이 정해져 있다.

이 규칙을 지키지 않으면 예외가 발생한다. 

예를 들어 Member의 연관관계에 Team이 있고 Team의 name이라는 필드에 접근하고 싶다면 

getTeamName 이런 식으로 프로퍼티명을 작성해야 한다.

Team에 또 Order라는 연관관계가 있고 price라는 필드가 있다면 getTeamOrderPrice의 형태로 접근이 가능하다.

getTeamOrderPrice외에 다른 이름으로 프로퍼티명을 작성하면 예외가 발생한다.

그리고 위에서 경고한 대로 이런 경우 JPQL에서 컬럼명에 alias를 줄 때에는 꼭 teamOrderPrice라고 주어야만 조회가 된다.

하나라도 철자나 대소문자가 틀리면 조회가 안 된다. 

이 경우는 예외가 안 터지고 그냥 값이 조회가 안 되어 초기화만 안 되기 때문에 예상대로 동작하지 않으면 어질어질하다.



이 프로젝션은 규칙이 까다로운 것만 빼면 좋아 보이지만 약간의 한계가 존재하는데, 

연관관계에 있는 대상을 함께 조회할 때에는 연관관계의 대상의 필드만 조회하는 기능이 불가능하다는 것이다.

연관관계 대상을 함께 조회할 때에는 무조건 연관관계 필드를 제외한 Entity의 값타입 필드를 전부 조회한다.

이게 알고리즘상 거기까지는 최적화가 안 되도록 되어 있는 것이다.

그렇기 때문에 성능상에 아쉬운 점이 있다.

그리고 Entity를 조회하는 개념이 아니고 값을 조회하는 개념이라는 점에서 

Dto처럼 바로 데이터를 객체로 받을 경우에는 적절하게 사용하면 아주 유용하다.



근데 사실 위의 단점들을 보완하는 방법이 하나 있다.

바로 네이티브 쿼리와 함께 사용하는 것이다.

먼저, Spring Data JPA에서 네이티브 쿼리를 사용하는 방법을 알아 보면

그냥 @Query 어노테이션에 네이티브 쿼리를 value 옵션에 작성하고 nativeQuery 옵션을 true로 주면 된다.

그럼 value에 작성한 네이티브 쿼리가 그대로 DB에 바로 나간다.


그럼 이 네이티브 쿼리와 프로젝션을 어떻게 조합할 수 있다는 것일까?

프로젝션은 프로퍼티 방식의 메소드의 get제외 이름을 통해 조회하고자 하는 데이터를 유추해 DB조회 쿼리를 생성하고 

조회된 결과들을 필드로 갖는 구현체를 생성해서 반환해 준다.

근데, 프로젝션만 사용하면 연관관계의 필드를 조회할 때에는 불필요한 데이터까지 함께 조회되는 문제가 있었다.

하지만 네이티브 쿼리는 우리가 직접 쿼리를 작성하기 때문에 필요한 데이터만 뽑게 작성할 수가 있다.

그리고 그렇게 뽑힌 데이터들은 그냥 프로젝션을 사용할 때처럼 똑같이 객체에 반영이 된다.

그리고 심지어는 위에서 아주 이상한(?) 문제였던, alias를 줄 때에 필드명과 대소문자까지 완전 일치해야 한다는 문제도 없다.

예를 들어 위의 예시로 getTeamOrderPrice를 통해 데이터를 조회할 때 조회된 데이터의 컬럼명은 꼭 teamOrderPrice이어야만 했다.

하지만 네이티브 쿼리는 철자만 맞는다면, 대소문자는 구분하지 않는다.

TeamOrderPrice, teamOrderprice, teamorderprice 이런 식으로 alias를 작성해도 바인딩이 잘 된다.



어차피 이런 값타입이나 Dto로 바로 받는 경우는 성능이 너무 안 나와서 성능 개선을 할 때이다.

프로젝션은 연관관계의 필드를 조회할 때 다른 필드도 전부 조회해 버리기 때문에 때에 따라서는 성능 개선에 크게 도움이 안 될 수도 있다.

그럴 때에는 nativeQuery와 프로젝션을 합친 방식을 사용하면 더 효과적으로 사용이 가능할 것이다.

그런데 어차피 이런 dto로 바로 받는 방식도 결국은 QueryDsl을 이용하면 편리하게 사용이 가능하기 때문에 위의 방식을 쓸 일은 그다지 없다.

가끔 네이티브 쿼리를 사용하고 정적 쿼리이며, Dto로 바로 뽑아내야하는 경우가 있을 수 있는데,

그럴 때에는 확실히 도움이 되는 방식일 것이다.

아니 이정도면 그 때만을 위한 기능이라고 볼 수 있는 수준이다.

하지만 그 경우에 한정해서는 무적의 성능이라고 볼 수 있다.

뭐 꼭 그렇지 않더라도 정적 쿼리인데, QueryDsl을 굳이 쓰기 귀찮고 위의 방법이 편하다면 나쁘지 않은 방식일 수도 있다.
