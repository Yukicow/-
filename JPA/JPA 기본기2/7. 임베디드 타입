






JAVA에는 primitive타입과 reference타입이 있다.

primitive타입은 값이 복사된다는 특징이 있고 reference타입은 참조값을 복사한다는 특징이 있다.

그래서 primitive타입은 서로 다른 변수에서 한 쪽이 다른 한 쪽의 변수를 초기화해도 값을 복사하기 때문에

한 변수의 변화가 다른 변수에 영향이 없다.

하지만 reference타입은 같은 참조값을 가지게 되기 때문에 한 쪽에서 참조하는 객체에 변화를 주면

그것을 참조하고 있는 다른 변수들의 데이터에도 모두 변경이 생긴다.


JPA에서는 이러한 특징을 조심해서 사용해야 한다.

Entity를 사용할 때에는 크게 문제가 되지 않는다.

Entity는 DB에서는 row에 해당하는 데이터이고, 어느 한 쪽이 변경한다는 것은

DB에서도 데이터를 변경한다는 의미이고 그것이 의도이다.

그렇기 때문에 같은 Entity를 참조하는 쪽이 있는데, 다른 곳에서 변경한 Entity의 값을 그대로 참조하는 건 의도된 것이다.

만약 이걸 의도하지 않고 사용하고 있다면, Entity를 제대로 사용하고 있는 게 아니고 설계가 잘못된 것이다.

이런 걸 의도한 것이 아니고, 그냥 각각의 Entity가 서로 고유하게 똑같은 형태의 데이터를 가지게 하고 싶었으면

Entity를 이용해서 연관관계를 매핑하는 것이 아니라, 그냥 Entity 내에 primitive타입의 필드를 추가했어야 한다.



예를 들어 Member와 Team에 서로 재각각의 주소와 관련된 값이 필요하다고 해 보자.

근데, 이 값을 하나의 Entity로 빼서 Member와 Team이 각각 참조하게 설계하는 것은 좋은 방법이 아니다.

Member의 주소와 Team의 주소값이 완전히 똑같아서 같은 주소 Entity를 참조하게 해 버리면 문제가 된다는 것이다.

Member에서 주소가 바뀌면 그걸 참조하던 Team의 주소도 바뀌기 때문이다.

그래서 이럴 경우에는 그냥 각각의 컬럼에 주소에 대한 속성을 추가하는 형태가 맞다.


딱 보면 너무나도 당연한 내용 같다. 근데 이걸 알아 둬야 하는 이유가 있다.

JPA에서 편의 기능이 하나 존재하는데 이 편의 기능 때문에 발생하는 문제가 있을 수 있는데 그걸 조심해야 하기 때문이다.

예를 들어 지금은 주소 하나만 존재하지만, 주소와 관련된 데이터들이 여러개 생겼다고 해 보자.

주소, 우편 번호, 도로명 주소 이렇게 세 개의 주소와 관련된 데이터가 있다고 해 보자.

그럼 평소와 똑같이 각각의 Entity에 이 세 가지 데이터를 필드로 넣으면 되는 문제다.


하지만 이러한 주소와 관련된 데이터 세 개가 다른 곳에서도 공통으로 사용된다고 해 보자.

이 데이터는 그냥 공통 내용일 뿐, 각 Entity끼리는 아무 연관이 없다.

따라서 이 세 데이터를 추상 클래스로 만들고 상속받게 하지는 못한다.

그냥 말 그대로 세 개의 데이터를 공통 분모로 빼서 필요한 곳에 딱딱 넣어서 사용하고 싶은 것이다.


이럴 때 사용할 수 있는 편의 기능이 존재하는데 바로 임베디드 타입이다.

객체를 생성해서 그 안에 공통 분모 필드를 넣고 임베디드 타입으로 사용하면,

필드에 그 객체를 넣어서 사용할 수 있다.

이 필드는 그냥 필드 3개를 하나로 묶은 거라고 볼 수 있다.

이 주소 객체를 생성하고 내부의 필드 데이터를 세팅해서 Entity의 필드에 초기화 하면

실제 DB에는 3개의 속성값에 그 객체에 담긴 값이 들어가게 된다.


마치 MappedSuperclass와 비슷하지만, MappedSuperclass는 필드를 그대로 Entity상에 주입해서 개별 필드로 사용하는 것이고

이 임베디드 타입은 그 필드 3개를 하나의 객체로 묶어서 관리할 수 있게 해 주는 것이다.

이렇게 객체로 관리하면 좋은 점이 필요한 필드끼리의 관심사를 묶을 수 있고, 

객체로 관리하기 때문에 내부에 필드를 이용한 메소드를 만들어서 다루기가 편하다.

Entity 객체에 필드를 이용한 메소드를 너무 많이 만들면 안 좋아 보이기 때문에 이런 관리의 편리함을 주기도 한다.


사용법도 간단하다. 그냥 관리할 필드를 담은 class를 하나 생성하고 @Embeddable 어노테이션을 추가하면

이제 임베디드 타입으로 사용할 준비가 되었다.

그리고 Entity에 이 객체를 참조하는 필드에는 @Embedded 어노테이션을 추가하면 된다.

그럼 우리는 이제 주소, 우편 번호, 도로명 주소에 대한 내용들을 하나의 객체를 통해 관리할 수 있게 된다.

new Address(주소, 우편 번호, 도로명 주소) 이렇게 해서 값을 setting하면 저 안에 있는 값이 DB에 

마치 필드에 그대로 setting한 것과 똑같이 동작하며 들어가는 것이다.



근데 이렇게 객체로 공통분모를 관리하면 확실히 큰 장점이 있지만 사용에 주의할 점이 있다.

아까 위에서 말한 이 편의 기능을 사용하면서 생기는 문제인데,

필드로 직접 컬럼을 관리할 때에는 보통 primitive타입을 사용하기 때문에 다른 곳에 같은 값을 초기화 해 줘도 서로 아무 관련이 없다.

하지만 이제는 객체가 되어 버렸기 때문에 만약 Address address = new Address(주소, 우편 번호, 도로명 주소)로 변수를 생성하고

Member.setAddress(address)와 Team.setAddress(address)로 서로 같은 address를 초기화 해 버릴 경우 문제가 발생할 수 있다.

서로 같은 주소라고 해서 이렇게 같은 address객체를 초기화 해 주면 같은 로직에서 중간에 Member쪽에서 address를 변경하기 위해 

Member.getAddress()로 address를 다시 가져와서 address의 필드값을 변화시킬 경우 Team의 address에도 영향이 간다는 것이다.


그래서 이런 임베디드 타입을 생성할 때에는 늘 불변 객체로 만들어 주어야 한다.

필드에 대한 setter를 만들면 안 된다. 값을 변경할 수 있는 여지를 주는 것을 방지하고

만약 값을 변경하고 싶으면 새롭게 객체를 생성해서 그 객체를 초기화 하도록 유도해야 한다.

그래야 완전히 서로 다른 객체를 참조하기 때문에 한 쪽이 맘대로 값을 변경해도(애초에 변경 못 하게 막았지만) 영향이 없다.

완전히 간섭의 여지를 주지 않도록 설계한 것이 된다.



만약에 같은 임베디드 타입의 필드를 두 개 이상 생성하면 어떻게 해야 할까?

예를 들어 Member에 자신의 주소에 대한 내용 뿐만 아니라, 직장에 대한 주소까지 적도록 되어 있다.

근데 이 주소에 대한 내용이 완전히 똑같은 컬럼이라서 Address라는 임베디드 타입을 두 개 설정하고 싶은 것이다.

하지만 이렇게 되면 속성 이름이 겹쳐서 사용이 안 되는 문제점이 있다.

이걸 해결하기 위한 기능이 @AttributeOverrides이다.

@AttributeOverrides( 
    @AttributeOverride(name = "", column = @Column(name = ))
    @AttributeOverride(name = "", column = @Column(name = ))
    @AttributeOverride(name = "", column = @Column(name = ))
    ) 

위의 형태로 오버라이드가 가능하다.




임베디드 타입을 사용할 때의 주의점이 두 가지 있다.

첫 번째는 임베디드 타입에는 꼭 기본 생성자를 만들어야 한다는 것이다.

기본 생성자를 JPA 내부적으로 이용하기 때문이다.

어디에 써먹는 지는 잘 모르겠지만 없으면 동작을 안 한다. Entity처럼 기본 생성자는 꼭 만들어 주자.


두 번 째는, 임베디드 타입 클래스의 필드에는 또 다른 임베디드 타입의 객체나, 심지어는 Entity도 올 수가 있는데,

@OneToMany와 @ManyToMany는 임베디드 타입 안에서 사용이 불가능하다는 것이다.

https://coderanch.com/t/682658/certification/Embeddable-class-oneToMany-relationship

위의 글을 읽어 보면 가능하기는 한데, 뭐 어떻게 한 건지는 모르겠고,

일단 막아 놓은 이유는 이렇다.

@ManyToOne과 @OneToOne은 자신이 fk를 갖는 방식이라 자신의 Entity에 다른 Entity의 식별키를 넣으면 되는데

@OneToMany와 @ManyToMany는 상대방 쪽에 fk를 만드는 형태이다.

근데 반대 쪽에서 fk를 가지려면 현재 Entity의 pk값이나 unique한 값이 필요한데,

임베디드 타입을 Entity와 띄어놓고 클래스 수준에서 보면 pk가 없는 상태이다.

또 임베디드 타입을 사용하는 Entity는 여러개일 수 있다. 애초에 그게 목적이기도 하다. 

oneToMany나 ManyToMany를 적용하려면 임베디드 타입을 사용 중인 모든 Entity의 id컬럼을 

다른 하나의 테이블에 fk로 모두 집어 쳐 넣어야 한다.

어쨋든 위와 같이 임베디드 타입에는 식별할 수 있는 유니크한 식별자가 없고, 

또 상대방 쪽에 몰아서 fk컬럼이 여러개 생기는 형태로 구현해야 하기 때문에 막아둔 것 같다.






