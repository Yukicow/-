






전에도 말했지만 우리가 특정 객체를 EntityManager를 통해 DB로부터 가져올 때, 

즉시 로딩으로 연관관계에 속해 있는 객체까지 한 번에 Join돼서 다 가져오면 문제가 많다.

성능상의 문제도 있고 연관관계를 제대로 인지하고 있지 않으면 쿼리가 생각한 거랑 다르게 나가는 것으로 오해의 소지가 있고

JPQL에서는 N+1 문제가 발생한다.

N + 1 문제라는 것은 JPQL를 통해 Entity(1)를 호출할 때, N개의 쿼리가 추가로 더해져서 나가는 현상을 말한다.

JPQL이라는 것은 객체와 매핑되는 쿼리문을 SQL로 해석해서 DB에 보내기 때문에

예를 들어 "SELECT i FROM Item i"라는 쿼리를 JPQL로 실행하면 일단 SELECT * FROM ITEM으로 해석되어 DB로 날려진다.

그리고 가져온 결과를 Item객체에 매핑시키는데, 이 때 필드를 봤더니 이 Entity에서 필요로 하는 다른 Entity가 있는 것이다.

그러면 그 Entity들을 조회하기 위해 필요로 하는 Entity의 수 만큼 DB에 조회 쿼리가 또 날아가게 된다.

즉, 원래의 Entity를 조회하기 위한 쿼리(1) + 그 Entity가 필요로 하는 Entity를 조회하는 쿼리(N) 만큼 쿼리가 수행된다.


심지어는 이 과정이 Entity 하나당 일어나는 것이다.

"SELECT i FROM Item i"로는 쿼리 한 번에 Item에 해당하는 모든 Entity를 불러오는데, 

그 Entity에 대해서는 Entity 각 하나당 참조하는 N개의 필드를 매핑하기 위해 N번의 쿼리가 수행되는 것이다.





이러한 문제점이 있기 때문에 무조건 즉시 로딩은 사용하지 말아야 한다.

우리는 이런 문제점을 해결할 수 있도록 지연 로딩이라는 것을 사용할 수가 있다.

지연 로딩은 프록시를 이용해서 실제 참조하는 Entity가 사용될 때에 쿼리를 수행하고 매핑시키도록 하는 방식이다.

저번 내용에서 getReference()를 사용하면 실제 Entity를 필드로 갖는 프록시 객체가 생성된다 했고

그 Entity의 데이터를 조회할 때에 실제 DB에 SELECT 쿼리가 나가서 Entity가 만들어지고 초기화된다고 했다.

지연 로딩은 이 원리를 이용해서 만들어진다.

Entity에서 연관관계를 갖는 필드에 지연로딩을 지정하면, Entity가 생성될 때 그 필드에 프록시 객체가 초기화된다.

그리고 실제로 그 필드의 데이터가 필요해서 조회를 할 때에 필드에 필요한 Entity를 생성하고 프록시 객체에 초기화한다.



그래서 우리는 일단 모든 연관관계는 다 지연 로딩으로 지정하고 사용해야 한다.

지연 로딩을 지정하는 방법은 연관관계를 지정하는 어노테이션에 fetch 옵션으로 LAZY를 주면 된다.

일단 모두 지연로딩으로 만든 다음에 필요한 것들에 대해서만 나중에 배울 fetch join을 사용하거나 개별 조회하면 된다.

아무리 두 연관관계가 함께 불려와지는 경우가 많다고 해도 일단은 무조건 지연 로딩이다.



연관관계에서 @ManyToOne과 @OneToOne은 기본이 즉시 로딩이기 때문에 따로 우리가 지정해 주어야 한다.

그리고 @OneToMany와 @ManyToMany는 기본이 지연 로딩이라서 따로 해 줄 필요는 없다.

근데 나는 개인적으로 그냥 다 LAZY로 명시를 하는 게 좋지 않을까 한다.

왜냐면 생략해도 된다고 해서 생략하다가 놓치면 답이 없기 때문.



참고로 지연 로딩을 걸어 놓아도, 참조하려는 Entity가 영속성 컨텍스트에 존재한다면 그 Entity를 그대로 주입해 준다.

굳이 있는 애를 초기화 안 시켜 놓고 나중에 다시 조회할 필요가 없기 때문이다.

그래서 영속성 컨텍스트에 참조하려는 Entity나 Entity프록시 객체가 있으면 지연로딩이어도 그 값을 비러 초기화 한다.




근데, 이게 지연 로딩이라는 것도 사실은 문제가 없는 게 아니다.

즉시 로딩과 다르게 로딩의 시점을 미룬 것 뿐이지 결국 나중에 조회를 하게 된다면 Entity에 필요한 Entity만큼 조회 쿼리가 나간다.

각 Entity별로 필요한 Entity 필드를 조회하는 데에는 결국 또 N + 1 문제가 발생한다는 것이다.

그래서 이런 문제를 해결하기 위해 뒤에서 fetch join이라는 것을 사용한다.