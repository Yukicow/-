







우리가 이제 연관관계를 매핑함으로써 Entity가 다른 Entity를 DB로부터 참조하여 가질 수 있게 되었다.

근데, 이렇게 되면 문제인 게 모든 곳에서 연관관계를 맺은 Entity를 필요로 하는 게 아닐 수도 있는데

일단 이 연관관계를 맺음으로써 Entity조회할 때 참조 Entity까지 함께 조회된다는 것이다.

그래서 당연히 이런 불필요하게 낭비되는 문제를 해결하기 위해서 JPA가 기능을 제공하는데 

바로 지연로딩과 즉시로딩이라는 개념을 통해서 제공한다.


이 것들에 대해서 제대로 알기 위해서는 JPA에서 프록시라를 어떻게 사용하는 지를 알아야 한다.

그래서 이번 내용에서는 그 프록시에 대한 내용을 정리해볼까 한다.


먼저, EntityManager를 통해서 DB로부터 데이터를 조회하는 방법은 두 가지가 있다.

find()와 getReference()라는 메소드를 사용하는 것이다.

이 둘의 동작 방식에는 차이가 있다.

find()같은 경우는 바로 DB에서 데이터를 조회하고 Entity와 매핑시킨 후 영속성 컨텍스트에 그 Entity를 저장한다.

하지만 getReference()의 경우는 바로 데이터를 조회하지 않고 Entity의 객체 타입을 상속받는 프록시를 하나 만든다.

이 프록시에는 나중에 초기화 받을 예정인 Entity를 필드로 가지게 된다.

그리고 이 프록시를 영속성 컨텍스트에 저장하게 된다.

이렇게 getReference()를 통해 받은 프록시는 DB에서 데이터를 조회하고 매핑된 Entity를 아직 초기화받지 못한 상태이다.

그래서 바로 조회 가능한 것은 pk값 뿐이라고 볼 수 있다.

pk는 getReference()를 통해 조회할 때 값을 넘기기 때문에 영속성 컨텍스트에 존재하는 프록시에서도 바로 조회할 수 있도록 하기 때문이다.


하지만 반대로 pk가 아닌 값을 조회할 때에는 실제 DB에서 Entity데이터들을 읽어와야만 조회할 수가 있다.

그래서 pk가 아닌 값을 조회하는 메소드가 실행되면 그 때가 돼서야 DB에 SELECT쿼리를 호출한다.

그리고 그 데이터를 Entity와 매핑해 Entity 객체를 생성하고 프록시 객체의 Entity를 참조하는 필드에 초기화한다.

즉, 그 전까지는 실제 DB에 SELECT쿼리가 나가지 않았기 때문에 당연히 Entity는 없는 샘인 것이다.

이렇게 DB로부터 Entity를 매핑하고 초기화가 되고 나면 

앞으로 프록시 객체는 초기화된 실제 Entity의 메소드를 호출해 값을 조회할 수가 있게 된다.


JPA는 한 가지 특성을 보장해야 한다.

바로 조회한 값을 항상 '=='을 할 경우 true를 반환해야 한다는 것이다.

이것은 DB에서의 REPEATABLE READ를 ORM기술을 사용하는 로직상에서도 보장하기 위한 기능인 것이다.

단순히 객체에 담긴 데이터만 같은 걸 보장하는 것이 아니라 완전히 같음을 보장해 준다.

예를 들어 위의 경우도 Entity가 영속성 컨텍스트에 불러져 왔다면 사실 그 이후부터는 프록시를 사용할 이유가 없다.

하지만 그럼에도 한 번 프록시를 호출한 적이 있다면 find()를 사용해도 프록시를 반환한다.


근데, 이건 어찌 보면 조금 당연하기도 한 게, EntityManager는 영속성 컨텍스트에 조회하려는 값이 있을 경우

그 값을 반환하면서 REPEATABLE READ를 보장하기 때문에 

한 번 getReference()가 호출된 적이 있다면 당연히 영속성 컨텍스트에는 프록시가 담겨 있고 

find()로 다시 호출을 한다고 해도 영속성 컨텍스트의 프록시가 반환되는 게 당연히 보장되어야 한다.

그렇기 때문에 그 반대의 경우도 똑같다. 

find()를 통해 실제 Entity가 먼저 조회되었고, 그 뒤에 getReference()를 호출해도

영속성 컨텍스트에는 실제 Entity가 담겨 있으니 실제 Entity가 반환되는 것이다.

또 성능상으로도 두 개를 분리하는 것 보다 하나를 계속 사용하는 게 더 좋다.

find()로 Entity를 조회했는데 getReference()를 해서 다시 프록시 객체를 반환해 버리면

그 프록시 객체를 통해 다른 데이터를 조회할 때 결국은 또 조회 쿼리가 나가야 하기 때문이다.



그리고 이러한 원리 때문에 조심해야 할 것도 있다.

당연하지만, 영속성 컨텍스트가 clear()로 비워지거나, detach()를 통해 Entity를 준영속 상태로 만들면

당연히 영속성 컨텍스트에는 Entity가 다시 없는 상태가 되기 때문에 find()나 getReference()를 호출하면 

그에 맞는 실제 Entity나 프록시 객체가 다시 생성되어 저장될 것이다.


이게 실제 현업에서 많이 겪는 문제라고 하는데,

트랜잭션을 하다 보면 보통 트랜잭션이 시작하고 끝날 때에 맞춰서 

영속성 컨텍스트도 시작되고 끝나기 때문에 트랜잭션이 끝나고 나서 

만들어져 있던 프록시 객체를 통해 값을 조회하려고 하는 경우(?) 뭐, 하여튼 이럴 때 많이 발생한다고 한다.

아무래도 영속성 컨텍스트가 한 번 비워졌기 때문에 기존의 프록시 객체를 이용해서 값을 조회하려고 해도

이미 영속성 컨텍스트의 범위 밖이기 때문에 DB와의 상호작용을 할 수가 없다.

그래서 이럴 때에는 다시 getReference()나 find()를 사용해서 영속성 컨텍스트에 저장을 해 준 뒤에 

그 결과값을 이용해서 데이터를 조회해야 한다.



이것뿐만 아니라 '=='의 사용도 조심해야 한다.

같은 객체임을 알기 위한 '=='이 아니라, 서로 다른 Entity인데, 같은 타입임을 증명하기 위해 '=='을 사용하는 경우이다.

예를 들어 Item이라는 Entity를 두 개 조회했다고 해 보자.

이럴 때에 item1은 find()를 통해 조회하고 item2는 getReference()를 통해 조회했다.

하지만 둘 다 같은 Item Entity이기 때문에 item1.getClass() == item2.getClass()로 조건을 걸었는데 false가 나와 버린 것이다.

이는 당연하게도 find()로 받은 객체는 실제 Entity이지만 getReference()로 받은 객체는 프록시이기 때문에 둘은 서로 다른 타입이다.

이런 경우가 발생할 수 있기 때문에 조심해서 사용해야 한다.

물론 실제로 이런 상황이 생기는 경우는 많지 않겠지만. 

이럴 때에는 item1.getClass() == item2.getClass()이렇게 사용하는 게 아니고 

item1.getClass() instanceof Item 이렇게 사용해야 한다.










