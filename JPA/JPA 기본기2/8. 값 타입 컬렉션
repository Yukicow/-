







우리가 지금까지 Entity의 필드에 여러 데이터를 담는 건 해 보았다.

근데 컬렉션 형태의 데이터를 담아 본 적은 없다.

@OneToMany 관계에서 Entity를 컬렉션 형태로 갖는 것은 해 보았는데,

Entity는 아니고 그냥 일반 primitive타입이나 임베디드 타입의 데이터를 컬렉션 형태로 갖고 싶다면 어떻게 해야 할까.


DB에는 여러 데이터를 하나의 row에 다 담아낼 수 없기 때문에

결국은 @OneToMany 방식 처럼 별도의 테이블을 만들고 필요한 속성들과 Entity를 참조할 fk를 생성한 뒤, 

거기에 Entity를 통해 생성되고 추가되는 컬렉션 데이터에 맞춰 row를 만들고 참조하면 된다.

사실 구현 방법은 @OneToMany랑 거의 같은 방식으로 하지만 Entity가 아니라는 점만 차이가 있다.

Entity가 아니기 때문에 따로 pk값을 가지지 않는다.

그래서 우리가 직접 pk를 지정해 주어야 하는데, 모든 컬럼을 다 합쳐서 하나의 pk로 직접 DDL을 사용해서 지정해야 한다.

여기서 모든 컬럼을 합쳐서 pk로 지정하는 이유는 완전히 똑같은 데이터를 제외하고는 모두 허용해야 하기 때문이다.

값 타입 컬렉션의 데이터는 그 값이 다르다는 보장이 없다. 서로 같은 데이터들이 들어가도 괜찮은 데이터들이다.

그런데 pk를 특정 컬럼 하나에 의존하게 되면 그 값이 겹치는 데이터를 배제하게 되기 때문에 문제가 발생할 수 있다.


그럼 위와 같은 것을 직접 테이블을 만들고 @OneToMany로 매핑해서 사용해야 할까?

그렇게 해도 상관은 없겠지만 이런 값 타입들에 대한 컬렉션을 위해 JPA가 제공하는 기능이 있다.

@ElementCollection이라는 어노테이션이다.

Entity에 값 타입에 대한 컬렉션 필드를 하나 생성하고 이 어노테이션을 붙여 주면 된다.

그럼 자동으로 @OneToMany처럼 해당 값 타입 데이터에 대한 테이블을 생성해 주고 

앞으로 컬렉션에 들어갈 데이터들은 모두 그 테이블에 저장되게 된다.


이 때 자동으로 생성되는 테이블에 이름을 지정할 수 있는데 @CollectionTable에 name옵션을 주면 된다.

또, fk에 이름을 지정하는 옵션도 있다. joinColumn옵션이다. 여기에 @JoinColumn으로 value를 주면 된다.

생성되는 컬럼에 까지 이름을 지정하고 싶다면 만약 일반 String이나 primitive타입의 경우는 @Column어노테이션으로 지정이 가능하다.

어차피 컬렉션에 들어 있는 데이터가 딱 하나이기 때문에 지정할 컬럼명도 하나라서 @Column을 지원한다.

하지만 임베디드 타입의 데이터를 컬렉션으로 받고 있다면, 임베디드 타입 클래스 내부에 지정한 @Column값이 사용된다.

이게 싫다면 @AttributeOverrides를 이용해서 지정하면 된다.



그럼 이제 우리는 Entity에서 컬렉션을 통해 값을 추가하고 제거할 수 있게 되었다.

이러한 값 타입 컬렉션은 Entity가 아니고 말 그대로 값 타입 데이터이기 때문에 생명주기가 Entity를 따라간다.

Entity에 컬렉션을 세팅하고 영속성 컨텍스트에 컬렉션을 따로 저장하지 않아도 그 값은 DB에 반영된다는 것이다.

당연하게도 Entity가 아니고 그저, 값에 불과하기 때문에 따로 영속성 컨텍스트와 관련이 없는 녀석들이다.

또, 그렇기 때문에 CollectionTable에 들어가는 데이터를 먼저 생성하고 거기서 Entity를 설정하는 것이 먹히지 않는다.



컬렉션에 이렇게 임베디드 타입을 쓸 때에는 equals와 hash 메소드를 제대로 오버라이딩해야 한다.

이걸 정확하게 해 주지 않으면 컬렉션에서 remove를 해 줄 때에 임베디드 타입 객체를 넘겨서 remove를 하게 되는데 이 때 문제가 발생한다.

remove에서 객체를 넘겨면 그 객체와 같은 객체를 삭제한다.

근데 이 때 아예 레퍼런스가 같은 객체면 바로 삭제가 되는데, 우리는 보통 삭제를 할 때에 같은 레퍼런스 데이터를 주는 게 아니고

그저 다른 객첸데 그 안의 데이터가 같은 객체를 넘기게 된다.

그럼 이 때 equals와 hash 메소드가 값을 확인하는 형태로 제대로 오버라이드 되어 있지 않으면 remove가 제대로 동작하지 않게 된다.

컬렉션을 다뤄야 한다면, 아니 일단 임베디드 타입을 만들면 equals와 hash를 오버라이딩 해 놓는 게 좋다.

또, 이런 임베디드 타입 뿐만 아니라 Entity에서 양방향 연관관계를 사용하거나, @ToMany를 사용할 때

컬렉션을 통해 Entity를 저장하고 지우는 걸 하기 때문에, 이 때에도 equals와 hash를 오버라이딩 해야 한다.






자 이제 여기서부터가 ㅈㄴ 중요한 내용이다.

사실 이 기능에는 아주 큰 문제가 있다.

위에서도 말했지만 이 값 타입 컬렉션을 구현하기 위해서는 모든 컬럼을 pk로 지정해서 사용해야 한다고 했다.

그래서 컬럼에 null이 허용되지 않고, row의 추적이 어렵다.

예를 들어 List에서 데이터를 하나 지웠다고 해 보자.

그럼 지운 데이터가 DB에서 어떤 row와 매핑되어 있는 지를 확인하기가 너무 번거롭다는 것이다.

모든 컬럼이 pk로 사용되니 조건이 너무 길어진다.

그래서 이런 값 타입 컬렉션에서는 컬렉션에 변화가 있을 경우 완전히 테이블의 row을 모두 지워 버린 다음

컬렉션에 있는 데이터를 하나하나 다시 insert해서 row를 생성하는 형태로 동작한다.


와..그럼 성능이 미친듯이 구리겠네요.

맞다.

그래서 이 기능은 사실 사용하면 안 된다.

위와 같은 문제점을 해결하기 위해 @OrderColumn이라는 어노테이션을 이용해서 해결이 가능하기는 하다.

이 어노테이션을 이용하면 테이블에 row 순서에 대한 컬럼이 하나 추가되어서 row 추적을 도와 주기 때문에 해결이 가능한 것이다.

하지만 이것도 의도대로 동작하지 않을 때가 있고, 이 순서를 나타내는 컬럼에 null이 들어가는 경우가 생겨서 문제가 발생할 수 있다.


그래서 실제로는 이 값 타입 컬렉션을 사용할 상황이라면 그냥 일대다 관계를 고려하는 게 훨씬 좋다고 한다.

아예 일대다 관계를 이용해서 참조하는 개체를 Entity로 사용해 버리면, id가 존재하기 때문에 row의 참조도 좋다.

사실상 값 타입 컬렉션과 동작은 똑같고, 성능은 더 좋고 안정적인 형태를 구현할 수 있다.

또 모든 생명 주기에 대한 옵션도 있어서 공유되는 경우와 아닌 경우를 분리하기도 좋다.

값 타입 컬렉션처럼 다른 곳에서 공유되는 것을 고려해서 불변 객체로 만들 필요도 없고 훨씬 안정적이다.





그럼 값 타입 컬렉션은 아예 안 쓰나요..

그건 아니다. 정말 단순한 경우에는 사용한다고 한다.

예를 들어 준 게 뭐 SELECT 박스로 치킨과 피자를 고를 수 있는 경우 뭐 이런 예시를 들었는데

아직 제대로 이해는 안 된다. 나중에 쓰는 경우가 어떤 경우인 지 알게 되면 그 때 작성해 보자.