







고아 객체는 참조 받는Entity가 자신을 참조하는 Entity로 부터 버려진 것을 말한다.

예를 들어 Team과 Member가 있을 때 Team의 필드에 List<Member>가 연관관계로 매핑되어 있다고 하자.

여기서 Team이 List<Member>에서 Member1을 지웠다고 해 보자.

그럼 Member1은 Team을 잃었기 때문에 고아 객체가 된 것이다.

이렇게 고아 객체가 되어도 사실 아무 문제가 없다.

그냥 Team만 잃은 Member인 것 뿐이다.


하지만 이 고아 객체를 이용한 옵션이 하나 있다.

바로 orphanRemoval이다. 

이 옵션을 사용하면 고아 객체가 된 Entity를 DB에서 제거한다.

단방향 연관관계에서 Entity의 참조 관계가 끊어져도 DB에서 사라지는 것은 아니었다.

만약 지우고 싶으면 직접 지우는 로직을 작성해야 했다.

하지만 이 옵션을 true로 설정할 경우 자동으로 참조 관계가 끊어져 고아 객체가 된 Entity를 DB에서 삭제시켜 준다.


이러한 특징이 있어서 CascadeType.REMOVE와 똑같이 동작하는 케이스가 하나 있다.

바로 위의 경우에서 Team이 아예 사라지는 경우이다.

orphanRemoval이 true인 상태에서 Team이 아예 사라질 경우 List<Member>에 있는 모든 Member들은 Team과의 참조 관계가 모두 끊어진다.

그렇기 때문에 모든 Member들은 삭제가 되어 버린다.

이렇게 orphanRemoval을 true로 사용하면 Team을 삭제하는 것에서는 CascadeType.REMOVE와 똑같이 동작한다.

정확히는 고아 객체를 지우는 동작을 하는데 그게 모두에게 적용된 것이다.

이런 동작체계를 정확히 이해하고 사용해야 한다.


고아 객체 또한 삭제가 일어날 수 있는 옵션이기 때문에 참조하는 Entity가 하나일 때 사용하는 게 좋다.

예를 들면 이런 경우에는 사용해도 좋을 듯 하다.

게시글과 첨부파일이다.

첨부파일은 게시글에서만 관리하기 때문에 첨부파일의 생명주기를 게시글이 가져가도 문제가 없다.

게시글에 달린 첨부파일을 삭제하면 그 첨부파일은 다른 곳에서 쓰일 일이 없으니 완전히 삭제되어도 괜찮다.

또 게시글이 삭제되어도 첨부파일도 함께 삭제되어야 한다.

이런 특정 조건이 갖추어진 경우에는 사용할 수 있을 것 같다.



CascadeType.ALL과 orphanRemoval = true를 이용하면 참조되는 Entity의 생명주기를 

참조하는 Entity가 완전히 관리할 수 있는 상태가 된다.
