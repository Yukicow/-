





만약 Entity가 특정 Entity를 상속받아서 구현되어 있는 형태일 때 DB와 어떻게 맞추어야 할까?



Entity가 다른 Entity를 상속하면 따지고 보면 상속을 받은 Entity가 상속하는 Entity를 모두 포함한 것과 다를 게 없다.

DB에서 이런 모양새를 구현하기 위해서는 상속을 받는 Entity를 통해서 상속하는 Entity가 함께 표현이 되면 되는 구조이다.

이 방법에는 3가지가 있다.


첫 번째는 Join전략을 이용하는 것이다.

각각의 Entity를 테이블로 구분하고 fk를 통해서 연결을 시킬 수 있도록 만들면 된다.

어떻게 보면 하나의 Entity에 객체 필드를 생성하고 @OneToOne으로 연관관계를 매핑한 것과 동작이 거의 같다고 볼 수 있다.


두 번째 방법은 부모 Entity에 해당하는 하나의 테이블에 모든 자식 Entity에 대한 컬럼을 포함시키고, 

어떤 자식 Entity에 대한 row인 지를 나타낼 수 있도록 Type컬럼을 생성해서 지정해 주는 것이다.

테이블을 여러개 만드는 것 보다 성능면에서는 이득이 있지만, 하나의 테이블에 너무 많은 컬럼과 연관 없는 컬럼이 섞인다는 단점이 있다.


세 번째 방법은

아예 DB상에서는 부모 Entity에 대한 테이블을 없애고, 각각의 자식 Entity에 부모 Entity의 컬럼을 직접 추가하는 것이다.

사실상 객체지향적 관점에서 보면 공통 부분을 하나의 클래스로 빼지 않고 각자가 갖고 형태라고 볼 수 있다.

하지만 어차피 RDB에서는 객체지향이라는 개념이 없고, 객체지향언어에서의 패러다임만 맞추면 되기 때문에 이렇게 사용해도 표현은 가능하다.



JPA는 이 세 가지 방법을 모두 지원한다.

기본적인 전략은 두 번째 방법인 하나의 테이블에 모두 때려박는 방식이고, 옵션으로 바꿀 수 있다.

이 옵션을 바꾸는 방법은 부모 Entity에서 @Inheritance(strategy = ) 옵션을 설정하면 된다.

첫 번째 방법에 대한 strategy는 JOINED이고, 두 번째 방법에 대한 strategy는 SINGLE_TABLE이고,

세 번째 방법에 대한 strategy는 TABLE_PER_CLASS이다. 


각각의 방식에 대한 장단점을 한 번 알아보자.



1. SINGLE_TABLE

하나의 테이블에 모든 자식 Entity 데이터를 포함하도록 테이블을 생성하는 방식이다.

당연히 테이블이 하나기 때문에 조회하는 데에 있어 성능이 더 좋다는 장점이 있다.

하지만 서로 연관없는 데이터가 하나의 테이블에 엮여서 존재하기 때문에 컬럼이 너무 많아질 수도 있고,

자식 Entity와 매핑된 컬럼들은 모두 null을 허용해야 한다는 문제점이 있다.

또 DTYPE이라는 현재 row가 어떤 자식 Entity를 나타내고 있는 지를 나타내는 컬럼이 추가적으로 필요하다.



2. JOINED

fk를 이용해서 부모 Entity와 자식 Entity 테이블을 서로 연결시키는 방식이다.

테이블이 정규화되어 있다는 장점이 있고, 외래키를 이용하기 때문이 이를 활용할 수 있다는 장점이 있다.

조회 시 Join을 많이 사용하고, 조회쿼리가 복잡하며, insert쿼리가 두 번 나가게 된다는 등의 단점이 있지만 크게 문제되는 정도는 아니다.

기본적으로는 JOINED전략이 정석이라고 보는 게 좋다고 한다.


JOINED 전략을 사용하더라도 DTYPE을 만들 수 있다.

그리고 가능하면 무조건 사용하는 게 좋다.

왜냐하면 부모 Entity만을 단독으로 조회할 일이 있을 수 있는데, 이 때 DTYPE이 없다면

어떤 자식 Entity에 대한 부모 Entity 테이블인 지를 인지할 수가 없기 때문에 DTYPE을 생성하도록 명시하는 게 좋다.

DTYPE을 생성하도록 하는 어노테이션은 @DiscriminatorColumn이다.


이 어노테이션을 사용했을 때 기본 생성되는 컬럼이름은 DTYPE이고 name옵션을 통해 변경 가능하다.

또, 컬럼에 저장되는 value는 자식 Entity들의 객체 이름을 기본으로 사용하는데, 이 때 value를 직접 지정할 수도 있다.

자식 Entity들에 붙일 수 있는 어노테이션이 있는데 @DiscriminatorValue이다.

여기에 값을 지정하면 @DiscriminatorColumn에 들어가는 value가 @DiscriminatorValue에 명시한 값이 된다.






3. TABLE_PER_CLASS

각각의 자식 Entity 테이블에 부모 Entity에 해당하는 데이터를 직접 때려박는 형태이다.

서로 연관 있는 것들끼리만 딱 테이블에 데이터가 들어가는 형태이기 때문에 제일 깔끔한 형태이다.

그리고 각 테이블에 어차피 연관 있는 데이터만 있기 때문에 DTYPE이 필요가 없다.


정말 좋은 방법 같아 보이지만 큰 문제점이 있다.

바로 부모 타입으로 데이터를 조회하는 경우이다.

당연하게도 이 방식은 자식 Entity에서 자신의 pk만을 갖는다.

부모 Entity에 대한 테이블이 존재하지 않기 때문에 자신의 pk만을 갖는다는 것이다.


이 때, 자신의 pk를 이용해서 자신의 Entity를 바로 조회하는 경우는 문제가 되지 않는다.

그냥 자신의 테이블에서 pk로 조회하면 끝나니까.

하지만 자신의 pk로 부모 Entity타입을 바로 조회할 때에는 어떡할까?

예를 들어 Item이라는 부모 클래스가 있고, Movie,Food가 있다고 해 보자. 

그럼 em.find(Item.class, movie.getId) 로 조회를 하면 어떻게 될까?

movie의 id를 이용해서 조회하고 있지만 사실 DB에서 조회하는 입장에서 보면 이게 movie Entity의 id인 지 모른다.

왜냐하면 앞에 Item.class를 통해서 조회하고자 하는 녀석을 인지하기 때문에 Item만을 추출하려 할 것이고,  

그러기 위해서는 Item.class를 상속 받는 모든 테이블을 Union해서 거기서 id값을 pk로 갖는 row가 있는 지를 검색하거나

모든 Item을 상속받는 Entity와 관련된 테이블에서 하나하나 다 조회한 다음 있다면 거기서 Item.class에 맞게 추출해야 한다.

심지어 테이블이 각각 따로기 때문에 pk가 같아지기라도 하면 값이 여러개 조회될 수도 있다.


이 외에도 문제가 너무 많다. 

서로 묶이는 개념이 없다는 것과 그런 특징 때문에 나중에 추가되는 것이 있을 때 모든 테이블에 하나하나 반영해 주어야 하는 등..

이러한 문제들이 많이 있기 때문에 전문가들이 추천하지 않는 방식이라고 한다.

그냥 사용하지 말자.






상속관계 매핑 시 주의점

TABLE_PER_CLASS를 사용해도 부모 Entity의 테이블이 만들어지는 경우가 있다.

바로 부모 Entity를 abstract 클래스로 만든 게 아니고 일반 클래스로 만든 경우이다.

일반 클래스를 @Entity로 선언하면 그 클래스만을 따로 조회할 일이 있다고 가정하고 테이블을 생성한다.

어차피 TABLE_PER_CLASS를 사용할 일은 거의 없겠지만 혹시 그런 일이 발생할 수 있으니 

부모 클래스 Entity는 abstract로 만들어야 한다.

그리고 꼭 이거 때문만은 아니더라도 abstract로 만드는 게 맞다.

어차피 다른 전략을 사용해도 abstract를 사용하는 게 명시적으로 더욱 좋은 효과가 있고 

어차피 다른 전략에서는 테이블을 만들어 주기 때문에 abstract로 한다고 일반 클래스와 다를 게 없다.



