





프로젝션이란 SELECT 절에 조회할 대상을 지정하는 것을 말한다.

프로젝션 대상에는 Entity, 임베디드 타입, 스칼라 타입(숫자, 문자 등의 primitive타입)이 될 수 있다.



@Entity
Class Member{

    @Id @GenerateValue
    private Long id;

    private String memberName;
    private Integer age;

    @ManyToOne
    @JoinColumn(name = "team_id")
    private Team team;

    @Embedded
    private Address address;

}


위와 같은 Member라는 Entity가 있다고 해 보자.

여기서 Entity를 조회하는 형태의 JPQL은

SELECT m FROM Member m, SELECT m.team FROM Member m 이 두 가지가 해당될 수 있다.

이 둘은 엔티티 프로젝션이 되는 것이다.

SELECT m.address FROM Member m 이건 임베디드 타입을 조회하니 임베디드 타입 프로젝션,

SELECT m.memberName, m.age FROM Member m 이 경우는 기본 타입의 데이터들을 조회하는 경우이니 스칼라 타입 프로젝션에 해당한다.




Entity 프로젝션은 가져온 Entity는 자동으로 영속성 컨텍스트에 담긴다는 장점이 있다.

그래서 그냥 Entity 프로젝션으로 가져온 데이터를 변경하면 알아서 DB에 반영이 된다.


하지만 당연하게도 임베디드 타입 프로젝션으로 가져온 임베디드 타입은 영속성 컨텍스트와는 관련 없는 그냥 데이터이다.

이 값은 Entity로부터 특정 데이터만을 조회하고 그대로 임베디드 타입 객체에 담은 것 뿐이지, 

Entity 자체를 가져온 것이 아니기 때문에 임베디드 타입 프로젝션으로 조회한 임베디드 타입 객체의 값을 변경해도 DB에 반영되지 않는다.

너무 당연한 내용이다.

그리고 애초에 우리는 임베디드 타입의 값을 변경할 수 있게 하는 걸 막는 것이 좋다고 했다.

그렇기 때문에 임베디드 타입을 받아와서 값을 변경하는 일은 애초에 거의 없다.

임베디드 타입 프로젝션은 그냥 Entity의 특정 데이터 부분을 조회해서 보는 용도라고만 생각하자.



제일 사용법이 까다로운 것은 스칼라 타입 프로젝션이다.

우리가 Entity를 전체 가져오는 게 아니고, 임베디드 타입으로 가져오는 것도 아니면

특정 값, 또는 특정 값들만을 가져올 텐데, 이럴 경우에는 가져오는 값의 형태가 정해져 있기 않기 때문에 까다롭다.

예를 들어 당장 위의 "SELECT m.memberName, m.age FROM Member m" 만 봐도 

두 데이터는 타입이 다른데, 어떻게 한 번에 가져올까..?

그래서 이런 경우 쿼리 객체로부터 결과를 받아올 때 Object[] 형태로 값을 받는다.

만약 결과가 여러개라면 List<Object[]>일 것이다. 


근데 이게 슬픈 게 getResultList() 메소드로 값을 받으면 기본적으로 반환 값은 Object[]이지만 타입캐스팅이 한 번 필요하다.

물론 이 경우는 List results = em.createQuery().getResultList의 형태로 받을 때이고

List의 generic으로 Object[]를 List<Object[]>로 넣어 주면 따로 타입 캐스팅은 필요하지 않다.

근데 타입 캐스팅을 하든 안 하든 중요한 건 좀 귀찮은 방식으로 동작한다는 것이다.

이걸 Object 배열로 받아서 그 값을 하나씩 꺼내서 사용해야 한다니..좋지 않다.


그래서 이런 불편한 사항을 해결해 주기 위해 특정 클래스로 매핑해서 바로 데이터를 받을 수 있도록 하는 기능이 있다.

약간 임베디드 타입처럼 조회해서 나온 결과를 특정 객체와 매핑해서 값을 넣어 주는 것이다.

사용법은 간단하다.

"SELECT m.memberName, m.age FROM Member m"에 매핑 시킬 객체의 생성자를 통해 객체를 생성하듯

em.createQuery("SELECT new 패키지명.객체명(m.memberName, m.age) FROM Member m", 객체명.class) 이렇게 호출하면 된다.

그럼 그 객체의 생성자를 호출해서 DB로 가져온 값을 인자로 넘겨 객체를 생성한다.


조금 패키지명과 객체명이 길어질 수 있다는 단점이 있지만 한 번에 객체에 값을 담아올 수 있다는 장점이 있다.

이렇게 스칼라 타입 프로젝션을 사용하는 경우는 보통 값을 Dto를 통해 반환하는 용도로 사용하는 경우가 많기 때문에

DTO를 잘 이용하면 유용하게 사용할 수 있다는 장점이 있다.


하지만 사용에 조금 주의해야 하는데, 위를 보면 알겠지만 생성자를 통해서 생성한다.

그래서 만약 DTO에는 필드가 3개인데 불러오는 데이터는 2개이고 DTO와 매핑시키고 싶다면

DTO에는 그 값 두 개에 대한 생성자가 따로 또 존재해야만 객체를 생성할 수가 있다.

심지어는 생성자에서 인자의 위치가 JPQL에서 new에 들어가는 인자의 순서와 일치해야 한다는 문제도 있다.

이걸 잘 모르고 사용하면 매핑 시켰는데 왜 안 되지? 또는 생성자가 있는데 왜 안 되지? 하는 문제가 발생할 수 있으니 조심하자.




