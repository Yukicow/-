








OSIV(Open Session In View)에서의 Session은 EntityManager를 말한다.

좀 더 쉽게 얘기하면 영속성 컨텍스트를 말하는 것이다.

말 그대로, 영속성 컨텍스트를 View단까지 살려둔다는 뜻이다.

이는 필터 또는 인터셉터를 통해 구현되는데, Spring boot는 기본으로 JPA OEIV 스프링 인터셉터를 이용한다.


동작 원리는 다음과 같다.

1. 클라이언트의 요청이 들어오면 서블릿 필터나, 스프링 인터셉터에서 영속성 컨텍스트를 생성한다. 단 이 시점에서 트랜잭션은 시작하지 않는다.

2. 서비스 계층에서 @Transeactional로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.

3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이 시점에 트랜잭션은 끝내지만 영속성 컨텍스트는 종료되지 않는다.

4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.

5. 서블릿 필터나, 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때 플러시를 호출하지 않고 바로 종료한다.


위와 같은 원리로 View단까지 영속성 컨텍스트를 살려둘 수 있다.



지금까지 우리는 Spring boot를 사용하면서 한 가지 함정에 빠져 있었던 것이다.

트랜잭션이 끝나면 영속성 컨텍스트가 사라지고 모든 Entity들이 영속성 컨텍스트의 관리하에서 빠진다고 생각한 것이다.

하지만 사실 OSIV가 default로 true로 되어 있기 때문에 영속성 컨텍스트는 요청이 완전히 처리될 때까지 살아 있다.

# 물론 boot를 사용하지 않으면 따로 등록하지 않는 이상 우리가 배운 내용대로 동작하는 게 맞다.


영속성 컨텍스트라는 것은 Connection을 가지고 동작한다.

당연하게도 Connection을 통해서 값을 조회하고 변경해야 하기 때문에 트랜잭션이 시작될 때 Connection을 가지고 와서 사용한다.

우리는 당연한게 트랜잭션이 끝나면 영속성 컨텍스트가 이 Connection을 반환하고 영속성 컨텍스트가 닫힐 거라고 생각했다.

하지만 그렇지 않다.


그렇기 때문에 Controller에서도 Entity의 지연 로딩이 제대로 동작했던 것이다.

원래라면 Controller에서는 @Transaction이 먹혀 있지 않기 때문에 지연 로딩이 일어나서는 안 된다.

하지만 OSIV가 true로 되어 있기 때문에 요청에 대한 Response가 나갈 때까지 영속성 컨텍스트가 살아 있어 가능했던 것이다.


여기서 주의할 점은 변경감지는 일어나지 않는다는 것이다.

영속성 컨텍스트는 기본적으로 트랜잭션 내에서만 데이터를 조회 및 수정 가능하게 한다.

하지만 트랜잭션 범위 밖에서 Entity의 조회는 가능하도록 구현해 두었는데, 이를 NonTransactional reads라고 한다.

그래서 영속성 컨텍스트를 사용할 때에는 트랜잭션 범위 밖에서 Entity의 데이터를 변경해도 DB에는 반영되지 않는다.

그래서 OSIV를 사용할 때에도 마찬가지로 데이터의 변경은 트랜잭션 안에서만 가능하다. 

이는 필터나 인터셉터에서 영속성 컨텍스트를 종료하는 시점에

flush()를 호출하지 않고 그냥 close()를 바로 호출해 종료하기 때문이고,

설령 flus()를 강제로 호출한다고 하더라도 트랜잭션 범위 밖에서 데이터 변경을 시도했기 때문에 

강제로 TransactionRequiredException을 터트리도록 구현되어 있기 때문이다.


하여튼 OSIV를 사용하면 Entity의 생명 주기가 요청을 마칠 때까지 이어지기 때문에 활용성이 높아 큰 장점이다.

하지만 반대로 영속성 컨텍스트가 동작하기 위해 Connection을 요청이 끝날 때까지 유지해야 해서, 

Connection을 너무 오래 갖고 있는 큰 단점도 존재한다.

이는 트래픽이 많을 경우 문제가 발생할 수도 있다.


그렇다고 OSIV를 false로 꺼 버리면, 모든 지연 로딩은 @Transaction 안에서 처리한 후에 넘겨야 한다.

Connection에서 지연 로딩을 하려 하면 LazyInitializationException이 발생한다.

당연하게도 프록시 객체에서 지연 로딩을 통해 값을 조회하려 하는데, 영속성 컨텍스트에서 이미 벗어났기 때문에 문제가 발생하는 것이다.

이런 경우에는 FETCH JOIN을 사용해서 미리 값을 초기화하거나 지연 로딩을 @Transaction내에서 처리하고

Controller에 DTO를 넘기는 식으로 사용해야 한다.

그래서 이럴 때에는 API나 View에 맞춘 Service를 별개로 만들어서 사용하거나, 계층을 추가해서 사용하는 등으로 해결한다고 한다.


그래서 결론은 Connection을 많이 필요로 하는 서버의 경우는 OSIV를 끄고 위처럼 계층을 추가하거나 

별개 service를 생성하는 등의 여러 방식 중 아키텍쳐에 맞는 방식을 선택해 해결하고 

딱히 Connection에 의한 성능 문제가 없는 곳이라면 그냥 OSIV를 켜 놓고 사용하는 게 좋다고 한다.




참고로 Test에서는 OSIV가 동작하지 않는다.

@SpringBootTest를 써 놓아도 OSIV가 동작하지 않기 때문에

Test에서는 따로 적절한 곳에 Transaction을 제대로 걸어야 한다.

만약 Test에서 Transaction을 걸지 않은 상태에서 조회된 Entity를 이용해 

지연 로딩으로 필드 값을 조회할 경우, 제대로 조회되지 않는 문제가 발생할 수 있다.

이는 OSIV가 동작하지 않기 때문에 트랜잭션 구간 외에서 영속성 컨텍스트가 존재하지 않고, 

이 상태에서 지연 로딩으로 필드값을 조회할 경우 당연히 조회가 안 된다.