










4. 둘 이상의 컬렉션을 동시에 FETCH JOIN 할 수 없다.

이건 성능상의 문제 때문인 것 같은데 지원을 하지 않는다.

뭐 어떻게 어떻게 하면 가능하기는 하다는데, 알려주지도 않고 별로 하고 싶지도 않다.


성능상 안 좋은 이유는 예를 들어 Team이 Member와 Order에 대한 두 개의 컬렉션을 갖고 있다고 해 보자.

Member와 Order를 한 번에 둘다 Fetch Join으로 가져오려고 시도 하면 DB에서는 어떻게 동작해야 할까?

일단 Fetch Join을 한다는 것은 두 컬렉션은 Team을 조회할 때 관련된 Entity들이 모두 함께 조회되어야 한다.

Team과 Member 이렇게 둘만 있으면 Team에 대한 Member를 뻥튀기 해서 가져오면 되는데...

여기에 Order가 추가됐다. 그럼 결국 Order도 Team과 관련되어 있으면 모두 출력해야 한다.


하지만 이 데이터들이 모두 하나의 row에 표현되어야 하는데, 실질적으로 불가능하다.

Team1에 대해 Member1,2,3이 있고 Order도 1,2,3이 있으면, 

Team1 Member1 Order1, Team1, Member2 Order2 이런 식으로 필요한 만큼만 딱딱 row에 들어맞춰질까..?

그리고 Member가 Order보다 더 많으면 Team1 Member4 null 이렇게 딱딱 맞춰서 필요한 Entity에 대한 개수만큼 조회가 가능할까?

절대 그렇게 안 된다. 그런 기능은 존재하지 않는다.

결국 application 입장에서 보면 각각의 연관된 모든 Entity 컬렉션을 조회하기 위해서는 

관련된 모든 경우의 수를 받은 다음 중복되는 것을 지우는 방법밖에는 할 수 있는 게 없다.

하지만 이건 너무 비효율적이다.

그래서 애초에 막아둔 듯하다. 


그럼 하나의 Entity에 컬렉션은 복수개를 못 넣는 건가요..?

그렇지는 않다. 

내가 개인적으로 보기에는 Fetch Join을 여러번 하면 될 것 같다.

한 번에 Fetch Join하는 게 기능상 문제라서 막아 놓은 것이라면, 여러 번 하면 그만이다.

한 번에 불러와서 row가 너무 많아지는 것 보다는 하나씩 여러 번 Fetch Join을 수행해서

컬렉션을 채워 넣는 게 더 성능상 좋지 않을까 싶다. 그래서 이 부분은 안 막은 것 같다.


"SELECT t FROM Team t JOIN FETCH t.members", "SELECT t FROM Team t JOIN FETCH t.orders" 

위처럼 각각 Team에 대한 Fetch Join을 하면, Team과 관련된 단일 컬렉션에 대해서만 조회하기 때문에

조회 회수는 조금 많아질 수 있겠지만 불필요한 row가 함께 조회되는 일은 발생하지 않을 것이다.

이렇게 각 컬렉션을 개별로 Fetch Join으로 채워 넣은 다음 Team Entity를 사용하는 형태로도 가능한 것 같다.

이게 문제가 있는 방식인 지는 모르겠지만 이론상 시험해 봤을 때 가능했다.


컬렉션을 한 번에 두 개 이상 Fetch Join으로 조회 못 한다는 것이지, 

일반 ToMany방식의 Entity들은 몇 개를 하든 상관 없다.

단일 Entity 여러개 + 컬렉션 1개 까지 가능하다. 








5. 컬렉션 FETCH JOIN에서는 페이징 API를 사용할 수 없다.

Fetch Join의 대상이 @OneToMany와 @ManyToMany관계인 경우에는 페이징 사용이 불가능하다.

이유는 간단하다. Fetch Join의 두 번째 문제점처럼 데이터의 정합성과 일관성에 문제가 발생할 수 있기 때문이다.


예를 들어 Team을 조회하는데 Member와 관련된 Team을 

"SELECT t FROM Team t JOIN FETCH t.members"

위처럼 Fetch Join하고 거기에 setFirstResult(0)와 setMaxResult(2)설정했다

그럼, 페이징이 없을 때에는 Member가 10명이 조회되는 Team이 10개가 나와야 하는데, 두 개로 잘려서 2개만 조회되었다고 해 보자.

이 때, 일반 조인이 아니고 FETCH JOIN이기 때문에 Team이 조회되는 시점에 Member 컬렉션도 함께 조회되고 초기화 되어야 한다.

근데 지금 페이징때문에 조회되는 Member가 줄었다.

그러면 컬렉션에는 원래 10명이 초기화되어야 하는데, 줄어든 두 명만 초기화되는 상황이 발생하는 것이다.

이것은 데이터 정합성과 일관성에 문제를 야기하기 때문에, 문제점 2번과 같은 현상이 발생할 수 있다.


그 뿐만 아니라, 우리는 Team을 기준으로 페이징을 하려고 한 것인데, 위의 경우 0~2까지 페이징을 했으면

의도대로라면 그냥 3개의 Team을 조회하려는 것이었는데, 위는 하나의 팀만이 조회된다.

왜냐하면 위에서 총 검색되는 row는 Team 10개에 대한 row가 아니고, Team 한 개당 Member 10개와 합쳐져 row가 10개가 생기기 때문에

한 Team당 10개의 row로 총 100개의 row가 조회될 것이다.

이 상태에서 페이징 처리를 하면 페이징 기준이 row가 되기 때문에 100개 중 3개를 자르게 되니, 하나의 Team에 대한 3개 row가 검색될 것이다.



이걸 방지하려면 두 가지 방법이 있다.

첫 번째는 ToMany방식의 컬렉션 데이터는 Fetch Join을 사용하지 않고 그대로 지연 로딩으로 두고

일단 필요한 데이터들에 대해서 페이징 처리를 하고 가져온 뒤에 컬렉션에 대해서는

따로 SELECT문을 날려서 값을 조회하는 형태로 뒤 초기화를 해 주는 방식이다.

이 때 페이징 처리로 가져온 Entity들의 id값을 모두 가져온 다음 컬렉션을 조회할 때 IN 문법을 이용해 한 번에 조회하면 좋다.

로직이 조금 복잡해지겠지만 성능은 좋을 것이다.


두 번째 방식은 Fetch Join을 수행하고 결과를 그대로 모두 가져와 페이징은 application 단에서 처리하는 것이다.


일반 JPA 스펙에서는 컬렉션을 Fetch Join하려고 하면 위의 방식 중 어느쪽도 지원하지 않는다.

하지만 Hibernate의 경우는 두 번째 방법으로 '일대다'와 '다대다' Fetch Join의 페이징을 처리하고 있다.

그렇기 때문에 성능상 아주 문제가 크다.

일단 모든 Entity와 컬렉션 필드를 완전히 다 가져와서 초기화한 다음에

거기서 잘라내는 형태로 페이징 처리를 하기 때문에 진짜 잘못하면 개심각하게 느려질 수가 있다.

심지어는 결과적으로 조회되는 결과가 달라지지 않기 때문에 우리가 따로 처리를 해야 한다.


일반 조인의 경우야 조회된 결과는 그냥 결과일 뿐이고 컬렉션 필드는 즉시, 지연 로딩 옵션에 따라 

필요한 때에 따로 쿼리를 보내서 다시 초기화하기 때문에 문제될 것이 없다.

일반 조인의 경우 페이징 처리할 때 Entity의 컬렉션 필드를 프록시로 초기화해 놓기 때문이다.

하지만 Fetch Join의 경우는 바로 값을 초기화 해야 하고, DB와의 정합성을 맞추기 위해서는 

조회되는 데이터와는 무관하게 일단 Entity의 필드에 DB와 똑같은 값들이 세팅되도록 보장해야 한다.

그래서 모든 데이터를 일단 메모리로 불러와서 세팅을 해 놓고, 페이징 처리를 할 수밖에 없는 것이다.


근데 개인적으로 두 번째 방식 보다 첫 번째 방식으로 해결하면 좀 낫지 않을까 싶다.

페이징 처리 후에 Entity의 id를 확인해서 초기화가 필요한 Entity의 컬렉션 필드에 대해서 따로 쿼리 날려서 초기화하면 될 것 같은데

저걸 굳이 다 불러온 다음에 application에서 페이징 처리를 할 필요가 있나 싶다.




그리고 나의 생각이 맞다는 걸 증명하듯, 컬렉션 페이징에서는 실제 이 IN문법을 이용한 방법으로 페이징을 해결하고 있다.

그냥 컬렉션은 지연 로딩을 사용해서 필요할 때에만 조회하는 형태로 하면 되지않나..?

조회할 Entity가 적다면 그 방법도 나쁘지는 않다.

하지만 조회되는 Entity가 적으면 메모리에 모든 데이터를 끌어놓고 사용하는 것도 성능상 나쁘지 않다.

오히려 이런 경우에는 메모리에 끌어 놓고 쓰는 게 더 빠를 확률이 높다.

괜히 하나씩 조회하고 초기화 하는 게 네트워크 연결 때문에 더 성능이 안 좋을 수 있기 때문이다.

그러니 N + 1을 이용한 지연 로딩방식은 방법은 해결법이라고 볼 수 없다.


하지만 이걸 해결할 수 있는 방법이 있다면 위에서 말한 IN을 이용해서 N + 1을 해결하는 것이다.

조회된 Entity들의 Id값을 이용해서 IN에 모두 넣고 각 Entity에서 필요로하는 컬렉션 데이터를 한 번에 조회하는 것이다.

근데..그럼 직접 IN에 들어갈 Entity의 id값을 뽑아서 JPQL을 하나하나 작성해야 하는 것일까?

Entity를 바로 조회하는 것이 아니고, 생성자 JPQL등을 이용해 Dto로 바로 뽑는 경우처럼 값타입으로 조회하는 경우라면

직접 JPQL에 IN을 넣고 id값들을 뽑아서 작성하는 형태로 가져가야 한다.

하지만 Entity를 조회할 때에는 정말 고맙게도 IN을 이용한 방식을 편리하게 해결해 줄 수 있는 어노테이션이 있다.

바로 @BatchSize이다.



@BatchSize(size = 값) 형태로 사용되며 특정 Entity의 필드를 초기화할 때

영속성 컨텍스트에 있는 같은 Entity들의 연관관계 필드들도 '값'만큼 한 번에 초기화 시켜 주는 기능이다.

말로 하면 조금 와닿지 않는데, 예를 들어 보겠다.

"SELECT t FROM Team t" 의 getResultList()결과로 List에 10개의 Team이 조회되었다고 해 보자.

Team 10개에 대해서 Member 컬렉션 필드를 초기화 하기 위해 각각 한 번씩 쿼리가 나가므로 10번의 SELECT 쿼리가 추가적으로 나갔을 것이다.

하지만 @BatchSize(size = 100)을 설정해 두었다면 하나의 SELECT 쿼리가 나갈 때 DB의 'IN'기능을 사용해서

"SELECT * FROM member WHERE team_id IN( ?, ?, ?, ?, ? ....) 형태로 영속성 컨텍스트에서 team_id 컬럼을 100개 추출해

한 번에 각각의 Team Entity에 필요한 컬렉션 Member Entity들을 조회하고 초기화해 주는 기능이다.

쉽게 생각하면 N + 1을 N/value + 1로 줄여 주는 미친 기능을 한다고 볼 수 있다.


페이징을 먼저하고 컬렉션을 초기화 하는 방식의 단점이었던 N + 1문제를 크게 해결할 수 있다.

물론 이런 BatchSize의 최대 크기가 1000까지이기 때문에 페이징으로 불러올 Entity의 수가 진짜 말도 안 되게 많으면

결국은 몇 번 끊어서 가게 될 것이다. 그래도 N + 1을 최대 N/1000 + 1로 줄인다는 것 자체가 엄청난 메리트이다.


사실 @BatchSize라는 것은 이걸 위해 만든 기능이라기 보다는 여기에 @BatchSize를 응용한 것이라는 게 더 맞다.

Hibernate에서는 지연 로딩을 최적화하는 방법이라고 명시하고 있다.

@BatchSize의 기능은 보면 알겠지만 그냥 특정 Entity에서 필드 초기화가 필요해서 쿼리를 날리는 시점에

영속성 컨텍스트에서 같은 Entity의 id들을 추출해 'IN'으로 묶어서 한 번에 조회하고 같이 초기화하는 기능일 뿐이다.

이는 컬렉션 뿐만 아니라 그냥 ToOne관계와 같은 단일 Entity에도 적용이 가능하다.

단일 Entity 필드를 @BatchSize로 조회하면, 단일 Entity를 조회할 때 IN으로 캐시에 있는 id를 이용해

초기화할 필드 Entity들을 한 번에 같이 조회하는 것이다.



그래서 이러한 @BatchSize의 단점도 존재한다.

바로 원하지 않는 Entity들의 필드까지 같이 초기화될 수 있다는 것이다.

기본적으로 @BatchSize는 정해진 값만큼 영속성 컨텍스트에 있는 Entity를 무조건 초기화한다.

예를 들어 영속성 컨텍스트에 Team은 50개의 데이터가 있다고 해 보자.

Members에 대해서 @BatchSize를 10으로 잡아 두었다.

이 때 나는 페이징으로 5개의 Team을 조회했다고 해 보자.

그리고 조회된 Team에 대해서 Members가 필요해서 데이터를 조회했다.

근데, 이 때 @BatchSize에 의해 10개만큼의 id가 IN에 들어가야 한다.

@BatchSize는 조회된 5개의 Team뿐만 아니라, 영속성 컨텍스트에 있는 Team 5개를 더 뽑아서 id를 가져온 뒤 함께 IN에 넣어서 초기화 했다.

우리는 조회된 Team 5개에 대해서만 Members가 있으면 되는데 쓸데없이 안 쓰는 Team 5개에 대해서 더 초기화가 일어난 것이다.

이게 @BatchSize의 단점이다.


그래도 다행인 점은 BatchSize가 알아서 최적화가 되어 있어서 그런 지

JPQL로 조회한 Entity 컬렉션에 있는 Entity들 중에서 한 Entity의 필드를 초기화하면

같은 Entity 컬렉션에 있는 Entity들이 우선순위를 갖고 IN의 대상이 되는 것 같았다.

그래서 위의 경우 페이징으로 조회한 Team 5개는 일단 확정적으로 함께 초기화가 되는 것이고

나머지 5개는 어떤 원리로 우선순위를 갖는 지는 모르겠지만 하여튼 5개가 초기화가 된다.


@BatchSize에 대해 이정도 알고 사용하면 크게 문제는 없을 것이다.

컬렉션 필드를 조회할 때 성능최적화를 위해 적절하게 사용하도록 하자.





이제는 @BatchSize의 사용방법에 대해 알아 보자.

조회될 때 이러한 단체 조회를 적용하고 싶은 컬럼 위에다가 @BatchSize를 붙여 주고 size값만 주면 된다.

그리고 이는 글로벌 설정이 가능한데, 그건 따로 알아 보자.

글로벌 설정을 하면 @BatchSize가 붙지 않았어도 모든 연관관계에 적용되기는 하지만 보통 이렇게 쓴다고 한다.

그럼 진짜 하나만 조회하려고 한 건데 쓸데 없이 여러개가 조회되는 경우도 있지 않나요?

그럴 때에는 글로벌 설정은 그대로 두고 @BatchSize를 직접 사용해서 그 설정이 먹히도록 만들면 될 듯 하다.



이 외에도 '일대다' 관계를 '다대일'관계로 반대 매핑해서 페이징을 처리하거나

"SELECT t FROM Team t JOIN FETCH t.members"가 아니라 "SELECT m FROM Member m JOIN FETCH m.team"의 형태로 페이징,

또는 DTO를 이용한 방법도 있는데, 쉽지는 않다고 한다.

하여튼 '일대다', '다대다' Fetch Join에서는 페이징 처리를 할 때에는 @BatchSize를 사용하는 방식을 고려하자.






6. 모든 것을 Fetch Join으로 해결하려 하지 말자.

모든 것을 페치 조인으로 해결할 수는 없다.

페치 조인은 객체 그래프를 유지할 때 사용하면 효과적인 기능이다.

만약 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하는 경우라면

페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 좋다.

