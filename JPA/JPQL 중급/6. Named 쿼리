






JPQL에는 @NamedQuery라는 것을 제공한다.

이 네임드 쿼리는 그냥 JPQL쿼리를 미리 작성해 놓고 이름을 부여한 다음 가져다 쓸 수 있는 개념이다.

설명 보다는 사용법을 직접 보면 이해가 갈 것이다.

Entity 위에 어노테이션을 붙여서 사용 가능하다.


@NamedQuery(
    name = "Member.findByName"
    query = "SELECT m FROM Member m WHERE m.name = :name"
)

이런 식으로 Entity 클래스 위에 쿼리와 이름을 작성한 다음에

EntityManager의 createNamedQuery()메소드를 이용해 네임드 쿼리의 이름을 넘기면 작성해 놓은 쿼리가 실행된다.



음 좋긴 한데, 그렇게 유용해 보이지는 않는데..?

이런 생각이 들 수 있는데, 사실 이 네임드 쿼리의 진짜 장점은 따로 있다.

바로 쿼리 문제를 애플리케이션 로딩 시점에 알 수 있다는 것이다.

이 네임드 쿼리는 쿼리를 작성해 놓으면 애플리케이션 로딩 시점에 파싱을 해서 SQL로 미리 번역을 해 놓는다.

그래서 쿼리 자체에 문제가 있을 경우 파싱 시점에 잡아낼 수가 있다.

Runtime시점에 로직 수행을 해 봐야 문제를 잡을 수 있는 것 보다 훨씬 효율적이다.


그래서 이런 네임드 쿼리는 정적 쿼리를 사용할 때에 유용하게 써먹을 수 있다.

로직에 따라 달라져야하는 동적 쿼리에는 사용할 수 없지만 정적쿼리에는 유용하게 쓸 수 있다.

그리고 이런 원리는 Spring Data JPA에서도 사용되는데,

Spring Data JPA에는 @Query라는 어노테이션이 있다.

이 어노테이션에 작성된 쿼리는 네임드 쿼리에 등록이 되어 사용되기 때문에, 애플리케이션 로딩 시점에 문법 오류가 잡힌다.


하지만 김영한님께서는 하는 얘기를 들어보니 이 @NamedQuery를 직접 사용하는 경우는 많이 없는 것 같다.

Entity위에 작성하기 때문에 너무 지저분해 보이기 때문이다.

사실 이 네임드 쿼리는 xml파일로도 작성이 가능한데, 

xml파일을 하나 만들고 거기에 작성하고 persistence.xml파일에 추가해 주면 된다.

자세한 건 필요해지면 찾아 보자.

어차피 실무에 가면 Spring Data JPA와 JPA를 함께 사용하기 때문에 거의 직접 쓸 일은 없는 듯 하다.

이런 정적 쿼리는 Spring Data JPA로 거의 해결하다 보니 그런 것 같다.

그래도 일단 Spring Data JPA의 @Query가 이런 @NamedQuery의 동작체계를 따라간다는 것을 알아 두자.
