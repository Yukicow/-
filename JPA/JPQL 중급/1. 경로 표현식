





JPQL에서는 Entity의 alias에 '.'을 찍는 형태로 필드에 접근한다.

그리고 이것을 경로 표현식이라고 한다.

이 때 데이터의 종류에 따라 경로 표현식의 특징이 달라진다.

크게 두 가지로 나뉘는데, 상태 필드와 연관 필드이다.


1. 상태 필드 

상태 필드는 단순히 값을 저장하고 있는 필드를 말한다.

상태 필드는 그 필드에서 값으로 끝나는 필드이기 때문에, 경로 탐색의 끝이고 더 이상 탐색이 불가능하다.

쉽게 말해서 m.name으로 조회를 했다고 할 때 name을 단순 String 값이기 때문에 여기서 더 뭘 할 수가 없다.

그냥 단순히 Member의 name을 조회하고 끝나는 형태이다.



2. 연관 필드

연관 필드는 연관관계가 매핑되어 있는 필드를 말한다.

단일 값 연관 필드와 컬렉션 값 연관 필드로 나뉜다.

단일 값 연관 필드는 @ManyToOne, @OneToOne처럼 하나의 Entity를 참조하는 형태라 조회하는 Entity가 하나일 경우이고,

컬렉션 값 연관 필드는 @ManyToMany, @OneToMany 처럼 Entity가 컬렉션으로 Entity들을 참조하는 필드를 말한다.

Entity간에 연관관계로 매핑되어 있기 때문에 필드에 접근한 뒤에 더 탐색이 가능한 형태이다.

하지만 이 중에서도 단일 값 연관 경로와 컬렉션 값 연관 경로에 따라 달라진다.


단일 값 연관 경로의 경오는 바로 탐색이 더 가능하다.

예를 들어 "SELECT m.team FROM Member m"이렇게 JPQL을 작성했다면 

m.team에서 team에 대한 상태 필드나 연관 필드에 "SELECT m.team.name FROM Member m" 이런 식으로 바로 접근이 가능하다.

하지만 컬렉션 값 연관 필드는, "SELECT t.members FROM Team t" 이렇게 사용되는데, 이게 상태필드나 연관필드에 접근하려면

기본적으로 경로 표현식의 대상이 하나의 Entity이어야 한다. 

하지만 t.members를 보면 Entity가 아니라 Entity를 담고 있는 컬렉션이다.

그러면 사실상 members내부의 member의 특정 상태 필드나 연관 필드에 접근할 수가 없다.

그래도 컬렉션의 size에 대해서는 "SELECT t.members.size FROM Team t"이런식으로 접근이 가능하기는 하다.


그렇다면 컬렉션 값 연관 필드에서 바로 경로 표현식을 사용하고 싶을 때에는 어떻게 해야 할까.

먼저, 연관 필드는 기본적으로 묵시적 내부 조인이 발생한다는 것을 알아야 한다.

전에도 배웠지만 우리가 따로 join을 명시하지 않고, 연관 필드간의 매핑 구현 방식에 따라 알아서 join이 발생한다.

뭐 @JoinColumn을 이용했다면, fk를 통한 join이 발생하고, 또는 하나의 테이블을 사이에 두고 join이 일어나기도 한다.

하여튼 우리가 직접 join을 명시하지 않아도 "SELECT t.members FROM Team t"이렇게만 작성하면 join이 자동으로 일어나니

이것을 묵시적 조인이라고 표현한다.

t.members라는 필드를 보고 연관관계를 유추해 암묵적으로 Join을 해 준것이다.

하지만 결국 t.members는 Member테이블을 나타내는 Entity가 아니고 Entity들을 담기 위한 컬렉션이다.

그 컬렉션을 보고 연관관계를 유추한 것 뿐이다.


컬렉션 연관 필드에서는 이렇게 묵시적 조인이 발생했기 때문에 우리가 특정 Entity에 대한 접근 alias를 얻지 못한 상태이다.

하지만 이걸 명시적 조인으로 사용하면 Entity에 바로 접근이 가능해지기 때문에 컬렉션 값 연관 필드에서 바로 접근하는 형태처럼 사용 가능하다.

예를 들어 "SELECT m.name FROM Team t join t.members m" 이렇게 명시적으로 조인을 사용하면

여기서의 t.members는 컬렉션 값 연관 필드가 아니고 사실 Member Entity이다.

왜냐하면 위치상으로 t.members가 join뒤에 오기 때문에 여기서는 t.members를 컬렉션으로서 보는 게 아니고

Team과 관련 있는 Member를 나타내기 위해 저렇게 사용하는 것이다.

내부적으로는 사실상 

SELECT m.name FROM Team t join Member m on t.id = m.team_id"의 형태라고 볼 수 있고 

t.members는 "Member m on t.id = m.team_id" 이 부분을 암묵적으로 표현하고 있다고 볼 수 있다.

# 실제 JPQL이 해석되면 저런 형태의 SQL로 바뀐다.

그러니 여기서의 m은 컬렉션이 아닌 Member Entity를 가리킨다.

그래서 m은 단일 값 연관 필드처럼 바로 다른 상태 필드나 연관 필드에 접근이 가능하다.

그럼 "SELECT m.name FROM Team t join t.members m"의 m.name처럼 Team과 연관된 Member에 대한 특정 필드에 접근이 가능하다.

컬렉션 값 연관 필드일 때에는 alias가 컬렉션을 나타내기 때문에 다른 경로 표현식의 사용이 불가했지만

이렇게 명시적으로 join을 사용하면 Member를 나타내는 alias가 생기기 때문에 필드에 접근이 더 수월하다.



이런 장점도 있고 묵시적 조인 자체에 JPQL을 보고 어떤 쿼리가 나갈 지 예상이 잘 안 된다는 단점과, 

쿼리 튜닝이 어렵다는 단점 등이 있어서 묵시적 조인은 사실 사용하지 않는 게 맞다고 한다.

JOIN은 쿼리 튜닝이 매우 중요한 문법이기 때문에 매우 중요하기도 하다.

그래서 join은 무조건 명시적으로 사용해야 한다.

그리고 사실상 OUTER JOIN은 저렇게 묵시적 조인이라는 개념이 없어서 무조건 명시하는 형태로 사용해야 하는데,

INNER JOIN은 묵시적 조인을 사용하고 OUTER JOIN은 명시적 조인을 사용하는 건 좀 이상하다.

단점만 있는 묵시적 조인을 사용할 바에는 명시적 조인으로 사용하는 게 훨씬 좋다.

그러니 그냥 묵시적 조인은 사용하지 말고 명시적 조인만 사용하면 된다.




