






벌크 연산이란 대량(2개 이상)의 데이터를 한 번에 UPDATE하거나 DELETE하는 것을 말한다.

JPA에서 벌크 연산을 어떻게 해야 할까?

만약에 모든 상품의 가격을 10% 인상하고 싶다고 해 보자.

모든 상품을 Entity로 불러와서 foreach문을 돌려가면서 10% 인상 연산을 수행하는 형태로

JPA의 변경 감지를 이용해서 UPDATE를 한다면, UPDATE쿼리가 Entity개수만큼 수행되기 때문에 너무 비효율적이다.


이런 문제를 해결하기 위해서는 하나의 쿼리에 모든 row가 UPDATE되도록 해야 하는데, 그럼 결국 NATIVE쿼리를 사용해야 한다.

하지만 우리에게는 JPQL이 있다.

이 JPQL을 이용해서도 UPDATE나 DELETE가 가능하다.

EntityManager의 executeQuery()메소드를 수행하면 된다.

Hibernate에서는 INSERT도 지원하는 듯 하다.


근데 문제는 이런 JPQL을 통한 UPDATE, DELETE 쿼리를 수행할 때 조심할 점이 있다.

예전에 JPQL을 처음 배울 때 얘기한 것 같은데, JPQL은 이전의 변경 상태를 DB에 반영하기 위해 flush작업을 한 번 한다고 했다.

그리고 flush는 캐시를 비우는 작업이 아니기 때문에 영속성 컨텍스트의 상태는 JPQL이 수행돼도 그대로 유지된다고 했다.

그럼 여기서 JPQL을 통해 UPDATE나 DELETE를 수행하면 어떻게 될까?

DB에는 JPQL이 수행되어 변경된 값이나 삭제된 값이 반영되겠지만, 영속성 컨텍스트에는 그렇지 않게 된다.

즉, DB와 객체 그래프의 일관성이 깨지게 되는 것이다.


이런 문제를 해결하기 위해서 JPQL을 통해 벌크 연산을 수행하고 나서는, 

아니, 벌크 연산 뿐만 아니라 JPQL을 통한 UPDATE, DELETE 수행 후에는 반드시 캐시를 한 번 비워야 한다.

뭐 사실 JPQL을 통해서는 단일 UPDATE DELETE는 진짜 거의 하지 않기 때문에 거의 벌크 연산에 대한 이야기라고 보면 되긴 한다.

하여튼, 이런 DB와 객체 그래프의 일관성을 유지하기 위해서 꼭 캐시를 비우고 다시 조회하는 작업을 거치도록 하자.

아니면 벌크연산을 로직의 가장 1순위로 수행시키고 그 뒤에 로직이 온다면 그것도 괜찮은 방법이다.

때에 따라서 적절한 방법을 선택하자.

