






문제점을 알아 보기 전에 알아 두어야 할 연관관계들에 대해 알아 보자.



1. @ManyToOne

다수가 하나를 참조하도록 하는 단방향 연관관계이다. 

N : 1 또는 '다대일'이라고도 한다.

예를 들어 Team과 Member가 있을 때 Member들은 하나의 Team에만 소속될 수 있다고 한다면

이런 경우 Member는 Team에 대해 ManyToOne에 해당한다.

자신이 많은 쪽(N)이고, Team이 딱 하나만 참조 가능한 쪽(1)이기 때문이다.


이 단방향 연관관계의 경우 Many쪽에서 One을 참조하기 위해 구현한 방식이다.

테이블에 One의 pk를 갖는 컬럼을 하나 추가하고 그 컬럼을 통해 One을 참조하는 형식이다.

RDB의 fk와 같다고 볼 수 있다.

하지만 실질적으로 한 쪽에서만 참조하도록 의도한 것이기 때문에 단방향 연관관계를 구현했다고 할 수 있다.




2. @OneToMany

하나가 다수를 참조하도록 하는 단방향 연관관계이다.

1 : N 또는 '일대다'라고도 한다.


Team과 Member관계에서 Team이 @OneToMany에 해당한다고 볼 수 있다.

Team에 속하는 Member들을 알아야 하기 때문에 자신의 팀 소속의 Member들의 pk를 모두 알아야 한다.


'1'쪽이 N개의 참조값을 가져야 하기 때문에 하나의 컬럼으로는 구현이 불가능하고 테이블이 필요하다.

자신의 pk값과 자신이 참조하고자 하는 쪽의 pk값을 갖는 테이블을 생성하고 그 row값을 통해서 N을 조회한다.

그리고 이 때 '다' 쪽은 여럿이서 '1'을 참조해도 되지만 '1'쪽은 여러 '1'이 같은 '다'를 참조할 수가 없다.

이런 경우는 '일대다'가 아니고 '다대다' 관계이기 때문이다.

그래서 @OneToMany에서 이런 일이 발생하는 것을 막기 위해 새로 생성하는 테이블의 '다'의 pk컬럼에 Unique제약조건을 건다.


사실 이런 기본 방식의 @OneToMany 방식은 그렇게 좋지는 않다고 한다.

아무래도 테이블을 하나 더 생성하게 되고, 성능상의 문제도 있고 운영에도 썩 좋지 않다고 한다.

그래서 @OneToMany를 사용할 때에는 @JoinColumn을 통해 fk를 지정하는 게 좋다.

@JoinColumn으로 fk를 지정하면 fk를 통해서 '다'쪽을 조회하는 게 가능해져서 굳이 테이블을 만들 필요가 없어지기 때문이다.

실제로도 거의 이렇게 사용한다고 한다. 


더 나아가서는 이 @OneToMany 조차도 사실 '1'쪽의 변화가 '다'의 fk에 영향을 주기 때문에 

'1'을 바꾸면 '다'가 바뀌는 구조의 꼬임이 발생해서 사용에 불편한 문제점이 있다.

그래서 김영한님께서는 이런 전략을 사용한다고 한다.

단방향 연관관계는 일단 '다대일'로 가져가고 여기서 반대의 경우가 생기면 양방향으로 걸어버리는 전략이다.

이럴 경우에는 단점이 객체 입장에서 조금 손해를 볼 수는 있다. 의도는 '일대다'를 사용하는 것인데 양방향을 걸기 때문에

사실상 불필요한 데이터를 조회해서 가지고 있어야 하는 상황이 발생하기 때문이다.

이런 트레이드 오프가 발생하기는 하지만 DB와 비슷하게 설계 방향을 맞춤으로서 유지보수에 용이성을 높이는 것이다.

어차피 뒤에 가서 지연로딩을 사용하게 되면, 이런 손해는 줄어들게 된다.


그리고 @OneToMany(@ManyToMany도 해당)를 사용해서 List를 필드에 둘 때에는 미리 초기화를 해 놓는 걸 권장한다고 한다.

메모리적으로는 아주 약간 손해를 볼 수는 있는데 권장한다고 한다.

여러가지 이유가 있는데, 중요한 두 가지 정도만 알아 보면

null문제에서 안전하다는 장점과 Hibernate가 Entity를 영속화할 때 

컬렉션이 있으면 그걸 감싸서 hibernate 내장 컬렉션으로 변경하기 때문이다.

변경 감지등이나 추적을 위해서 이런 작업을 수행하는 것인데, 처음 초기화한 컬렉션을 사용하다가 중간에 다른 컬렉션을 초기화 해 버리면

hibernate에서 원하는 동작이 이뤄지지 않을 수 있게 된다.


그건 미리 초기화 하는 거랑 관련이 없어 보이는데요..그냥 안 바꾸면 되는 거 아닌가?

그렇다. 안 바꾸면 되는 것이다. 근데, 이걸 처음에 초기화 안 하면 나중에 초기화 하는 방법이 뭐가 있을까?

생성자와 setter밖에 없다. 생성자는 사실상 미리 초기화해 놓는 거랑 같다.

setter는 값이 변경될 위험성이 있으니 조심해야 한다.

결국은 생성자 방식이랑 다를 게 없는 바로 초기화 방식을 사용하는 것이다.

NPE(Null Point Exception)도 막고 어차피 생성자로 생성할 때 초기화하는 것과 동작도 같고. 안 할 이유가 없다.

그리고 위에서 말한 것처럼 컬렉션은 중간에 다른 컬렉션으로 절대 바꾸면 안 된다.

정말 뭔가 다른 컬렉션을 이용해야 하는 경우라면, 컬렉션 메소드들을 이용해서

원래의 컬렉션을 다른 컬렉션의 값에 맞추도록 하는 방식으로 동작시켜야 할 듯 하다.







ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 연관관계의 문제점 내용을 공부한 후에 볼 내용 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


근데, 양방향 연관관계(양쪽의 단방향 연관관계)에서 @ManyToOne에는 mappedBy를 사용해서 '다'쪽이 주인이 될 수 있었는데, 

그 반대로 @OneToMany에서는 mappedBy가 없던데 주인이 되게 할 수는 없나요?

스펙상으로는 이게 지원되지 않는다.

너무나도 당연하지만, 제대로 공부를 했다면, 당연히 RDB에서 fk를 가진 쪽만이 fk를 변경할 수 있다.

그러니 스펙상으로 fk의 기능과 똑같은 양방향 연관관계를 구현하는 mappedBy가 @OneToMany쪽에 있을 리가 없다.

하지만 기술적으로는 이게 유사 @OneToMany mappedBy를 구현할 수는 있다.

바로 옵션을 이용하는 것이다.


그냥 양쪽에 mappedBy를 사용하지 않고 @ManyToMany과 @OneToMany로 단방향 연관관계 두 개를 만들면, 

# @JoinColumn을 사용했다는 가정

이것은 fk를 통한 양방향 연관관계가 아니고 단방향 연관관계 두 개를 사용하는 것이기 때문에

양쪽의 단방향 연관관계의 참조값의 변화가 모두 fk에 영향을 주게 된다.

근데, 이 때 @JoinColumn의 옵션 중에 insertable과 updateable이라는 게 있는데

이 옵션을 false로 지정하면 해당 필드의 변화가 fk를 insert하거나 update할 수 없게 한다.

그렇기 때문에 사실상 이렇게 되면 fk의 관리는 @OneToMany쪽에서만 가능하게 되기 때문에

'1'쪽의 변화만이 '다'의 fk에 영향을 주게 되어 @OneToMany에 mappedBy를 사용한 것과 같은 효과를 낸다.

쉽게 생각하면 그냥 양쪽 다 fk를 변경 가능한 상태를 만들고 그 중에 한 쪽을 옵션으로 변경을 못 하게 막는 것이다. 





3. @ManyToMany

다수가 다수를 참조하도록 하는 단방향 연관관계이다.

N : N 또는 '다대다'라고도 한다.


이 단방향 연관관계의 경우 양쪽이 서로 다수를 참조하기 위해 구현한 방식이다.

@OneToMany와 구현 방식은 똑같지만 @OneToMany의 경우 특정 '1'쪽이 이미 다른 'N'을 참조하고 있는 경우

다른 '1'들은 더 이상 그 'N'을 참조할 수 없는 형태인 반면에 

@ManyToMany는 'N'이 아무 'N'을 참조할 수 있다.


이 케이스는 @OneToMany에서 '1'이 '다'가 되어버린 케이스이기 때문에 기본적으로 중간 테이블이 필요한 형태이다.

양쪽이 둘 다 여러개의 '다' pk를 가질 수 있다면 하나의 컬럼을 가지고는 구현이 불가능하기 때문이다.


FoodShop과 Food가 있다고 해 보자.

FoodShop은 Food를 생성하고, Food는 어느 한 FoodShop에 종속되는 것이 아니고 

어느 FoodShop이든 같은 요리인 Food를 만들어낼 수 있다.

이럴 경우에는 FoodShop은 여러 Food를 참조할 수 있고, Food도 여러 FoodShop에서 동시에 참조될 수 있다.

그래서 이런 참조관계를 나타내는 테이블에서 서로 다른 'N'에 대해 같은 'N'을 참조하는 Row들이 다수 존재할 수 있다.



이런 @ManyToMany는 실무에서는 그닥 좋지 않다고 한다. 아예 사용을 안 하는 게 좋다고 한다.

@ManyToMany의 특성상 양쪽의 pk를 fk로서 갖는 테이블을 생성하는데 

실무에서는 이렇게 둘의 관계만을 나타내는 테이블이 존재하는 게 쉽지 않다고 한다.

약간 이런 건 이상적인 느낌이 세고, 실질적으로는 그 외에 다른 부가적인 컬럼들이 추가되는 경우가 필요하기 때문이다.

@ManyToMany에 의해 생성되는 테이블에는 그런 기능이 없기 때문에 결국은 새로운 테이블을 추가해야 하는데,

이럴 거면 처음부터 둘을 합친 테이블을 만들어서 Entity로서 관리하는 게 더 좋다는 것이다.

그리고 이런 테이블을 만들어서 Entity를 관리하게 되면, @ManyToMany는 쓰지 않아도 된다.

중간 테이블에서 원래 @ManyToMany 객체와의 @ManyToOne과 @OneToMany 관계 필드를 만들어서 사용하는 것이다.


이 원리는 오로지 DB테이블을 이용해서 서로의 ManyToMany 관계를 만들던 것을 

ORM기술력을 이용해서 객체적으로 ManyToMany관계를 만든 것이기 때문에 동작 자체는 거의 다르지 않지만

객체적으로 더 유용하게 사용이 가능하다.


예를 들어 Food와 FoodShop 중간에 FoodFactory라는 Entity를 하나 더 만들고 필드로 Food와 FoodShop을 삽입

그리고 그 필드를 @ManyToOne으로 설정하고 fk를 @JoinColumn으로 지정, Food와 FoodShop의 '다'에 해당하는 필드를 @OneToMany로 설정하면

DB의 FoodFactory에는 Food와 FoodShop에 대한 fk를 갖고 있는 형태로 동작하기 때문에 

Food와 FoodShop의 fk가 각각 하나의 row에 존재하니 Food를 통해 FoodShop들을 조회하고 싶으면 

그 Food의 pk를 fk로 갖는 FoodFactory를 모두 조회하면 된다.

그럼 그 FoodFactory 안에는 FoodShop Entity가 있기 때문에 원하는 Food와 관련 있는 모든 FoodShop을 조회 가능하다.







4. @OneToOne

하나가 하나를 참조하도록 하는 단방향 연관관계이다.

1 : 1 또는 '일대일'이라고도 한다.


한 쪽에서 하나만 참조하기 때문에 1 : 1로 매칭되는 형태의 단방향 형태이다.


연인사이를 예로 들 수 있다.

남자친구는 여자친구 한 명만을 참조할 수 있다.

같은 '남자'타입의 객체에서 서로 다른 남자가 같은 '여자'를 참조할 경우 문제가 발생할 것이다.

그래서 이런 경우 @OneToMany때 처럼 Unique제약 조건을 추가해서 겹치는 일을 없게 한다.


@OneToOne에서 주의할 점은 두가지가 있다. 

첫 번째는 fk가 없는 쪽에서 단방향을 걸 수가 없다는 것이다.

'일대다'에서는 '일'이 '다'를 변경해도 '다'쪽의 fk가 변경되었지만 @OneToOne에서는 그게 안 된다.

무조건 fk가 있는 쪽만이 단방향을 걸고 그 쪽만이 fk값을 변경시킬 수 있다.

근데 양방향에서는 이게 가능하다.

양쪽에 @OneToOne을 걸고 주인으로 사용하고자 하는 쪽의 반대편에 mappedBy를 사용하면 주인은 fk값을 변경할 수 있다.

이런 경우는 반대쪽에 fk가 있어도 값을 변경할 수 있다.

왜 이렇게 동작하는 지는 알 수가 없다..JPA가 지원을 안 한다고 하는데 굳이 이럴 이유가 없어보이는데..


하여튼 그럼 우리는 두 가지 선택권이 있다. fk가 있는 쪽에서 @OneToOne을 거느냐,

아니면 fk가 없는 쪽을 주인으로 하는 양방향 연관관계를 만드느냐이다.

사실 여기에는 각자 장단점이 있기는 하다.

fk가 있는 쪽에서 @OneToOne을 걸면 장점이 테이블을 조회할 때 fk값이 있고 없고를 보고 참조하는 객체가 있는 지 없는 지 판단이 가능하다.

하지만 반대로 fk가 없는 케이스의 경우 테이블을 조회할 때 fk를 포함하고 있지 않기 때문에 결국은 참조하는 row가 있는 지를 판단하려면

반대쪽 테이블에서 fk가 없는 row의 pk값을 갖고 있는 row가 있는 지를 한 번 검색해야 하는 것이다.

그래서 어차피 한 번 조회과정을 거치기 때문에 지연로딩을 걸어도 즉시로딩 한다는 단점이 있다고 한다.


대신 fk가 없는 쪽에 거는 경우 fk가 있는 쪽이 '1'에서 '다'로 변경되었을 때 테이블 구조를 유지하기가 편하다는 장점이 있다.

그건 반대도 마찬가지 아닌가요?

그렇긴 한데, 여기서 주와 부로 나누어서 생각해 보면 '부'가 '다'가 되는 경우가 일반적으로 '주'가 '다'가 되는 경우보다 많기 때문이다.




두 번째 주의할 점은 Unique제약이다.

@OneToMany에서는 자동으로 Unique제약을 걸어 주는데, @OneToOne은 Unique제약을 우리가 걸어야 한다.

우리가 걸지 않으면 @OneToOne을 사용했음에도 같은 Entity를 서로 다른 Entity에서 참조 가능해지기 때문에 

왜 @OneToOne했는데 안 되지? 이런 경우가 발생할 수 있다.

꼭, @OneToOne을 사용할 때에는 @JoinColumn에 옵션으로 Unique제약을 넣어 주자.

