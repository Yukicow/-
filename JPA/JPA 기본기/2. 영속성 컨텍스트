





영속성 컨텍스트는 JPA의 컨셉을 동작시키기 위한 구현체이다.

엔티티(Entity)를 저장하고 관리하는 '저장소(캐시)'의 개념이라고 생각하면 된다.

EntityManager에 의해 접근하여 다뤄지는 저장소이다.


EntityManager는 영속성 컨텍스트 뿐만 아니라 쓰기 지연 SQL 저장소를 통해 쿼리를 저장했다가 commit하면 flush하기도 한다.

flush란 쓰기 지연 SQL저장소에 있는 쿼리들을 실제로 DB에 전송하고 수행하는 메소드라고 보면 된다.

우리가 직접 호출하거나, 트랜잭션이 커밋될 때, JPQL의 쿼리객체가 쿼리를 수행될 때 자동 호출된다.

# 보통 직접 호출하는 경우는 많이 없다고 한다.

JPQL의 쿼리 객체가 쿼리를 수행할 때 자동 호출하는 이유는 호출시점에 그 전에 작성한 쿼리들에 의해서

DB에 반영되었다는 가정하에 데이터를 조회하거나 수정하는 경우가 있을 수 있기 때문이다.

JPQL은 바로 호출되어 버리기 때문에 그 전에 영속성 컨텍스트에 저장된 쿼리들이 수행되지 않고 JPQL만 호출되어 버리면

개발자의 의도와 맞지 않게 실행될 가능성이 있어 flush를 자동으로 호출한 뒤에 JPQL이 수행되도록 하는 것이다.

# 참고로 이 기능은 옵션이라는 듯 하다. 원하지 않으면 flush를 호출하지 않게 바꿀 수도 있는 듯 하다.

# 하지만 그럴 경우 개발자에게 모든 flush 호출 의무가 있기 때문에 JPA쌉고수가 아닌 이상 실수를 하기 마련이다.


flush는 쿼리를 한 번에 보내서 수행하는 역할을 하도록 하는 것이지 커밋과는 관계가 없다.

그냥 오로지 영속성 컨텍스트의 쓰기 지연 SQL 저장소에 있는 쿼리문만 보내고 반영하는 것이 전부라고만 생각하면 된다.



영속성 컨텍스트에는 캐시라는 것이 있다. 

(가볍게 생각하면 '캐시 = 영속성 컨텍스트' 라고 봐도 틀리지는 않다.)

1차 캐시 2차 캐시가 있는 것 같은데, 1차 캐시에 대해 알아 보자.


먼저, JPA에서 우리가 EntityManager를 통해 '데이터 변경(저장,삭제)'메소드를 수행할 시 바로 DB에 반영되지 않는다.

쓰기 지연 SQL 저장소에 그 쿼리를 순차적으로 저장하고 commit시점에 한 번에 전송되어 수행한다.

물론 '데이터 조회'의 경우는 예외이다. 조회는 데이터를 가져와서 봐야 하기 때문에 바로 수행된다.


하지만 이 때 '데이터 조회'든 '데이터 변경'이든 공통되는 내용이 있다.

바로 조회되어 Entity화된 데이터나 변경할 예정인 Entity 객체들이 모두 영속성 컨텍스트의 1차 캐시에 보관된다는 것이다.

EntityManager에 의해 한 번이라도 사용된 데이터들은 1차 캐시에 그 엔티티 객체와

그 객체가 등록되는 시점의 데이터 상태를 그대로 유지하는 스냅샷 엔티티가 등록된다.


이 때 EntityManager가 다루는 Entity는 어떻게 지정하고 생성할까?

@Entity를 DB와 매핑시키려는 객체에 붙여 주면 JPA(EntityManager)가 관리하는 객체로서 인지한다.

그럼 그 객체로부터 DB에 값을 저장하거나 반대로 DB에서 매핑되는 테이블로부터 row를 Entity로 가져올 수 있다.

@Entity를 붙여 줄 객체에는 '기본 생성자'를 필수로 넣어야 하고, 

final클래스, enum, interface, inner클래스에는 @Entity 사용이 불가능하다.



하여튼 이렇게 등록된 개체들을 이용해 영속성 컨텍스트가 어떤 일을 하는 지 알아 보자.

EntityManager는 데이터를 변경하거나 조회할 때 가장 먼저 영속성 컨텍스트의 1차 캐시를 확인한다. 

# 1차 캐시에는 primary key값과 엔티티, 스냅샷 엔티티가 저장되어 있다.

그리고 데이터를 조회할 때 1차 캐시에 조회하려는 엔티티가 있다면 새롭게 DB로부터 SELECT를 수행하는 게 아니고

1차 캐시에서 그 엔티티를 그대로 반환한다.  

데이터를 수정할 때에는 마지막에 commit이 되어 수정쿼리가 날아가기 전에 

1차 캐시에 등록된 실제 엔티티와 스냅샷 엔티티의 값을 비교하여 변경사항이 있다면 적용하도록 한다.

값을 비교했을 때 변경사항이 없다면 쿼리는 수행되지 않는다.


캐시에 등록되어 영속성 컨텍스트에 의해 관리되는 개체들을 영속 상태라고 표현한다.

영속 상태의 개체들에 대해서는 위와 같은 작업들이 수행된다.

영속 상태의 개체를 영속성 컨텍스트의 관리에서 빼도록 하여 준영속 상태로 만들 수 있는 메소드가 있는데 detach()이다.

이렇게 준영속 상태로 만들면, 캐시에서도 엔티티가 사라져서 조회도 다시 해야 하고 값을 변경해도 DB에 UPDATE가 반영되지 않는다.

또, 특정 개체만 준영속 상태로 만드는 게 아니고 아예 영속성 컨텍스트 전부를 초기화 시키는 메소드도 있는데, clear이다.


JPA는 기본적으로 영속성 컨텍스트를 이용해서 위오같은 매커니즘으로 동작하게 되어 있다.

그렇다면 이런 방식으로 사용하였을 때 이점이 무엇이 있길래 이렇게 하는 것일까?



이러한 영속성 컨텍스트 개념을 도입해서 얻는 이점이 여러 가지가 있다.


1. 캐시를 이용한 성능 향상

위에서 보면 알겠지만 성능이 좀 더 좋다. 물론 아주 미미하다고는 하는 것 같지만.

SELECT를 할 때마다 DB에서 값을 조회한다면 조금 시간이 걸릴 수 있다.

하지만 한 번 가져온 데이터에 대해서는 같은 엔티티를 반환하기 때문에 이러한 과정이 없어져 시간이 절약된다.



2. 동일성 보장 (REPEATABLE READ 보장)

SELECT를 할 때 캐시에 존재하는 엔티티를 그대로 반환한다는 것은 반대로 말하면

계속 새롭게 조회를 해도 변하지 않는 값을 받을 수 있다는 얘기이다.

중간에 데이터가 변경되고 커밋되어 DB에 반영되어도 캐시값을 읽기 때문에 처음과 달라질 이유가 없다.

이는 영속성 컨텍스트를 구현함으로써 얻을 수 있는 이점이기 때문에 DB의 격리수준과 관계없이 동작하는 내용이다.

따라서 DB의 격리수준이 한 단계 낮은 READ COMMIT이어도 REPEATABLE READ를 보장받을 수 있다.

"즉, 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 

데이터베이스가 아닌 애플리케이션 차원에서 제공한다."라고 볼 수 있다.


주의할 점은 이는 영속성 컨텍스트에 엔티티가 저장되어 있을 때의 얘기이다.

중간에 영속성 컨텍스트에서 분리를 했다가 다시 조회한다면 그 때에는 DB로부터 다시 조회하기 때문에 새로운 값이 조회될 수 있다.



3. 쓰기 지연

위에서도 쓴 내용이지만 영속성 컨텍스트는 쓰기 지연 SQL 저장소에 SQL을 저장해 두었다가 마지막에 한 번에 보낸다.

그래서 




4. 변경 감지

1차 캐시에 실제 엔티티 객체와 스냅샷 엔티티 객체가 함께 등록되어 있기 때문에

스냅샷 엔티티 객체와 실제 엔티티 객체간의 차이를 변경된 데이터를 통해 감지할 수가 있다.

그래서 이러한 변경 감지를 통해 실제로 변경된 데이터가 있을 경우에만 데이터 수정 쿼리를 날리도록 할 수 가 있어 효율이 좋다.

실제로 EntityManager에는 데이터를 수정하는 메소드가 따로 존재하지 않는다.

즉, 알아서 변경이 일어나는 것을 감지해서 수정쿼리를 날려 주는 것이다.


예를 들어 우리가 따로 SELECT로 엔티티를 조회하고 그 엔티티의 데이터를 변경한 다음에

따로 persist같은 메소드로 다시 값을 넣어 줄 필요가 없다는 것이다.

JPA는 엔티티 객체의 데이터에 변경이 있을 경우 커밋 전에 실제 DB에서도 매핑되는 데이터를 변경할 수 있도록 쿼리를 작성하고

쓰기 지연 SQL 저장소의 쿼리들과 함께 flush한다.




5. 지연 로딩

==== 아직 안 배움 ====









위의 내용을 읽었다면 이제 JPQL을 사용할 때 주의할 점을 알았을 것이다.

EntityManager에는 데이터 변경에 대한 메소드가 없다.

그렇기 때문에 그저 엔티티의 스냅샷을 이용해서 변경사항이 있을 때만 수정 쿼리가 날라가는데,

이 때 JPQL을 통해서 수정 쿼리를 날리면 어떻게 될까?

정말 슬프게도 JPQL을 통한 수정 쿼리가 DB에는 반영이되지만 엔티티에는 반영이되지 않는다.

즉, 엔티티의 값을 변경하지 않은 상태로 JPQL로 수정 쿼리만 날릴 경우 엔티티는 유지되고 수정만 반영되는 것이다.

그래서 Entity 그래프를 맞춰야할 필요가 있다면 적절하게 영속성 컨텍스트를 비우고 다시 채우는 방법을 사용해야 한다.