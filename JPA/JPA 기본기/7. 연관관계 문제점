



'JPA기본기 - 5. 연관관계 매핑' 뒤의 내용이다.



1. @OneToMany 사용 시 문제점


@OneToMany, @ManyToOne, @OneToOne, @ManyToMany들은 위에서 말한대로 DB의 기능을 이용해 만든

단방향 관계를 설정하기 위한 기능으로서 만들어진 것이다.

쉽게 말하면 DB의 fk과 같은 기능에서 단방향만을 구현하기 위한 것이라고 보면 된다. 


먼저, hibernate jpa는 @OneToMany 어노테이션을 통해 단방향 관계를 설정할 때 테이블을 하나 더 만든다.

참조되는 쪽에서도 참조하는 쪽을 참조할 수 있도록 하기 위한 중간 장치인 것이다.


@ManyToOne의 경우는 테이블을 새로 만들지는 않고, fk처럼 pk를 참조하는 컬럼을 하나 만들어서 참조한다.

그럼 왜 @OneToMany에서만 테이블을 쳐 만들죠?

이건 상식적으로 생각하면 당연한 내용이다.

@ManyToOne의 참조하는 Entity가 하나이기 때문에 컬럼을 하나 추가하고 pk값 하나만 참조하면 된다.

하지만 @OneToMany의 경우는 자신을 참조하는 ㅈㄴ게 많은 row들을 모두 알아야 한다.

그래서 하나의 컬럼을 생성하고 거기에 pk값을 다 때려넣을 수가 없는 구조이다.

그래서 따로 테이블을 만들고 하나하나 다 저장하는 것이다.


하여튼 다시 돌아와서 테이블을 만드는 이유를 설명하면

1 : N에서 '1'쪽에서 N을 참조하기 위한 방법이 필요하기 때문이다.

만약 '1'쪽을 참조하고 있는 'N'들의 모든 pk를 알 수 있다면 특정 'N'을 바로 찾기가 수월할 것이다.

이렇게 '1'쪽을 참조하는 'N'들의 pk를 '1'의 pk와 매핑시켜 놓은 테이블을 하나 더 만드는 것이다.


Entity의 필드에 'N'쪽의 Entity의 List를 만들고, JPA를 통해 그 List에 'N'들을 집어 넣으면

이 테이블의 로우가 그 List에 맞추어 갱신된다.

예를 들어 Team이라는 Entity에 List<Member>라는 필드가 있고 @OneToMany가 사용되었다고 해 보자


class Team{

    @Id
    private Long pk

    @OneToMany
    private List<Member>
}

이 상태에서 pk가 각각 1,2,3인 Member 객체 3개를 만들고 Team의 List에 추가한 뒤 DB에 반영되고 나면

참조값을 저장하기 위해 새로 생긴 테이블에는 Team의 pk와 각 Member의 pk가 담긴 row가 3개 갱신된다.

그럼 나중에 DB에서 Team을 조회하게 되면 갱신된 테이블을 토대로 List안에 들어갈 Member들을 함께 가져온다.


근데, 이 때 문제가 하나 있다.

@OneToMany를 단순히 단방향 연관관계로서 단독으로 사용하면 문제될 게 없는데,

만약 반대쪽에서도 @ManyToOne을 이용해 Team쪽을 참조하고 있는 경우이다.

이럴 경우에는 양쪽이 각각을 단방향 연관관계로 참조하고 있는 상태이다.


늘 말하지만 양방향 연관관계가 아니다.

서로 다른 단방향 연관관계 두 개가 있는 것이다.

그렇기 때문에 Team이 Member를 참조하기 위해 사용하는 방식과 Member가 Team을 참조하기 위해 사용하는 참조방식은 서로 연관이 없다.

사실상 따지고 보면 @OneToMany와 @ManyToOne이 서로 연관되어 있는 게 아니라는 것이다.

그냥 각자의 필드에 필요에 의해 단방향 연관관계를 설정한 것이라고 보면 된다.


예를 들어 이렇다.

Team의 경우 Member와 단방향 연관관계를 맺기 위해 @OneToMany를 사용할 경우 

Team의 pk값에 따른 여러개의 Member pk값을 갖는 테이블이 새로 생성된다.

그리고 Team은 그 테이블을 통해서 자신이 참조할 Member를 참조하며 단방향 연관관계를 맺고 있다.

반대로 Member는 @ManyToOne으로 Team과 단방향 연관관계를 맺을 경우 Member의 테이블에 Team의 pk값을 참조하는 컬럼을 추가한다.

그리고 Member가 참조할 Team의 pk를 담고 Team을 참조할 때 그 값을 통해서 참조한다.

즉, Team의 입장에서는 Member의 컬럼은 알 바가 아니고, Member입장에서 Team이 사용하는 테이블은 알 바가 아니다.

서로 각자 자신들이 필요로 하는 값을 참조하기 위한 방식을 각각 갖고 있는 것이다.


만약에 이것이 의도된 것이고, 정말 둘의 참조 관계가 연관이 없는 것이면 상관이 없다.

그래서 Team1의 멤버 목록에는 Member 1,2,3 이 있는데 Member1의 Team 소속이 Team1이 아니고 Team2일 수도 있다.

지금 위의 예시에서는 아무리 봐도 뭔가 이상한 상황이지만, 단방향 연관관계라는 것은 그런 것이다.

서로 필요한 것만 참조하면 되는 것이지, 그게 연관될 필요가 없다.

하지만 우리가 저런 연관 없는 단방향 연관관계를 의도하고 사용하는 경우는 사실 거의 없다.

분명 양방향 연관관계처럼 동작하기를 바라고 사용할 것이다.


그럼, 말한대로 양방향 연관관계처럼 동작하기를 바라고 사용한다면 이제 문제가 발생한다.

위처럼 각각의 참조가 불일치하는 경우가 발생하는 것이다.

왜냐면 각각이 단방향 연관관계이기 때문에 한 쪽에서 참조하는 값의 변화가 다른 쪽의 참조값에 영향을 주지 않기 때문이다.


Team은 테이블을 참조하고, Member는 자신의 컬럼을 참조하는데

만약에 우리가 로직상에서 Team의 List에서 Member1과 2를 지웠다고 해 보자.

그럼 테이블에는 Member1과 2에 대한 row는 없어질 것이다.

하지만 그 반대로 Member에서 Team을 참조하던 컬럼에는..?

당연하게도 변화가 있을 리 없다.

이렇게 각각이 참조하고 있는 개체가 다르기 때문에 서로의 참조값의 변화에 무관심하다.

이럴 경우 양쪽의 참조를 서로 맞추기 위해서는 개발자가 직접 양쪽의 참조에 모두 변화를 주어야 한다.

Team의 List에서 Member 1과 2를 제거했다면 Member1과 2에서도 Team의 참조를 없애야 하는 것이다.


일반적으로 RDB에서는 fk를 사용해서 양방향 연관관계를 구현하기 때문에

양쪽이 같은 fk를 바라보고 있어서 fk하나만 변경하면 서로의 참조관계가 모두 달라진다.

Member의 fk만 바꿔도 Member는 더 이상 Team과 연관이 없고, 

Team에서도 자신을 참조하는 Member들을 조회할 때 fk가 변경된 Member는 조회에서 빠질 것이다.


하지만 우리는 서로 다른 참조를 이용해서 있는 단방향 연관관계를 갖는 두 객체를 이용해 양방향 연관관계를 맺었기 때문에 

이러한 문제가 발생한 것이다.




2. @OneToMany와 @JoinColumn 사용 시 문제점

위의 @OneToMany만 사용하는 케이스에서는 '1'쪽에서 'N'을 참조할 방법이 없었기 때문에

테이블을 하나 더 만들어서 그 테이블에 fk와 pk를 저장함으로써 '1'이 'N'들을 참조할 수 있게 했다.

하지만 이번에는 @JoinColumn과 함께 사용하는 경우이다.

이럴 경우 굳이 테이블이 새로 생길 필요가 없다.

join에 필요한 컬럼을 명시했기 때문에 '1'쪽에서 'N'들을 전부 조회할 수 있게 되었다.


그리고 위의 1번에서의 문제점과 다르게 이제는 같은 참조를 가지는 두 개의 단방향 연관관계이기 때문에

사실상 거의 RDB에서의 fk를 이용한 양방향 연관관계와 거의 같은 형태라고 볼 수 있다.

# 사실 그냥 같다고 보면 된다.


하지만 여기에도 문제가 있다. 

바로 결국은 단방향 연관관계 두 개를 이용한 양방향 연관관계의 구현이기 때문에

양쪽에서의 참조의 변화가 모두 적용되어 버린다는 문제이다.

예를 들어 보겠다.

위의 예시처럼 Team(fk)을 바꾸고 싶은 경우이다.

Entity가 지금 단방향 관계가 양쪽에 걸려 있기 때문에 

양쪽에서 변경하는 내용이 모두 fk에 영향이 가 버린다는 문제가 생긴다.


예를 들어 Member Entity에서 자신이 참조하던 Team을 다른 Team으로 바꿔 버려도 Member의 fk가 새로운 Team의 pk로 바뀔 것이고

기존의 Team에서 Member를 없애고 새로운 Team에 Member를 추가해도 Member의 fk가 C의 pk로 바뀔 것이다.

# 이 때 양쪽에서 같은 데이터에 변화를 주었을 때, 일단 둘 다 변경을 감지하고 쿼리를 보내기는 하는데, 

# 이게 우선순위가 있는 건지 또는 다른 매커니즘이 있는 건 지는 모르겠다. 쿼리의 순서 때문에 한 쪽이 묻힌다는 것은 확실하다. 

# 보니까 단순 ManyToOne에서 변경하는 경우는 하나의 데이터만 변경하고 OneToMany 쪽에서 변경하는 경우는 여러 데이터가 한 번에 변하는

# 케이스가 있을 수 있기 때문에 일단 단일 변경에 대한 ManyToOne의 쿼리가 먼저 수행되고, 그 다음 OneToMany인 것 같다..?


주석을 읽어 보면 알 수 있지만 지금 여기서의 문제점은 이거다.

위의 @OneToMany만 사용해서 완전히 연관 없는 @ManyToOne과 함께 사용하여 양방향 연관관계인 것처럼 구현할 때에는

양쪽의 참조를 우리가 직접 하나하나 맞추어 주어야 했기 때문에 여간 불편한 게 아니었다.

하지만 지금은 서로 같은 컬럼을 참조하게 되었으니 이런 불편한 문제는 해결이 되긴 했는데  

한 쪽에서의 변화만으로도 이런 참조값에 변화를 줄 수 있다는 게 오히려 양쪽에서 모두 값을 변경시킬 수 있게 돼 버렸다는 것이다.

그리고 한 쪽의 변화가 묻힐 수 있다는 문제점이 있다.


예를 들어 내가 Team1의 List에서 Member1과 2를 뺐는데, 로직상 마지막에 Member1을 다시 Team1에 소속시키기 위해 

Member1의 Team을 Team1로 세팅하고 commit을 했다고 해 보자.

이럴 때, 순서대로 List의 내용이 적용되고 Member의 내용이 적용되면 문제가 없는데..

이게 정확한 순서가 정해진 건지는 모르겠지만 List의 부분이 마지막에 적용되었다는 것이다.

그렇게 되면 마지막에 Member1의 Team을 Team1로 다시 변경한 건 먹히지 않고 List에서 1과 2가 빠진 것만이 적용되어

결국 Member1은 Team1에서 빠지게 되는 슈퍼 불상사가 발생한다.


이런 문제점들은 사실 잘 알고 사용하면, 크게 문제될 건 없긴하다.

하지만 이렇게 복잡한 것을 하나하나 인지하고 사용한다?

아무리 잘하는 사람이라도 한 번쯤은 실수를 하게 되어 있다.

근데 이런 부분에서 실수가 발생해서 문제가 생기면 찾는데에 개고생스한다 진짜로


그러니까 우리가는 이걸 원하는 것이다.

JPA에서 제공하는 단방향 연관관계를 잘 사용하고 있다고 하자.

그러다 우리는 양방향 연관관계를 구현해야 하는 상황이 온 것이다.

그래서 단방향 연관관계를 이용해서 양방향 연관관계를 구현하려고 봣더니??

위의 예시들처럼 뭔가 신경써 주어야 할 부분이 너무 많고 양방향 연관관계라고 하기에는 단방향 연관관계의 특징이 너무 드러나는 것이다.


그렇다면 그렇게 동작하지 않게 하는 양방향 관계 설정 방법이 없을까?

당연하게도 있다.

바로 mappedBy를 사용하는 것이다.


mappedBy는 위의 @OneToMany와 @JoinColumn을 함께 사용하는 방식에서 

한 쪽만 수정이 가능하도록 지정한 것처럼 동작하는 기능이라고도 볼 수 있다.

따지고 보면, DB의 fk를 통한 양방향 관계를 구현하기 위한 기능이라고 보면 된다.

단방향 관계를 이용해서 유사 양방향 관계를 구현한 게 아니고, 진짜로 fk처럼 동작하도록 양방향 관계를 의도한 기능이라고 보면 된다.

그래서 mappedBy는 양방향 관계를 명시하는 것이라고 보면 된다.

그리고 mappedBy의 value값이 이제 fk를 갖는 쪽을 명시하는 것이다.

List에 담기는 객체 중에 Entity를 참조하는 필드가 바로 fk라고 볼 수 있다.

그래서 그 필드의 필드명을 value값으로 적어 주면 그 필드가 fk와 같이 동작함을 명시하는 것이다.


fk처럼 동작하는 양방향 관계이기 때문에 당연히 fk의 변경은 fk를 갖는 쪽에서만 이뤄질 수 가 있다.

즉, List를 갖는 쪽에서 아무리 변화를 줘도 fk에는 변화가 일어나지 않는다.

위의 @OneToMany와 @JoinColumn을 사용했을 때에는 List에서의 변경도 영향이 갔는데 이제는 다르다.

fk처럼 동작하는 양방향 관계의 구현이라고 생각하면 이게 당연하다. 

DB에서 fk를 변경하는 쪽은 fk를 갖는 테이블 말고는 불가능하다.



하지만 @OneToMany, @JoinColumn을 사용할 때는, 우리는 단방향 관계를 통해 양방향 관계를 구현하다 보니 

데이터의 변화를 감지하고 변경하는 JPA의 동작 특성상 다른 Entity(즉, 다른 테이블)의 변화가 

fk의 변화에까지 영향을 미쳐서 동작한 것 뿐이다.

하지만 이번에는 제대로 fk처럼 동작하는 양방향 관계를 대놓고 만들었으니 이런 일이 발생해서는 안 된다.

즉, 원래의 양방향 관계에서의 동작 형태를 갖춘 것이다.


