






객체지향 언어와 RDB의 가장 큰 차이점은 참조값이라고 할 수 있다.

객체에서는 필드로 객체를 직접 참조할 수 있는 장점이 있는데,

RDB의 경우는 다른 테이블을 직접 가질 수 없고 조회가 가능하도록 테이블의 참조값(fk)을 저장하는 형식이다.

이러한 차이 때문에 Entity에서 테이블의 컬럼을 매핑시킬 때에도 어쩔 수 없이 다른 Entity의 pk를 참조하는 fk를 갖도록 만든다.

이것은 Entity를 RDB에 맞추어 설계한 것이라고 할 수 있다.

이렇게 되면 Entity가 참조하고 싶은 Entity가 있을 경우 참조값을 갖는 필드를 이용해서 다시 Entity를 조회해야 하는 일이 발생한다.


그래서 이러한 RDB와 객체 지향 언어의 불일치를 해결해 주는 기능이 있다.

바로 연관관계이다.

연관관계를 사용하면 Entity는 객체 지향 언어에서 사용하던 그대로 특정 객체를 참조하여 사용할 수 있다.

그러면 RDB에서는 그 특정 Entity에 필요한 값도 함께 join으로 조회해서 Entity의 필드에 주입해 준다.

이 때 join이 아니고 분리해서 조회하고 가져오게 할 수도 있는데 이건 옵션이니 나중에 배울 내용이다.



연관관계의 종류에는 여러 가지가 있지만 일단 기본적으로 연관관계에 대해 이해하기 위해서는

단방향 연관관계와 양방향 연관관계를 이해해야 한다.


단방향 연관관계라는 것은 객체지향 언어에서 객체가 다른 객체를 has a관계처럼 가질 때처럼

객체가 다른 객체를 참조할 수 있는 형태의 연관관계를 말한다.

즉, Entity가 참조하고자 하는 Entity를 필드로 포함하는 경우에는 그 Entity를 바로 조회가 가능하다는 것이다.

하지만 단방향 연관관계에는 문제가 있다.

참조되는 쪽에서는 자신을 참조하는 Entity를 조회할 방법이 없다는 것이다.


RDB의 경우는 fk를 통해서 서로가 참조될 수 있는 형태로 연결되어 있는데, 이는 양방향 연관관계이다.

RDB에서는 이 fk를 가진 쪽이든 참조되는 쪽이든 fk를 통해서 '조회'라는 기능을 누릴 수 있다.

하지만 프로그래밍 언어 에서는 이런 특정 참조값을 이용해 조건부로 조회하는 '기능'이 없기 때문에  

양방향 연관관계라는 개념이 존재하지 않는다.

또, 반대로 RDB는 완벽한 단방향 연관관계라는 개념이 존재하지 않는다.

왜냐하면 한 쪽이 누군가의 컬럼값을 가지고 있다는 것은 반대 쪽에서도 자신의 컬럼값으로 그 쪽을 조회할 '여지'가 충분하기 때문에

일방적인 단방향 연관관계 관계가 성립할 수 가 없다.


이런 패러다임의 불일치가 있기 때문에 프로그래밍 언어에서는 양방향 연관관계를 직접 '기능'으로서 구현해서 사용해야 한다.

그 기능을 어떻게 구현할까?

먼저, RDB의 양방향 연관관계를 이용해야 한다.

RDB를 이용해서 단방향 연관관계처럼 동작하도록 구현하면 된다.

사실 양방향 연관관계를 이용해서 단방향 연관관계를 동작하게 한 것이나 다름이 없다.

위에서도 말했지만 한 쪽이 다른 쪽의 컬럼을 갖는 이상 양방향 연관관계는 성립할 수 밖에 없다.


하지만 반대 쪽이 그 관계를 모른다는 가정으로 사용하면 어떨까?

fk를 지정하지 않고 한 쪽 테이블에서 일방적으로 다른 한 쪽의 fk값을 컬럼으로 갖는다면 가능할 것이다.

한 쪽은 완전히 자신의 pk가 다른 곳에서 참조되고 있다는 걸 모르니까 말이다. 사실상 유사 단방향 연관관계를 만들 수 있다.

하지만 이럴 경우 그 컬럼값의 경계가 애매해진다. 

다른 테이블의 pk를 일반 컬럼으로서 갖는다는 건 사용의 경계가 애매해지기 때문에 위험할 수 있다.

그리고 실제 JPA에서도 이렇게 사용하지는 않는다. 그냥 fk로 지정하고 사용한다.

근데 따지고 보면 납득이 안 가는 것은 아니다. 논리적으로 보면 위처럼 fk로 지정하지 않는 게 성격상 맞지만

fk로 지정한다고 해서 단방향 연관관계를 만들 수 없는 것도 아니고, 그냥 인지는 하되 안 쓰면 그만인 것이다.


쉽게 생각하면 양방향 연관관계라는 것은 단방향 연관관계를 포함하는 개념이기도 하다.

양방향 연관관계에서 다른 한 쪽이 다른 한 쪽을 참조하는 기능을 배제하면 그건 사실상 단방향 연관관계라고도 볼 수 있지 않을까?

그래서 프로그래밍 언어의 객체의 단방향 연관관계를 구현하기 위해 RDB의 양방향 연관관계의 특성을 이용하고

그것을 단방향 연관관계로서만 사용하면 단방향 연관관계를 구현할 수 있다.

말은 복잡하지만 그냥 양방향 연관관계를 만들고 단방향 연관관계로 사용하는 것이다.


그럼 그 다음에는 양방향 연관관계를 구현하기 위해 

참조되는 Entity쪽에서도 자신을 참조하는 Entity를 가지게 하고 단방향 연관관계를 각 Entity에 부여한다.

그럼 서로 양쪽에서 각자 참조가 가능해지기 때문에 양방향 연관관계가 된다.


왜 굳이 fk를 이용한 양방향 연관관계가 있는데 단방향 연관관계 기능을 또 만들고 그걸 이용해서 양방향 연관관계를 만들어야 하죠?

왜냐하면 프로그래밍 언어에서는 위에서도 말했지만 단방향 연관관계가 존재하고,

DB를 이용할 때에도 이런 단방향 연관관계만이 적용되어야 할 때가 있기 때문이다.


예를 들어 이런 경우가 있을 수 있겠다.

FoodShop에는 Food가 여러 가지 있다.

FoodShop은 Food를 여러개 참조해서 사용해야 하지만, Food는 자신이 어느 FoodShop에 소속되어 있는 지 알 필요가 없다.

왜냐하면 Food가 FoodShop 하나에 국한되는 게 아니고 여러 FoodShop에서 사용될 수 있기 때문이다.

이런 경우에는 FoodShop이 Food만 참조하면 되는 경우이기 때문에 굳이 양방향 연관관계가 필요가 없다.

오히려 fk를 이용한 양방향 연관관계로는 이런 관계를 만들 수가 없다.

왜냐면 fk를 사용하면 하나의 pk만 컬럼에 저장이 가능하기 때문에 Food가 여러 FoodShop에 소속될 수 없다.

그래서 이럴 때에는 FoodShop의 pk와 Food의 pk를 컬럼으로 갖는 테이블을 하나 더 만들어서 사용해야 한다.

실제로 @ManyToMany라는 단방향 연관관계를 이렇게 구현하고 있다.

물론 양쪽의 pk를 가지는 이상 양쪽 모두에서 서로를 조회할 수 있으니 양방향 연관관계도 성립이 해버리지만

애초에 우리가 의도한 @ManyToMany이 붙은 쪽만이 이 테이블을 사용할 예정이니, 사실상 단방향 연관관계라고 할 수 있다.

마치 물걸레질과 청소 기능가 모두 가능한 청소기를 샀는데 청소기능만 쓰는 느낌..?


하여튼 이런 식으로 DB의 기능을 이용해서 객체의 단방향 연관관계를 구현하도록 한다.

사실상 이런 기능은 개발자가 직접 테이블을 생성해서 구현해야 하는 것이 맞다.

하지만 우리는 ORM기술을 사용하고 있다.

이런 객체에서의 단방향 연관관계를 ORM기술이 구현해 준 것이라고 생각하면 된다.

즉, 이 내용이 너무 어렵다면 그냥 내가 이런 단방향 연관관계 기능을 구현했을 때 어떤 모습일 지를 생각해 본다면 좀 그려질 것이다.



위에서 말한 단방향 연관관계를 이용한 양방향 연관관계는 완벽한 양방향 연관관계라고 보기가 좀 애매하다.

왜냐하면 사실상 이 방식은 단방향 연관관계를 양쪽에 적용시켜서 양방향 연관관계를 만든 것이기 때문이다.

RDB에서는 fk하나로 양방향 관계가 정립이 돼버리는데, 이 방식은 그런 하나의 값으로 양방향 연관관계가 정립된 것이 아니기 때문이다.

한 쪽이 다른 한 쪽의 레퍼런스를 가져야만 하는 형태로 동작하기 때문에 사실상 단방향 연관관계밖에 없는 것이다.

그리고 그 단방향 연관관계를 양쪽에 적용시켜서 양쪽에서 서로를 조회할 수 있게 만든 것일 뿐이다.


쉽게 생각하면 이거다.

객체지향 언어인 java, 즉, 프로그래밍 언어에는 '어떤 특정 공통되는 값을 가지고 객체를 조회' 라는 개념의 '기능'이 없다는 것이다.

프로그래밍 언어와 RDB는 애초에 개념이 다르고 동작방식이 다르기 때문이다.

무조건 그 객체의 참조값이 있어야만 우리는 그 객체에 접근이 가능하다는 것이다.

그래서 우리는 양쪽이 모두 참조값을 갖도록 한 것이다.


근데 이렇게 양쪽이 참조값을 가지게 하면서 문제가 발생했다.

참조값이 서로 연관없이 다른 경우나 오히려 같아서 발생하는 문제가 있다.

그 문제점에 대해 알아 보자.




