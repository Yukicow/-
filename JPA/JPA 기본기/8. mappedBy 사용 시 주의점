








mappedBy를 사용할 때 주의해야 할 내용들에 대해 알아 보자.




1. 주인이 아닌 곳에서의 데이터 변경을 해 놓고 DB에 변경사항이 적용되지 않는 것으로 오해


mappedBy를 사용할 때 가장 많이 하는 실수가 바로 이것이라고 한다.

주인이 아닌 쪽의 List에 변화를 줘 놓고, 계속 데이터가 제대로 변경이 안 됐다느니, fk가 의도된대로 동작하지 않는다느니 하는 것이다.

연관관계와 mappedBy를 제대로 이해했다면 일어날 수가 없는 일이다.

물론 로직을 작성하다가 뭔가 복잡해져서, 나도 모르는 사이에 그렇게 사용할 수도 있다.

이 부분은 조심해야 한다.





2. DB에 반영되는 주인쪽만 데이터 변경하기


mappedBy를 통해서 fk를 지정한 Entity의 변화만이 DB에 반영된다고 해서 

Entity에 변화를 줄 때에 List에는 아무 변화를 주지 않는 것이다.

Entity를 변화했다면 List에도 변화를 주어야 한다.

그래야 그 이후 로직에서 List를 통해 뭔가 수행을 할 때에 불일치가 발생하지 않는다.

List가 DB에 영향이 없다고 해서 무시하는 것은 ORM기술을 사용하는 이유가 없는 것이다.

ORM은 DB를 객체와 매핑시켜 사용하는 것이기 때문에 객체를 이용해서 값을 변화시키면

전체적인 연관관계나 데이터 정합성을 DB처럼 유지해야 한다.


그럼 그냥 flush하고 clear하면 되는 거 아닌가요

실무에서는 flush와 clear를 직접 사용하는 것은 거의 없다고 한다.

또, flush를 하고 clear를 하면, 그 전에 사용했었던 데이터들을 이용하려면 다시 캐시에 올려야 하는데,

이럴 경우 한 번씩 다 부르는 과정을 겪어야 하기 때문에 성능적으로 좋지 않다..


근데 결국 그렇게 다 맞춰줄 거면 사실상 mappedBy없이 @OneToMany랑 @ManyToOne만 써도 상관없지 않나요..?

맞다.

사실상 @OneToMany랑 @ManyToOne을 사용할 때와 다를 건 없다.

하지만 mappedBy를 사용함으로써 RDB의 동작방식과 매핑되도록 구현할 수 있고

무엇 보다 실수를 해서 우리가 객체상태를 반영하지 못 해 일치시키지 않아도 실제 DB에서까지 불일치할 일은 없다는 것이다.

데이터를 일치하는 걸 잊어서 원하는 형태로 데이터가 들어가지는 않을 수는 있을 지 언정 참조의 불일치가 일어날 수가 없게 된다는 것이다


그래서 실제 개발자들은 이런 데이터를 일치시키는 걸 까먹는 걸 방지하기 위해서 편의메소드를 만들어 사용한다고 한다.

예를 들어 fk의 주인인 Member쪽에서 Team세팅하는 changeTeam()메소드에 

인자로 받은 Team의 List에 Member 자기 자신을 추가하는 로직까지 함께 포함시키는 것이다.

이렇게 하면 하나의 호출에서 양쪽이 함께 설정되므로 편리하게 사용이 가능하다.


오..그럼 setter에 저렇게 로직을 추가하면 되겠군요!

정말 슬프게도 setter에 이런 로직을 추가하기 보다는 그냥 다른 이름의 메소드를 만들어서 사용하는 게 좋다.

무조건 안 되는 건 아닌데, setter는 관례로서도 사용되는 메소드이기 때문에 setter가 다른 곳에서 사용될 때 문제가 발생할 수 있다.

또 사용하는 사람 쪽에서도 이게 단순이 setter를 사용한 건지 이런 변경 로직을 사용한 것인 지 구분하기도 좋다.


그리고 이런 값을 세팅하는 메소드도 양쪽 중에서 어디에 두고 사용할 지는 상의하고 사용하면 된다.

양쪽 다 두는 방식은 그닥 좋지 않다고 한다.

주인은 Member지만 Team에서 add나 delete를 할 때에 Member의 Team이 함께 바뀌도록 할 지, 

Member의 Team을 바꿀 때 list를 삭제 추가할 것인 지 선택해야 한다.



예시를 좀 들어 보자면 

Team에 둘 경우에는 Member를 넣을 Team과 뺄 Team 양쪽의 메소드를 호출해야 하고

Member에 둘 경우에는 Team을 변경하는 하나의 메소드에서 기존의 Team에서는 빼고 인자로 받은 새로운 Team에는 추가하는 로직을 넣어야 한다.

하나의 메소드로 해결되고 간결하다는 장점이 있다. 개인적으로 member가 좋은 것 같다.

team.addMember()
team.deleteMember()
이냐

member.changeTeam()
이냐의 문제이다.

대신 member의 하나의 메소드가 조금 복잡하게 생기게 될 수는 있다.

그리고 또 상황마다 다를 수가 있기 때문에 그 때 그 때 판단하고 사용하면 된다고 한다.







3. 무한 루프에 조심하자.


이건 객체의 특성상 당연히 조심해야 하는 내용이다.

양쪽이 서로를 참조하고 있는 형태의 객체의 경우, 당연하게도 서로를 참조하다가 무한루프에 빠지기도 한다.

예를 들어 3가지 정도가 있는데, toString(), lombok, Json을 사용할 때이다.


toString의 경우는 자신의 필드를 출력하기 때문에 자신이 참조하고 있는 객체의 toString을 호출할 텐데,

그 객체가 자신을 참조하고 있기 때문에 자신의 toString이 한 번 더 호출되고 또 필드의 객체가 toString되고 하는 식으로

무한루프에 빠질 수 있어서 toString을 사용할 때에는 조심해야 한다.

lombok을 조심해야 하는 이유도 사실 toString때문이다. 

lombok의 @ToString이나 @Data 등의 어노테이션은 자동으로 toString을 만들어 주기 때문에 사용할 때에 주의해야 한다.


Json라이브러리에서 주의해야 하는 이유는 Entity(@Entity가 붙은 객체)를 Controller를 통해 출력할 때 발생하는 문제 때문이다.

API스펙으로 Entity를 반환해 버리면, Json으로 변환 과정에서 toString처럼 참조가 엮여 있어서 무한루프가 발생할 수도 있고 

또, Entity는 바뀔 수도 있기 때문에 이런 Entity를 직접 반환해 버리면 나중에 바뀌었을 때 API스펙이 완전히 바뀌어 버리기 때문에

Entity는 직접 반환하는 것 보다는 DTO를 이용해서 데이터를 담은 객체만 반환하는 게 좋다.

그냥 Entity는 아예 Controller에서 반환하지 않는 게 좋다.






4. 처음부터 양방향 연관관계를 사용한다.


우리가 사실 DB를 사용해서 특정 테이블들을 서로 연결시키기 위해 fk를 사용해서 양방향 연관관계를 사용하지만

실질적으로 정말 양방향으로 조회를 하는 경우가 꼭 있는 것은 아니다.


예를 들어 OrderItem(주문 상품)과 Item(상품)이 있을 때 주문 상품에서 어떤 상품인 지를 보려하지

상품을 보고 주문 상품에 뭐가 있는 지를 보려하지는 않는다.

그리고 이런 관계는 사실 단방향 연관관계라고 봐도 무방한 상태이다.

하지만 DB에는 양방향 연관관계가 존재하지 않기 때문에, 이런 관계에서도 일반적으로 fk를 사용하는 것이 더 편리하다.

그래서 실제 DB에서는 fk를 통한 양방향 연관관계가 설립되어 있지만 실제로는 양방향이 연관관계가 필요하지 않은 경우일 수 있다는 것이다.


결론은 우리는 JPA를 통해 객체를 이용해서 DB의 연관관계를 설계하고 있기 때문에 

단방향 연관관계로 관계가 맺어질 수 있는 경우는 무조건 단방향 연관관계로 처리하는 게 제일 깔끔하다.

JPA를 통해서 객체의 연관관계를 설정할 때 DB의 fk에 맞춰서 무조건 양방향 연관관계를 맺는 것은 좋지 않다.


그리고 나중에 반대쪽 조회가 필요한 경우, 그 때 양방향으로 전환해도 하나도 문제될 것이 없다.

DB에 아무런 영향도 없고, 그저 반대방향으로 조회하는 기능만 추가되는 것이라고 볼 수 있기 때문이다.

물론, 편의 메소드를 추가하는 등등의 작업은 추가적으로 필요해 질 수 있지만

단방향 매핑을 잘 해 두었다면 크게 문제될 일도 아니다.

오히려 단방향 매핑으로도 충분한데, 처음부터 양방향으로 매핑해서 신경써 주어야 하는 부분이 늘어날 수도 있다.



약간 쉽게 생각하면 이런 느낌이다.

테이블에서 하나의 컬럼을 조회하는데, 다른 테이블을 참조해서 같이 가져오는 경우가 있나..? 이것이다.

진짜 단편적으로 생각하면 join을 쓸 일이 있냐 없냐라고도 할 수 있다.

너무나도 당연한게 fk를 이용했을 때 join을 쓸 일이 없다면 사실상 그건 단방향 연관관계나 다름이 없다.

예를 들어 Member와 Order가 있다고 해 보자.

우리가 Member를 조회할 때 Order를 함께 조회할 일이 있을까..?

없다고 봐도 된다.

엥? 무슨 소리에요 우리 Member가 조회한 Order를 알아야죠!

자 여기서부터가 지금 문제 발생이다.


Member가 주문한 Order를 알고 싶으면 Member와 Order를 Join해서 가져오는 개념이 아니다.

그건 fk를 이용해서 Order를 조회하는데, Member가 fk인 Order를 조회하면 그만인 일이다.

Member와 Order는 Order쪽에서 나중에 주문한 Member가 누구인 지 알아야할 경우가 있을 수 있기 때문에

Order를 한 Member가 누구인 지를 저장하기 위한 fk를 둔 것일 뿐이다.

여기서는 사실상 Order는 Member에 대해서 N(Order) : 1(Member)로 단방향 연관관계인 샘이다.


이럴 경우에 굳이 객체에 양방향 연관관계를 성립시킬 이유가 없다.

불필요하게 Member객체에 List<Order>를 두어야 할 이유가 없다는 것이다.

오히려 성능만 저하시키는 꼴이된다.

즉, 이렇게 fk를 사용한다고 해서 무조건적으로 양방향 연관관계를 성립하고 있는 것은 아니다.

단방향 연관관계가 필요한데, RDB에서 fk로 양방향 연관관계를 이용해 정립하고 있는 것일 수 있다.




또, 양방향 연관관계라고 해서 무조건 양방향 연관관계를 맺어야 하는 건 또 아닐 수도 있는 것 같다.

예를 들어 join을 통해 가져와야 하는 경우가 있기는 한데, 그렇게 많이 하지는 않을 수도 있다.

그럴 때에는 그냥 jpql의 쿼리를 이용해서 값을 가져오는 게 낫지, 이걸 양방향 연관관계를 맺어주고 사용하는 것은 좋지 않을 수도 있다.

이게 이해한 게 맞는 지는 모르겠다. 요 부분은 나중에 이해되면 고칠거지롱