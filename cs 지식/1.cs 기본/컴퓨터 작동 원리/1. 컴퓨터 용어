

cpu의 작동원리에 대한 영상이니 밑에 글이 이해가 안 되면 참고

https://www.youtube.com/watch?v=Fg00LN30Ezg





1. 프로세서


Processor (프로세서)는 하드웨어적인 측면에서 

"컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛"이다.  

이는 중앙처리장치(CPU)를 뜻하며 폰노이만 '아키텍쳐'에 의해 만들어졌다면 

적어도 하나 이상의 ALU(Arithmetic Logic Unit)와 처리 '레지스터'를 내장하고 있어야 한다.

컴퓨터가 아니어도 다른 기기들에서 그에 적합하게 설계된 프로세서들이 각 있다.

일반적으로 프로세서라고 하면 컴퓨터에서는 cpu를 가리키는 것이라고 볼 수 있다.

프로세서의 구조는 회사마다 각각 다르며 이 구조를 아키택쳐라고 한다.

요즘은 멀티 프로세서들이 대부분인데 하나의 프로세서 가지고는 처리가 안 되는 것을 나눠서 

실행시켜 일의 부담을 줄이기 위한 것이다. 예를 들면 70의 힘이 필요한 일이 있고 싱글 프로세서가 100의

힘을 낼 수 있다면 싱글 프로세서는 이 것을 해낼 수 있다. 하지만 60의 힘을 내는 두 개의 프로세서를 가지고 있다면

이 프로세서는 제 힘을 내지 못 한다. 이 프로그램이 싱글 프로세서에 맞춰져 있기 때문에 

제대로 작동하기 위해서는 70의 힘을 내는 프로세서가 있어야 한다.

하지만 프로그램을 짤 때 애초에 두 개로 나누어 힘을 분산하여 처리하도록 만든 다면 35의 힘을 들이는 두 개의

프로세서로 처리가 가능할 것이다. 만약 110의 힘을 내야 하는 프로그램이라면 어떨까 이 프로그램은

싱글 프로세서로는 조금 버거울 것이다. 듀얼 프로세서에서도 안 돌아갈 것이다. 싱글 프로세서에 맞춰 설계 했으니까.

그러나 이 프로그램을 멀티 프로세서에 맞추어 설계한다면 어떨까.

110의 힘이 필요한 프로그램이 설계될 때 55의 힘이 필요한 두 개의 프로세서로 돌아가게 설계를 했다면

60의 힘을 내는 프로세서 두 개가 있는 멀티 프로세서는 저 프로그램을 완벽하게 돌릴 수 있다.

한 마디로 최적화만 잘 돼있다면 멀티 코어가 웬만하면 더 좋다.





2.코어


코어는 프로세서에서 각종 연산을 수행하는 즉,일을 수행하는 녀석을 말한다.

한 마디로 프로그램을 실행하면 돌아가게 만드는 녀석인 것이다.

일을 수행하는 녀석이 하나인 싱글 코어에서 그럼 여러 프로그램이 어떻게 돌아가는 건가요?

원래는 하나의 프로그램이 실행되기 위해 cpu를 점유하고 있으면 다른 프로그램은 실행상태에 있을 수 없다. 

그래서 시분할(짧은 텀)로 프로그램을 반복하여 전환하며 실행하도록 하고 있다.

이건 여러 프로그램이 동시에 돌아가는 것 처럼 보이는 거지 실제로는 매우 빠르게 하나하나

번갈아 가면 수행하고 있는 것이다. 이걸 context swtiching 이라고 한다.

이 짓이 빠르게 이루어지고 있기 때문에 동시처럼 보이는 것 뿐이다. 이걸 동시성이라고 한다.

여러 코어를 가지고 각 코어가 각 프로그램을 실행을 동시에 하는 것은 병렬성이라고 한다.



3. 프로세스

어떤 작업을 수행할 수 있는 실행파일을 프로그램이라고 한다.

그리고 프로세스는 "메모리에 적재되어 프로세서에 의해 실행중인 프로그램" 이다.

한 마디로 프로그램이 컴퓨터 내에서 실행되면 그것을 프로세스라고 할 수 있는 것이다.

예를 들면 내가 게임을 키면 그것도 프로세스이다. 실행되고 있는 프로그램을 프로세스라고 할 수 있다.




4. 스레드


스레드에는 물리적 스레드와 논리적 스레드가 있다.

물리적 스레드는 하나의 코어가 허용할 수 있는 스레드라고 할 수 있다.

데이터의 이동 통로라고도 볼 수 있다.

옛날에는 하나의 코어에는 하나의 스레드. 즉 코어가 계산한 데이터가 이동할 수 있는 통로가

하나 밖에 없었다. 그래서 코어에 의해 각종 수행된 데이터들은 하나의 통로를 통해 전달이 되었다.

하드웨어에서 말하는 멀티 스레드는 이 통로를 여러개로 바꾼 것이다. 코어가 번갈아 가면 여러 수행을 하고

각종 수행한 결과들은 구분이 되어 통로로 이동하는 것이다. 이거랑 관련된 건 이쪽 스레드~

저거랑 관련해서 수행한 데이터들은 이쪽 스레드~ 코어가 통로 하나만 쓸 때에 남는 시간을

최대한으로 끌어내서 통로를 두 개 줄 테니 쉬는 동안에도 다른 일 해서 데이터 보내라. 채찍질을 하는 것과도 같다. 

한 마디로 논리적 스레드가 병렬처리 될 수 있게 코어를 늘린 것처럼 만든 것 이라고 볼 수 있다.

os가 스케줄링할 수 있는 최소 단위인 거지.




논리적 스레드라는 것은 프로세스 내에서 세부적인 작업의 세부 단위이다.

그니까 프로그램 내에서 진행된 동시 작업의 개수라고 보면 된다.

이게 무슨 말이냐. 크롬을 예시로 들면 원래는 하나의 스레드(실행 단위)로 시작해서

내가 유튜브를 보다가 댓글을 입력해. 그럼 영상은 영상대로 나오고 내가 댓글을 입력하는 건 

그거 대로 받아야 되잖아? 그럼 이 때 원래 스레드가 하나로만 진행된다면 댓글을 쓰든 영상을 보든

하나만 가능하니까 댓글을 쓸 때에는 영상이 멈출 거야. 근데 내가 두 가지를 동시에 하고 싶어서

댓글 달기에 대한 업무를 또 하나의 스레드로 만든 거지.

한 마디로 가지치기라고 보면 돼. 내가 댓글을 쓰려 하면 두 개의 스레드가 된 거야.

물리 스레드가 충분하다면 두개가 병렬처리로 동시에 진행될 수도 있고 부족하다면 우선 순위에 의해 병행처리 시킬 수도 있지.

만약 아무 것도 적용하지 않았다면 댓글 입력 동안 유튜브 영상은 잠시 멈출 것이고.

즉, 소프트웨어 스레드가 100개가 있다고 하더라도 동시에 실행될 수 있는 스레드는 하드웨어 스레드 개수와 같다.

나머지 스레드는 실제로 일할 task 가 없어서 쉬고있거나(유휴상태) 하드웨어 스레드에 올라갈 자신의 차례를 기다리고 있다.


좋은 비유가 있어 가져와 보았다.


4코어 8스레드 라는 것은, 상하권이 나뉜 4세트의 책과 같습니다. 

이 4세트를 가지고 도서관에서 100명의 사람에게 빌려 줄 수 있습니다. 

비록 한번에 읽을 수 있는 사람은 8 사람 밖에 없지만요.




*리눅스를 기준으로 보충 설명


clone 과 fork는 새로운 프로세스를 생성한다는 관점에서는 비슷하지만,

fork 는 사실 clone() 시스템 콜이 레이어드 되어 있는 라이브러리 함수이다.

fork가 전체 메모리 주소 공간을 복사한다는 것은 예전 방식이고 현재 리눅스에서는 

fork는 copy-on-write방식을 사용하여 프로세스 생성 시 모든 자원을 복사하는 것이 아니고 

변경사항이 생길 경우에만 복사하도록 구현되어 있다. 


fork와는 다르게 clone()은 자식 프로세스가 실행 컨텍스트를 호출 프로세스와 공유할 수 있게 해준다.

예를 들어 메모리 공간, 파일 디스크립터 테이블, 시그널 핸들러 테이블 등을 공유한다.

clone의 주 사용처는 공유되는 메모리 공간에서 동시에 실행되는 쓰레드 구현이다.

리눅스에는 실제 스레드라는 것이 없고, clone함수를 이용하여 프로세스를 생성하면 

자식 프로세스가 부모 프로세스의 메모리 영역을 공유 한다. 

즉 fork는 별도의 공간을 할당한 뒤 부모 프로세스 영역의 값을 복사하는 형식인 것에 반해 

clone은 메모리 공간 자체를 공유한다. 물론 코드 영역도 공유한다. 

이것이 가지는 의미는 자식 프로세스에서 어떤 메모리 영역의 값을 변경시키면 

부모 프로세스에서도 그 영역을 공유하므로 부모 프로세스 직접적으로 영향을 준다는 사실이며

이것이 곧 스레드의 특성과 매우 흡사하다



그럼 결국 멀티 프로세스와 멀티 스레딩은 물리적인 개념뿐만 아니라 소프트웨어적인 개념이라는 것도 이해가 될 것이다.

위에 예시에서 유튜브를 보면 댓글을 달 때 이 기능을 수행하기 위해 멀티 스레드 방식을 사용할 지

멀티 프로세스 과정을 사용할 지 정하는 것이다. 멀티 스레드 방식을 이용한다면 같은 메모리 공간의 데이터를

공유하기 때문에 현재 실행 중인 크롬의 데이터를 받아 와서 사용하게 될 것이다.

하지만 멀티 프로세스의 경우 새로운 메모리 공간을 할당 받고 똑같이 데이터를 복사해서 저장한 후에

그 새로운 프로세스 내에서 어떤 작업을 수행하고 또 뭐 프로세스 간에 통신을 하고 그런 식이겠지. 
 

멀티 프로세싱은 프로세스를 여러 개로 늘려 여러 개의 프로그램들을 병렬 및 병행 처리하며

멀티 스레딩은 하나의 프로그램 안에서 논리 스레드를 늘려 병렬 및 병행 처리하는 것이다.

쉽게 말하면 병렬 및 병행 처리의 대상이 프로세스냐 논리 스레드냐의 차이인 것이다.

프로세스일 때와 논리 스레드일 때 각각의 장단점이 있고 필요에 따라 알맞게 사용하는 것 뿐이다.

이제 부족한 물리 스레드 공간에 대해서는 병행처리로 이어 나갈 것이다.

처리 방식은 병행처리,병렬처리는 둘 중 하나! 이게 아니고 os가 이렇고 코어,스레드가 무한하지 않는 한 언제나 동반되는 것이고

병렬처리는 코어 하나가 감당해야 할 병행처리를 코어와 물리 스레드를 늘림으로서 나타난 녀석이라고 볼 수 있다. 

그러니 멀티 코어 또는 멀티 스레드 프로세서가 아니라고 해서 멀티 프로세싱과 멀티 스레딩을 못 쓰는 건 아니다.

왜냐면 둘은 처리 방식의 일종이기 때문에 만약 싱글 코어 싱글 스레드 프로세서 에서 멀티 프로세싱이나 멀티 스레딩을 이용한다면

이 상황에서는 병렬처리는 있을 수 없으니 병행처리만 일어날 것이고 병행처리 대상이 프로세스 또는 논리 스레드가 되는 것이다.




둘의 차이점

메모리 영역의 차이가 있는데 멀티 스레딩은 메모리 영역중에 스택 부분만 구분하고 나머지는 공유한다.

멀티 프로세싱은 새로운 메모리 공간을 할당 받는다.


스택 부분만 구분하는 이유는 

stack을 스레드끼리 공유한다면 선입후출의 특성을 가진 스택에 여러 스레드의 작업이 섞여 더 복잡해진다.




