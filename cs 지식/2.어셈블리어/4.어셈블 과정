


어셈블 과정은 어셈블러의 종류에 따라 나뉘지만


현재는 대부분 이중패스 어셈블러를 사용 중이니

이중패스 어셈블러를 기준으로 말해보겠다.




이중 패스 어셈블러는 총 두 번 코드를 스캔한다.


1. 첫 번째 스캔


어셈블리어 코드 전체를 위에서부터 아래로 스캔하면서 LABEL이 표시된 줄을 찾는다. 

찾으면 그 LABEL이 어떤 메모리 주소에 해당하는지를 심볼 테이블(Symbol Table)이라는 곳에 기록한다. 

# 첫 번째 스캔에서 심볼 테이블에 레이블에 대한 메모리 주소와 이름을 저장해 놓기

어셈블러는 코드 첫 부분의 .ORIG에 명시된 메모리 주소를 기준으로 각 줄의 메모리 주소를 알아낼 수 있다.

# '.ORIG 메모리 주소'는 offset 0이 되는 지점이라고 할 수 있다.


이렇게 각 LABEL에 대응되는 메모리 주소를 알아낸 뒤에는

다시 처음부터 코드를 스캔하면서 다음 과정을 진행한다.



2. 두 번째 스캔


첫 번째 스캔에서 만들어낸 심볼 테이블의 정보를 바탕으로 어셈블리 코드를 ISA 명령어로 번역한다.

두 번째 스캔 과정에서는 각 어셈블리어 명령어에 적혀 있는 LABEL들이 

어떤 메모리 주소인지 알고 있기 때문에 바로 0과 1로 이뤄진 명령어로 번역할 수 있는 것이다.

# 한 줄 한 줄 기계어로 전환하는데 레이블이 사용된 지점 보다 밑에서 정의되면 오류가 나겠지?
# 하지만 첫 번째 스캔에서 심볼 테이블에 레이블에 대한 메모리 주소와 이름을 저장했기 때문에
# 그걸 토대로 레이블을 이용하면 돼서 문제가 안 됨.
# 단일 패스 어셈블러 였다면 문제가 생겼겠지. 이중 패스 어셈블러를 많이 사용하는 이유이기도 해.

