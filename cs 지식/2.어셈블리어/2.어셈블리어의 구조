


어셈블리어는 기본적으로

어셈블리어는 레이블 : 명령어 : 오퍼랜드 : 주석 의 형태를 갖는다.



1. 레이블


레이블이란 인스트럭션이나 데이터의 위치를 표시해 주는 것이다.
  
':'로 표현을 하는데, 그러니까 어떤 곳에서 레이블에 접근하려고 하면 그 곳으로 보내주는 거임.

예를 들면 c언어의 스위치가 있겠지?

case 1:
case 2: 이렇게 막 케이스별로 두잖아 이게 다 레이블인 거임.

switch()의 괄호 안에 들어오는 숫자랑 같은 케이스로 이동시켜주는 거잖아.

레이블이란 이거임.

레이블은 어떤 인스트럭션이나 데이터의 위치를 표시하고 그 위치로 접근하려 하면

그 코드가 있는 곳으로 보내주는 거지.


또 에러가 있는데.

raise ValueError 하고나면 exception ValueError: 레이블 이름과 같은 코드로 이동시키는 거야.

ValueError를 발생시키고 ValueError:(레이블)이 있는 곳으로 이동


어셈블리어에서도 어떤 특정 레이블에 접근하게 만들기 위해 레이블을 붙여주는 건데.

만약 레이블에 대한 접근이 나중에 필요하다 싶으면 레이블을 주면되고 아니면 말고임.


*여기서 매우 중요 궁금증 다 해결됨)

그래서 왜 이 레이블이라는 게 필요하고 이중 패스 방식을 사용하느냐

만약 우리가 어떤 값에 대해 함수를 실행하게 만들었어.

어떤 값에 대해 레이블을 통해 함수로 이동하게 하겠지?

이 값에 대해 어떤 레이블이 있는 곳으로 가서 계산 좀 하고 오세요. 이렇게.

근데 만약 내가 이 레이블을 값 보다 밑에다 적었다면 어떻게 될까.

단일 패스 형식으로 어셈블을 했다가는 레이블이 정의가 안 돼 있으니

계산이 안되겠지? 그래서 필요한 게 바로 이 이중 패스 어셈블러야.

한 번 레이블에 대해 싹 한 번 흝어서 심볼 테이블에 레이블 메모리 주소를 이름이랑 같이 

저장해 놓는 거지. 그래서 다음에 한 번 더 스캔할 때에는 레이블이 밑에 정의돼 있어도

어차피 첫 번째 스캔에서 그 레이블의 주소값을 심볼 테이블에 저장해 놓았으니까

그 위치로 가서 계산하고 오면 되겠지? 두 번째 스캔 때에는 이런 방식을 통해서

바로 기계어로 올바르게 변환할 수 있는 것이야.



2. 명령어(Instruction, Mnemonic Code)


명령어는 ISA의 Opecode(명령어)부분을 문자로 나타낸 것이다.

각 프로세서별 ISA가 지정하는 명령 코드를 1:1 대응하여 나타낸 것이라고 생각하자



ISA에 담겨 있는 Opecode



3. 오퍼렌드(operand)


명령어의 주체가 되는 것들이라고 할 수 있다.

한 마디로 명령어 실행의 주체가 되는 녀석들이다. 

오피코드는 '~해라' 오퍼렌드는 '~을' 이라고 볼 수 있다.



4. 주석


주석은 말 그대로 주석이다. 설명을 보충할 때 옆에 적어주기 위해 쓰는 것.

