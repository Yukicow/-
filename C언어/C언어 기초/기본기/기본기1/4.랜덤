


1. rand()

rand() %숫자의 형태로 쓰인다.

범위는 0~숫자 -1 까지이기 때문에 

숫자의 범위를 포함하려면 +1을 해주어야 한다.

ex) 

rand() %10 + 1

0~10까지의 범위

그리고 사용 전에는 #include <stdlib.h>로 헤더파일을 불러와야 한다.

그리고 난수 초기화라는 것을 해주어야 하는데

랜덤함수를 사용해 보면 처음 랜덤으로 생선된 값이 계속 반복돼서 출력되는 걸 볼 수 있다.

이 걸 이해하기 위해서는 컴퓨터에서 난수를 어떻게 생성하는 지에 대한 이해가 필요하다.


2. 컴퓨터에서의 난수

난수란 정의된 범위 내에서 무작위로 추출된 수를 일컫는다. 난수는 누구라도 그 다음에 나올 값을 확신할 수 없어야 한다.

의사난수란 난수는 아니나 난수로 취급이 가능한 수열을 지칭한다. 

보통 난수를 만들 수 없는 컴퓨터 등에서 난수를 사용하기 위해서 만들어진 수열이다.

컴퓨터에서는 특수한 하드웨어 없이 완전한 난수를 생성할 방법이 없기 때문에 보통 의사 난수를 사용한다.

생각 외로 컴퓨터는 난수를 간단히 만들 수 없다. 

컴퓨터는 사람과 달리 무의식적인 선택, 또는 우연에 의하는 선택을 할 수 없기에 

기본적으로 정해진 입력에 따라 정해진 값을 낼 뿐이다.

랜덤은 랜덤이지만 이게 완전한 랜덤이 아니고 어떤 규칙에 따라 지정되는 랜덤이라고 볼 수 있다.

그 규칙은 정해져 있지만 우리가 규칙을 딱딱 맞춰서 사용할 수 있는 게 아니기 때문에 완전한 랜덤과 비슷한 효과를 낼 수 있는 것이다. 

흔히 난수표를 쓰는데 난수표가 정해진 이상 결국은 같은 순서로 같은 숫자가 나온다.

이를 해결하기 위하는 방법은 난수표를 여러 개 만들어 놓고 매번 다른 난수표를 읽히는 것이다.

이 난수표를 선택하게 만드는 값을 '시드'라고 한다. 시드에 따라 난수표가 정해지는 것이다.

근데 문제는 결국 시드라는 것도 랜덤으로 정해져야 한다는 것이다.

그래서 보통은 시드값으로 현재 시간을 넣어서 해결한다.

위의 rand()함수도 마찬가지다. rand()함수는 받은 시드값에 따라 난수표 결정하고 랜덤 숫자를 출력해주는 함수이다.

근데 rand()함수 자체에 시드를 받는 게 아니고 srand() 라는 녀석이 시드를 대신 받는다.

한 마디로 srand()함수가 받은 시드값에 따라 rand()함수가 출력하는 값이 달라진다.

두 개를 합쳐서 하나의 함수로 쳐 만들지 ㅄ같이 따로 만들어서 시드 따로 받고 출력 따로한다.

그래서 rand() 함수를 이용해 진짜 난수같은 효과를 보려면 srand()함수에 변하는 시드를 입력해 줘야 한다.

이 때 이용되는 것도 보통 시간이다. 그래서 time()함수를 이용해 시간을 받아와 값을 넣어주는 것이다.

time() 함수는 1970년 1월 1일 0시(UTC)부터 현재까지 흐른 시간을 time_t 타입(초단위 정수 자료형)으로 반환을 한다.

컴퓨터가 난수를 생성하는 방법은 시간 외에도 컴퓨터가 켜져 있는 시간,마우스 움직임,키보드 누른 간격 등등 수도 없이 많다.

그러니 C언어 rand()함수를 정말 시간 값만으로 초기화하는, 수십 년도 더 된 알고리즘을 쓰는 프로그램들은 문제가 된다고 보아도 무방하다.

여러 개선책이 있지만 근본적으로 시드를 기반으로 한 랜덤함수는 완전한 무작위라고 보기가 힘들다. 

특정 패턴의 경우 영원히 안 나올 수도 있다. 

하여튼 좋은 알고리즘도 있는데 c/c++ rand()함수는 언어의 역사만큼 오래된 안 좋은 랜덤 알고리즘을 쓰고 있다.

시간을 이용한 난수 표현이 개 구대기인 이유는 예측이 쉽다는 것이다.time 함수는 1초 단위로 수가 바뀌기 때문에

프로그램이 실행될 때 어떤 랜덤한 값을 만든다고 하면 이 때 프로그램이 실행된 시간을 알면 초 단위로 프로그램이

진행된 시간 만큼 대입하면 암호를 알아낼 수도 있다. 보안에 취약하다는 것이다.

그리고 c언어에서 난수표를 ㅄ같이 만들어서 그런 건지는 모르겠는데 1초당 보통 값이 3~4가 증가하는 규칙성이 있다.

이러면 난수에 가까운 의사난수라고 볼 수 없다. 시간에 따른 규칙성이 너무 뚜렷하기 때문이다.

그래도 최근 프로그램들은 최대한 의사난수가 난수와 가깝게 쓰일 수 있게 알고리즘이 잘 짜여져 있다는 듯 하다.

그럼 이제 rand()와 srand()함수를 같이 쓰는 이유는 이해가 됐을 것이다.


아 맞다 근데 tiem 함수에 unsigned int를 쓰는 것도 있고 아닌 것도 있던데 뭐죠?

아직 잘은 모르는데 unsigned int라는 거는 음수가 없는 0과 양수만 나타내는 int라고 하는데

이게 원래 srand()함수가 받는 인자가 unsigned int 자료형이더라고. 그래서 아마 자료형을 맞추려고 그런 게 아닐까.

근데 어차피 시간값은 양수이니까 굳이 안 써도 잘 작동 하는 거고? 

# 사실 확인은 나중에 해 보자


또 질문.

근데 왜 값으로 NULL을 넣는 건가요?

time()함수는 인자로 변수의 메모리 주소를 받아. 포인터 매개 변수 거든.

그리고 받은 메모리 주소 안에 1970년 1월 1일 0시 부터 현재까지 흐른 시간을 초단위로 반환해 주는 녀석이야.

그러니 NULL을 이용할 경우 메모리 주소에 값을 직접 넣는 게 아니고 현재까지의 시간만 반환하는 거지.

그래서 변수 선언 그리고 초기화를 이용하면 그 변수 안에 그 값이 들어가지만 변수를 선언만 해놓고

그 안에 나중에 값을 넣을 때에는 그 변수의 메모리 주소를 직접 넣어줘야 한다 이 말씀이야.

예시)

time_t a = time(NULL);

time_t b;

time(&b);

위의 a와 b는 서로 다른 방식으로 값을 저장한 거지. 

time()함수를 이용해 값만 따로 반환하고 변수에 저장하느냐 아니면 애초에 

time()함수를 그대로 이용해 변수의 메모리 주소를 받아 안에 값을 반환해주냐.

메모리 주소를 받는 이유는 이제 이해하지? 참조에 의한 호출을 해야 값을 넣어줄 수 있기 때문이야




3. %숫자를 사용하는 이유.


랜덤 함수에서 rand()는 원하는 범위를 정하고

숫자를 하나 뽑을 수 있는 기능이 아니다.

rand() 함수는 0 ~ 32767까지의 숫자를 랜덤으로 생성한다.

그래서 뒤에 %를 이용해 나머지를 구하는 것이다.

어떤 값을 어떤 수로 나누었을 때 어떤 수의 최대 나머지는 그 수보다

1 작은 숫자가 된다. 쉽게 말해서 어떤 숫자를 5로 나누려고 한다면

어떤 숫자가 랜덤으로 등장했을 때 가능한 최대 나머지는 4라는 것이다.

5는 5로 나누어 떨어지고 그 이상 부터는 다시 나머지가 1로 돌아오니까.

예를 들어 보자 내가 19로 37을 나누면 나머지는 18이다.

이 원리를 적용해 rand()로 난수를 뽑고 %숫자를 이용해 

그 나머지 값으로 랜덤 범위로 정하는것이다.

특정 숫자가 나올 확률이 조금 높다고?

물론 rand() 함수가 무한한 숫자중 하나를 뽑는 게 아니기 때문에

조금은 확률에 차이가 있을 수 있다. 하지만 아주 미세하다.

만약 나누는 수를 크게 지정하면 좀 크게 차이가 날 수 있다.

예를 들어 rand() % 30000 이라고 하면 0부터 30000 까지는 모두 한 번씩이다.

하지만 뒤의 30001~32767까지에 대한 나머지의 즉 1~2767은 다른 숫자들에 비해

확률이 두 배가 되는 것이다. 그래도 그렇게 큰 차이는 아니고 

아마 이걸로 차이가 날 만큼 뭔가 코드를 짤 일은 아직 없을 것이다.


위의 방법 보다 더 좋은 방법이 있다고 하는데 아직은 모르겠다. 나중에 다시 찾아 보자