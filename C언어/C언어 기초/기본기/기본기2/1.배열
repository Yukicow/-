



배열(Array)


배열(array)은 "같은 타입"의 변수들로 이루어진 유한 집합으로 정의됩니다.

배열을 구성하는 각각의 요소들을 배열 요소라고 부르고 배열에서 위치를 가리키는 숫자를 인덱스(index)라고 한다.

index는 0부터 시작하며 0과 양의 정수만을 가질 수 있다.

배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조이다.

배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있다.

하지만 현실적으로 이해하기가 쉬운 2차원 배열까지가 많이 사용된다.


배열은 변수[] = {}의 형식으로 사용된다.

[]안에 배열의 크기를 정해줄 수 있다. 예로 [5]는 배열 요소가 최대 5개가 들어갈 수 있다.

만약 [5]로 5개의 공간을 정하고 2개의 요소만 넣는다면 나머지 3개의 자리에는 0이라는 값이 들어간다.

하지만 아무 요소도 넣지 않고 배열만 만들어 두면 더미값이 들어간다.

참고로 [] 안에 들어가는 것은 무조건 상수이어야 한다. 

근데 상수인 숫자 자료형 데이터를 갖는 변수를 이용해도 오류가 난다. 무조건 숫자를 직접 넣어야 하는 듯 하다.

근데 아주 신기하게도 동적할당을 해줄 때에는 변수로도 됨ㅋㅋㅋ 이건 나중에 더 배우면 자세히 설명.


배열에서 배열의 요소들은 각각 메모리 공간을 할당 받는 데이터들이다.

이 때 배열 요소들은 메모리 주소를 연속으로 할당받는다.

이게 무슨 말이냐 하면 만약 문자열 hello 에서 h가 100이라는 메모리 주소에 저장되면 e는 101의 주소에 저장된다.

# char은 1바이트를 차지하기 때문에 1이 증가하지만 int는 4바이트이므로 104가 될 것이다.


*중요)

이 때 문제점이 있다. 자세한 내용은 기본기1 -> scanf와 printf 부분 참조.



배열의 변수는 배열의 가장 첫 번째 배열 요소의 메모리 주소의 이름이다.

라고 보는 것 보다 내 개인적으로는 늘 말하지만 변수는 메모리 공간의 이름이다.

배열의 변수도 마찬가지로 메모리 공간의 이름인데 그 메모리 공간이 배열 전체의 크기인 것이다.

그리고 그 전체 메모리 공간을 첫 메모리 주소(base adress)를 기준으로

배열요소의 개수만큼 자료형의 크기에 맞게 분할해서 인덱스를 0부터 부여한다.

하지만 이 때 변수의 포지션이 애매한데 만약 변수가 호출되었을 때 많은 값 중에 무엇을 출력해 주는가 이다.

그래서 아예 메모리 주소(base adress)를 출력한다. 그리고 그 주소는 주소 자체이고 단순 숫자나열이 아니다.

한 마디로 배열의 변수는 기본 패시브가 &가 되어 나온 상태라고 보면 된다. 주소로서만 사용될 수 있다는 것.

근데 포인터 배열 보면 index값으로 *를 안 쓰고 값에 바로 접근하던데 그건 어떻게 하는 건가요?

그건 포인터 변수가 배열의 메모리 주소를 갖고 있기 때문이다. 배열은 [인덱스]를 통해 배열 요소에 접근할 수 있다.

만약 포인터로 배열을 정의 했다고 가정해 보자.

int a[3] = {1,2,3};
int *ptr = a;

이 때 a는 메모리 주소를 가리키기 때문에 포인터와 문제 없이 호환이 된다.

근데 a의 요소들에 접근할 때 a[]로 접근할 수 있다. 그럼 ptr은 포인터 변수니까 값을 호출하려면 *를 붙여서

*ptr[]로 하면 되겠네요! 왜냐면 ptr[]로 접근하면 메모리 주소가 나올테니까요!

으음~ 노노노 잘 생각해 보렴 배열의 특성이 뭐지? 인덱스가 있지. 다른 변수를 포인터로 지정하면 메모리 주소를 통해

값에 접근하려면 *를 쓰면 되지만 배열은 그냥 []만 써주면 되잖아.


잘 봐 바. ptr이 뭐지?

a의 메모리 주소요.

그치?

그럼 ptr만 놓고 보면 a랑 같은 값을 가지는 거네?

네

그럼 그냥 ptr == a 즉 그냥 똑같은 거네?

그쵸

그럼 왜 굳이 *을 붙여서 접근하지? ptr 자체가 a랑 똑같으면 a[]랑 ptr[]도 똑같은 거 아닌가?

헉..


배열 포인터 변수는 배열 변수의 메모리 주소값을 갖는다. 꼭 기억하도록

그래서 배열 포인터가 변수에 *를 붙이고 출력하면 배열 변수의 첫 번째 배열요소에 해당하는 값이 출력 돼.

배열 포인터 변수는 배열 변수의 메모리 주소(= 첫 번째 요소 메모리 주소)랑 똑같으니까.

그러니 배열 포인터는 배열 포인터의 특성을 물려 받아서 []가 써지네 뭐네 그런 개념이 아니고

그냥 배열 포인터 변수가 배열 변수랑 똑같기 때문에 배열 변수처럼 []로 접근이 가능한 거야.

대신 포인터이기 때문에 배열 변수랑 다르게 *로 메모리 주소에 대해 값에 접근할 수 있다는 거지.

문제는 *로 접근 가능한 게 첫 번째 요소 하나라는 거지만. 하지만

printf("%d", *(a + 숫자)) 이런 식으로 사용하면 배열처럼 다른 요소에 접근 가능하다.



그리고 당연하게도 메모리 주소를 가리키지만 변수이기 때문에 다른 메모리 주소를 가리키는 변수와 바꾼다고 값이 바뀌지 않는다.

c언어의 변수는 레퍼런스랑 다르기 때문에 변수가 한 번 지정받은 곳에서 바뀌지 않고 안의 데이터 값만 바뀌니까.

이 변수가 넘겨주는 게 메모리 주소에 대한 데이터이기 때문에 포인터처럼 동작할 수 있지만 

메모리 주소가 동작하는 거지 변수가 동작하는 게 아니다. 이게 무슨 말이냐. 포인터와는 다르다고 말하는 것이다.

만약 배열 변수가 포인터와 똑같다면 배열 변수와 &배열 변수를 출력했을 때 다른 값이 나와야 한다.

포인터라면 배열에 대한 메모리 주소를 따로 메모리 공간에 저장하고 그 메모리 주소를 이용하니까.

하지만 배열 변수와 &배열 변수는 같은 값을 가진다. 

결국 배열 변수는 일반 변수이고 변수가 넘겨 주는 값이 메모리 주소인 것 뿐이다. 

포인터는 포인터 변수와 &포인터 변수가 다른 값을 가진다. 

그래서 포인터 변수에 다른 값을 넣으면 &포인터 변수에 있는 데이터인 메모리 주소가 달라진다.

한 마디로 포인터 변수가 가리키는 메모리 주소가 바뀌고 바뀐 데이터를 이용할 수 있는 것이다.

근데 만약 똑같이 배열 변수에도 저 짓을 해서 배열 변수에 다른 값을 넣어 버리면

&배열 변수 안에 있는 데이터가 바뀌어야 하는데 배열 변수와 &배열 변수는 같다. 즉 자기 자신이기 때문에.

그냥 안에 있는 데이터를 초기화해 바꾸어 버리겠다는 의미랑 같다. 사실 포인터도 변수라서 원리는 같다.

하지만 배열은 상수다. 요소에 접근해 값을 바꿀 수는 있지만 전체를 재초기화 한다는 건 불가능하다.

그리고 설령 바뀐다고 하더라도 배열 변수의 데이터로 메모리 주소가 들어가는 게 전부이다.

배열 변수에 &를 써서 주소값을 바꾼다고?

그건 어떤 변수든 간에 다 안되는 거잖아..포인터도 &포인터 변수의 값을 바꾸는 건 불가능함..



쉽게 말하면 배열 변수는 배열 전체를 묶은 것을 나타내고 변수가 호출될 때

그 안에 데이터가 여러개이니 그것의 base adress를 데이터 대신 보내는 것.

그럼 첫 번째 배열 요소 데이터를 보내면 되지 왜 base adress를 보내는가 하면.

만약 그렇게 되면 배열 변수는 배열로서의 위치가 애매해진다. 배열 변수를 부를 때마다

첫 번째 요소 데이터를 부르면 배열인 지 그냥 하나의 자료형 데이터인 지 구분도 안되고 

애초에 []를 쓰면 되는데 뭐하러 똑같은 걸 또 줌 다른 걸 주면 되지.

그리고 주소로 주면 좋은 게 []처럼 쓸 수 있는 경우가 있는데

바로 위에서 말한다 *를 이용하는 것이야.

printf("%d", *(a + 숫자)) 이런 식으로 명령어를 적으면

배열 a의 첫 번째에서 + 숫자 뒤의 요소값을 출력하도록 사용할 수 있지.


# 이걸 보고 파이썬 리스트의 원리가 궁금해 졌다면 파이썬 -> CPython -> 리스트 원리를 참고