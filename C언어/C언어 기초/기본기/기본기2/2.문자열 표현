


c언어에는 문자열에 대한 자료형이 없다.

대신 문자열의 표현 방식에는 두 가지가 있다.


배열을 이용한 문자열 표현과 포인터를 이용한 문자열 표현이다.



1. 배열을 이용한 문자열 표현


배열의 변수는 가장 첫 번째 요소에 대한 주소값을 갖는다. 이는 변수[0]의 주소를 말한다.

# 이는 배열의 시작점을 알기 위함이지 포인터와는 다른 개념이라는 듯  하다.

배열이라는 것이 같은 자료형 변수를 연속적으로 나열하는 것이니

배열을 이용해 문자열을 표현할 경우 각 문자 하나하나가 데이터가 되는 것이다.

배열로 문자열을 표현한 것은 h,e,l,l,o 라는 char 데이터를 하나하나 저장한 것과 같아서

데이터를 변화시키는 것도 자유자재이다.


*중요)

문자열의 경우 마지막을 알리는 null문자(\0)가 들어가는데 이는 글자 수 하나를 차지하니 주의할 것



2. 포인터를 이용한 문자열 표현


문자는 ''로 문자열은 ""로 표현하는 건 알고 있지?

문자열에 대한 자료형은 없지만 문자와 문자열이 구분되는데 ""를 이용하지.

""라는 것은 참 신기한 녀석이다.

""로 우리가 문자열을 생성하면 문자열은 배열처럼 나란히 메모리 주소를 가지면서 생성 된다.

""에서 ""의 역할은 생각 보다 중요했다. ""는 [""의 안에 있는 문자열이 있는(시작하는) 주소값]을 나타낸다.

한 마디로 ""자체로 주소값을 나타내게 만들어 준다는 뜻이다.


printf("%d \n", "sentence") 


를 실행해 보면 알 수 있다. 어떤 특정 숫자가 나온다.

이는 ""라는 것이 ""안에 있는 sentence라는 문자열이 저장된 메모리 시작 주소 값을 나타내라 라는 의미다.

한 가지 더 예시를 들면 사실 printf()함수에서 함수가 받는 인자는 메모리 주소값이다.

printf() 근데 우리는 아무 생각 없이 "" 안에 문장을 넣으면 문장이 출력되는 구나! 하고 썼지만 사실 그런 간단한 문제가 아니었다.

""는 ""안에 있는 문자열의 메모리 주소의 시작점을 나타내는 부호였던 것이다. 마치 &가 메모리 주소를 불러오는 것처럼!

그리고 우리는 이렇게 ""로 문자열을 만든 것을 문자열 리터럴이라고 부른다.

# 리터럴은 소스 코드 상에서 고정된 값을 가지는 것을 일컫습니다.


핵심은 c언어는 문자열 리터럴을 문자 배열 취급한다는 것이다. 그렇기 때문에 당연히 인덱스 값도 갖고 배열처럼 이용된다.

하지만 문제는 이런 문자열 리터럴은 '리터럴'이기 때문에 프로그램 실행중 값이 변경되면 안 된다.

그래서 사용자가 정의한 상수나 이런 리터럴에 대해서는 따로 공간을 지정하는데 이 곳은 읽기 전용 공간이다.

값을 읽어드리는 것 까지는 허용하나 변경하려는 시도가 있다면 프로그램을 강제 종료한다.

그래서 이렇게 문자열 리터럴로 정의된 문자열은 변경이 불가능하다.

이게 문자열 리터럴과 배열을 이용한 문자열 생성의 차이점이다.

배열은 문자열이 아니고 문자 하나하나의 데이터 모임이기 때문에 값을 바꾸는 게 자유다. 리터럴이 아니라는 뜻이다.


근데 배열 문자열에서도 char a[3] = "no" 이런 식으로 ""로 표현하잖아요. 

저렇게 정의된 배열 문자열은 알아서 컴파일러가 char a[3] = {'n','o','\0'} 로 해석한다고 하네. 

일단 입력 자체는 문자 하나가 아니니까 문자열로 입력은 하는데 컴파일 과정에서 컴파일러가 앞에 a[3]을 보고

아 배열로 만들려고 한 거구나 이해하고 알아서 해석하는 듯 하다.


그래서 만약 다차원 문자열 배열을 만들 때에 안에 있는 값 하나하나를 다 바꿀 수 있게 하고 싶으면

원래 생각한 것 보다 배열을 하나 더 추가해주면 된다. 그럼 문자열에서 문자 하나하나가 배열요소 취급돼서

그 값들을 바꿀 수 있게 된다.


예시)

char* a[2][2][4] = {{"se","Sfw"},{"Gge","Geg"}};

char* a[2][2] = {{"se","Sfw"},{"Gge","Geg"}};

위에 것은 문자열들 문자 하나하나 조차도 문자열로 취급 받고

밑에는 위에서 말한 대로 문자열 리터럴로 정의된다.

배열 요소가 만들어진 문자열에 대한 주소값까지만 갖기 때문.



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 주의 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

참고적으로 VS(vsc아님) 2017 이상에서는 리터럴을 char* 가 가리킬 수 없습니다. 

반드시 const char* 가 가리켜야 하며

덕분에 리터럴을 수정하는 괴랄한 짓을 컴파일 단에서 막을 수 있습니다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


어쨋든 그럼 이제 왜 포인터를 이용해서 문자열을 표현하는 지 알겠지?



결론)


""가 문자열 시작 메모리 주소를 나타내니까 첫 번째 문자에 대한 메모리 주소를 받아서 포인터 변수에 저장을 한다.

포인터 변수이기 때문에 첫 번째 문자에 대한 메모리 주소를 갖는 하나의 새로운 메모리 공간을 갖는다.

포인터를 이용해 문자열을 만들면 그 값은 리터럴이 되기 때문에 바꿀 수가 없다(읽기 전용 공간으로 간다)  

# 최근에는 아예 초반부터 const char*를 사용하게 패치됨.

그래서 포인터를 이용한 문자열에서 변수가 가리키는 값을 바꿀 때에는 

아예 포인터 변수가 가리키는 값을 새로 초기화를 해야 한다. 

포인터이기 때문에 포인터가 가리키는 변수는 바꿀 수 있다. 아예 다른 값을 가리키는 거지만.



그리고 둘 다 모두 변수가 메모리 주소를 나타내기 때문에 scanf()에서 변수에 &없이 사용하는 이유이기도 하다.