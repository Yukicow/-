




포인터는 메모리 주소를 가리키는 자료형을 말한다. 포인터 변수는 다른 변수들 처럼 메모리 공간을

할당 받고 안에 메모리 주소를 데이터로 갖는다.

안의 데이터는 그냥 주소에 대한 값일 뿐이다. 포인터는 이 변수가 메모리 주소를 가리키는 변수라는 것을

구분하기 위한 녀석이라고 생각하면 된다. 마치 int는 이 변수가 정수형이라는 걸 알리 듯이.

그래서 모든 포인터 변수의 데이터는 &를 사용해 받아온 값이다.

&는 메모리 주소 그 자체를 출력하는 것이기 때문에 그냥 숫자랑은 다르다.

그래서 &를 사용한 데이터는 다른 숫자와 연산이 불가능하고 

연산은 아니지만 포인터를 이용할 때 메모리 주소값에 수를 더하면 

그 메모리 주소의 다음 메모리 주소를 가리게 사용할 수도 있다.

예를 들어 int a 의 메모리 주소가 100이면 *(&a + 1)는 104에 있는 메모리 주소의 데이터를 불러온다.

# 이게 정확히 맞는 지는 모르겠는데 일단 배열에서는 이게 맞음
# 만약 배열이 아니고 일반 메모리 주소에서 +1을 하면 바로 다음 메모리 주소값을 주는 지 아니면 랜덤하게 주는 지 모름.

일반 그냥 숫자일 뿐이라면 정수형과 다를 것도 없고 메모리 주소라는 인식을 못 한다.


메모리 주소에 *를 이용하면 그 메모리 주소의 값이 출력된다.

포인터 변수 안에 들어가는 데이터를 마음대로 초기화할 수 있다.

처음에 a의 메모리 주소를 포인터 변수가 저장하고 있었는데 b주소로 바꾼다고 하면

다른 변수에 데이터가 초기화 되듯이 안에 있는 메모리 주소의 데이터만 바뀐다.



포인터 배열에 관해서.


배열은 배열의 시작 주소값을 받고 그 주소값을 토대로 인덱스로 나눠서 접근하지.

그래서 배열에 접근하려면 '주소' 그 자체가 필요해.

근데 포인터는 안에 있는 데이터를 '주소'로 만들어 준다고 했지?

그래서 포인터 변수를 호출하면 자신이 가진 '주소' 데이터를 넘겨 줘.

그럼 넘겨받은 '주소'는 배열의 변수와 똑같은 역할을 할 수 있지.

그래서 포인터 배열 변수는 배열 변수와 똑같이 쓰일 수 있는 거야.


ex)

int a[3] = {1,2,3};

int *b = a;

b는 a의 시작 주소값을 데이터로 갖는 그냥 변수인데

여기에 int* 로 포인터 선언이 됐기 때문에 단순 int형 정수값이 아닌 주소 그 자체로 보존할 수 있지.

그래서 b를 호출하면 a의 b에 저장된 a의 '시작 주소' 데이터를 넘기니까. 

마치 a를 그냥 사용하는 것과 똑같이 작동하는 것이야.

그래서 a[0] = b[0] 이라고도 볼 수 있지.


그럼 포인터 배열과 일반 배열은 크게 의미가 없는 것 아닌가요?

내 개인적인 생각인데 포인터 배열이 빛을 발하는 건 다차원 배열부터 인 것 같아.

특히 배열과 포인터를 이용한 문자열에서 더더욱.

포인터는 변수이기 때문에 그 자체로 변수야. 그래서 포인터로 문자열을 표현하면

우리가 흔히 쓰는 변수의 배열처럼 사용할 수가 있지.

하지만 배열을 이용한 문자열 표현은 배열이 하나가 더 필요해져.

예를 들어볼까?


{{"hi","yes","go"},{"mon","dad","bro"}}

이걸 표현하려면 일반 배열로는 어떻게 표현할까?

3개짜리 배열이 두 개 있으니까 [2][3]이겠지.

라고 생각하면 오산이다. 왜냐하면 문자열은 배열이기 때문에 문자열에 대한 배열도 고려해야돼.

배열 요소중 글자 수가 가장 많은 게 3개니까 일단 배열에 대한 공간은 최소 4는 확보해야겠지?

그래서 [2][3][4]가 필요해.

물론 값에 접근할 때에는 [][] 두 개만 써도 문자열 전체에 접근은 가능하지.

하지만 선언이 안 돼. 문자열의 문자 하나하나에 대해서도 배열 공간을 요구하거든.

근데 포인터를 이용하면 아주 편리하지.

포인터는 주소값만을 가지기 때문에 포인터로 문자열 배열을 만들면

[][] 두 개만 가지고 선언이 가능해. 왜냐.

포인터는 문자열에 대해서 문자열의 시작주소만 알면 되기 때문에 굳이 문자열의 문자

하나하나에 대해서 신경쓰지 않아도 된다. 문자열을 묶어서 하나의 요소로 볼 수 있다는 뜻이지.

그래서 {{,,},{,,}}이면

{}가 두개 인데 그 안에 요소가 문자열인데 문자열의 시작 주소만 알면 되니까

요소가 3개라고도 볼 수 있는 거지. 3개짜리 요소를 갖는 배열이 2개 즉 [2],[3]이야

그래서 포인터로 배열을 이용하면 int *a[2][3] 이렇게 선언이 가능하지.

그리고 문자열은 그 자체로 배열의 특성을 갖기 때문에 문자 하나에 접근할 때에는

뒤에 []를 하나 더 붙여서 접근하면 돼. 단 포인터로 선언한 문자열은 상수이기 때문에 값의 변경은 못 하지.


결론)

포인터 배열은 포인터가 변수이기 때문에 다른 변수들처럼 배열을 이용할 수 있다.
