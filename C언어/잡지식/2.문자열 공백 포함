



문자열 공백 포함


문자열을  입력 받을 때 공백을 포함시키고 싶을 때가 있을 것이다.

보통 gets,fgets를 많이 사용하지만 scanf에서도 사용이 가능하다.


바로 []를 이용하는 것이다.

scanf()를 쓸 때에 ()안에 % 부분에 []를 넣어주는 것인데

[]는 []안에 있는 문자만 읽어들이라는 뜻이다.

만약 %[1] 을 했다면 입력 값이 1이 아닌 다른 값이 들어오면 바로 잘라버린다.

예를 들어 1115551332254411 이렇게 값을 입력했다고 해 보자.

그럼 앞에 111만 출력된다. 5뒤에 1이 있기는 하지만 []의 의미하는

그 안에 있는 값이 입력되는 경우만 이라는 뜻이기 때문에 다른 경우가 들어오면 칼같이 자른다.


이것의 반대가 있는데 바로 [^]이다. ^를 적어주면 [] 뜻이 반대로 행해진다.

[]안에 있는 것이 나오면 자른다 이다.

정확히는 []안에 있는 것을 제외하고만 받아들인다 이지만 위처럼 이해하는 게 훨씬

편하고 더 맞는 말 같다. []는 안에 있는 값이 아니면 자름. [^]는 안에 있는 값이면 자름.


그래서 어떤 문자든 간에 다 받아들이게 하기 위해서 \n을 넣어준다.

\n는 줄바꿈이다. 근데 c언어에서 입력을 받을 때 엔터키를 누르면 입력을 마친 것으로 받아들인다.

결론은 \n 나오는 경우의 수는 없다는 것이다.

그래서 %[^\n]를 사용하면 엔터 누르기 전까지 어떤 문자든 다 받아들일 수 있다는 뜻이다.


근데 이 때 알아야 할 게 하나 있는데 바로 버퍼라는 개념이다.

우리가 입력한 값들은 프로그램에게 전달 되기 전에 입력 버퍼에 잠시 저장되는데

이 때 모든 데이터가 다 읽히지 않고 입력 버퍼에 남아있는 경우가 있다.

# 이유는 여러 가지 인 것 같지만 정확히는 모르겠다..
# 배열이나 변수 크기 보다 큰 값을 입력하면 전부 담지 못 하고 남게되는 것 같은데 이상하게 적게 담아도 이런 경우가 있다.


하여튼 이렇게 입력 버퍼에 값이 남게 되면 문제가 생긴다. 우리가 엔터를 치고 나면

\n에 대한 정보가 입력 버퍼에 저장되는데 \n은 가장 마지막에 저장된다. 

왜냐면 엔터를 치면 처리가 끝나니까. 당연히 마지막이겠지.

그래서 입력 버퍼에 데이터가 아직 남아 있다는 것은 \n를 포함한 값들이 남아 있다는 것이다.

이 때 다음 명령어에 입력 데이터를 받는 명령어가 있을 때 문제가 생긴다.

아무 값도 입력 안 했는데 입력 버퍼에 남아 있는 데이터를 보고 가져가기 때문이다.


당연히 엔터(\n)에 대한 입력 버퍼를 받을 때 까지 가져갈 것이다.

그래서 전에 다 전달되지 못한 데이터들이 그 명령어에 전달되는 것이다.

그래서 우리는 이런 경우를 막기 위해 사용하는 것이 입력 버퍼를 지우는 과정이다.

입력 버퍼를 지우는 과정은 여러가지가 있다. 밑에 예시들을 보자.



1. 간단하게는 getchar(); 를 추가하는 걸로도 가능

하지만 getchar()는 뒤에 \n만 남았을 때 사용가능 하다. 

getchar()가 한 번만 작동하기 때문이다. 만약 입력 버퍼에 a\n a와 \n이 남아 있다면 

getchar()는 a를 받고 상쇄된 다음 사라질 것이다. 

// 쉽게 상쇄라고 했지만 정확히는 getchar()가 a라는 입력을 받고 아무 것도 수행하지 않고 끝나기 때문이다.

그럼 아직 \n은 입력 버퍼에 남아 있다.

이렇게 입력 버퍼에 있는 모든 값을 초기화 하기 위해서 getchar()를 조금 응용하는 방법이 있다.

바로 while(getchar() != '\n'); 이다

이것은 입력 버퍼에 있는 데이터들이 계속해서 getchar()에 들어간다는 뜻이다.

getchar()의 값이 \n 일 때까지 말이다. \n은 가장 마지막에 있으니 마지막에

\n를 받고 나면 while문을 탈출하고 입력 버퍼는 모두 상쇄되어 있을 것이다.

나는 이게 제일 깔끔하고 좋아 보인다.



2. fflush(stdin); 추가그런데 이건 gcc에서 안돌아간다. 왜? 당연히 안된다. 

표준 fflush함수는 출력버퍼를 비우는 녀석이다.VC에서는 확장해서 사용하므로 동작하지만 gcc는 안된다.



3. tcflush(0, TCIFLUSH); 추가0번 디스크립터를 비워라. 그런데 이는 유닉스 계열에서 터미널과 관련된 함수인 듯



4. rewind(stdio); 추가rewind함수는 매개변수로 들어온 스트림을 초기화하는데 사용



5. __fpurge(stdin);이놈도 리눅스에서만 동작하고 표준은 아니다. stdio_ext.h 추가.



6. fgets(string, sizeof(string), stdin);

문자열 입력을 scanf가 아니라 fgets로 받는다. 그러나 입력시 사이즈를 오버하면 똑같은 문제가 발생한다.

그리고 사이즈를 오버하지 않더라도 문자열 끝에 개행문자가 추가된다.

그래서 다음 줄에string[strlen(string)-1] = '\0'; 로 강제로 널문자를 넣어준다.



7. scanf("%*c", c);%*c는 입력은 받지만 저장은 안한다. 

즉 비어있는 \n를 날려버린다.



8. scanf("%c", &c);를 scanf(" %c", &c); 로%c 앞에 공백을 추가하면 white space를 구분자로 인식한다.




