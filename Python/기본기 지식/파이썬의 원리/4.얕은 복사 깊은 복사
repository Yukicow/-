


얕은 복사와 깊은 복사


파이썬에서는 불변객체와 가변객체가 함수 호출 방식이 다른 call by assignment를

적용하고 있다는 걸 알 거야.


근데 여기서 문제 되는 게 바로 가변객체인데.

가변객체에 대해 어떤 함수를 실행했는데 그 값이 변경된다면 참 곤란할 것이다.

값이 변하지 않게 하려면 어떻게 해야 할까.

원하는 가변객체와 똑같은 값을 가지는 다른 변수를 만들어서 사용하면 되지 않을까?

그런데 여기서 예시를 들어보자.

단순히 새로운 변수를 만드는데 정보가 몇 개 없는 변수면은 a = [1,2,3] b = [1,2,3]

이렇게 간단하게 만들 수 있지만 그 안에 정보가 무수하게 많으면 저걸 언제 다 쓰고 자빠졌냐.

그렇다고 b = a 이런 식으로 선언해버리면 b는 a와 같은 주소를 바라보기 때문에

같은 값에 대해 처리하게 될 거고.

그래서 알아야 하는 객체를 복사하는 함수인 copy함수인데

이걸 사용하기 전에는 얕은 복사, 깊은 복사에 대해 알아야 한다.



1. 얕은 복사


얕은 복사는 말 그대로 복사를 얕게 하는 것이다.

이게 뭔 개소리냐고?

만약 리트스 l1 = [1,[2,3]]이 있다고 해보자.

내가 l2라는 변수를 만들어서 l1과 같은 값을 갖게 하려고

l2 = l1[:] 라고 선언했어. 이러면 새로운 리스트가 만들어 지는 거니까

당연히 다른 주소값을 가지겠지?

근데 다른 주소값을 가지는건 가장큰 리스트 대괄호[]에 대해서 만이야.

안에 있는 객체들은 같은 주소값을 가진다는 거지.

id(l1) 과 id(l2)는 서로 달라 근데 id(l1[0])과 id(l2[0])은 서로 같은 주소를 가져

여기서 질문. 같은 값을 복사할 때 불변객체는 그렇다 쳐도 가변객체는 메모리 공간을 새로 가져야 하는 거 아닌가?

맞아 원래라면 a = [1,[2,3]] 과 b = [1,[2,3]]은 리스트에 대한 메모리 공간도 안에 있는 [2,3]에 대한 메모리 공간도 다 달라.

근데 객체를 복사를 할 때에는 이게 달라져. 객체를 복사를 하게 되면 리스트 자체는 메모리 공간이 새로 할당되는데.

안에 있는 객체들은 레퍼런스를 그대로 따라가. 이렇게 안에 있는 객체들이 레퍼런스를 그대로 따라가는 걸 얕은 복사라고 하는 거고.


이제 밑에 예시를 통해 얕은 복사가 왜 문제가 되는 지 알아 보자.

이게 지금은 l1[0] 이랑 l2[0] 가 불편객체라서 값이 바뀌어도 문제가 없거든?

왜나면 어차피 불변객체라 값이 바뀌면 주소값도 달라지니까 어느 한 쪽에서 값이 바뀌어도

서로 영향을 안 미쳐. 밑에 예시를 봐 바.

l1 = [1,[2,3]]

l2 = copy.copy(l1)

만약 위에 l1 이 어떤 과정을 거쳐서 l1 = [5,[2,3]] 이 돼버렸다고 쳐 보자.

l1 이 바뀌었는데 l2가 같이 바뀔까? 당연히 안 바뀌지.

l1[0]과 l2[0]의 주소값이 같았어도 숫자가 바뀌면서 l1[0]의 레퍼런스는 바뀔 거야.

이 말은 [] 안에 있는 불변객체와 새로 생기는 값들은 문제가 없다는 거야.

# 밑에 처럼 새로 생기는 값을 객체에서 불러온 거면 같은 주소를 가리키니 문제가 됨.

l1 = [1,[2,3]]

l2 = copy.copy(l1)


l1.append([4,5])

l2.append(l1[2]) # l1에 있는 [4,5] 리스트 데이터를 받는 것이기 때문에 같은 레퍼런스를 가리킴.

print(id(l1[2])) = print(id(l2[2]))


-> 

l1.append([4,5])
   
l2.append([4,5]) # 위가 아닌 밑에 처럼 쓰면 새로운 객체가 생성된 거라 다른 레퍼런스를 가리킴.

print(id(l1[2])) != print(id(l2[2]))



근데 여기서 만약 l1[1]이랑 l2[1]의 경우면 어떨까..?

지금 l1[1]이랑 l2[1]은 리스트 값이잖아 가변객체란 말이지..?

그리고 l1[1]이랑 l2[1]은 얕은 복사를 했기 때문에 서로 같은 레퍼런스 값을 가져.

그럼 어떤 경위로 l1[1]이 변형 돼버리면 어떻게 될까?

당연히 l2[1]에도 영향이 가지. 같은 레퍼런스 안의 값이 바뀐거니까.

가변객체는 같은 안에 있는 값이 바뀔 수 있다고 했잖아.

서로 같은 주소를 가리키는데 어느 한 쪽이 값을 바꿔버리면 다른 한 쪽도 바뀐 값을 가리키는 거야.

한 마디로 얕은 복사는 껍데기 주소값만 바뀌고 속에 있는 객체들의 주소값은 서로 같은 상태라는 거지.


여기서 주의할 점)

가변객체의 값이 바뀌거나 새로 생기거나 없어지는 건 서로 영향을 미치는데

가변객체가 완전히 재할당 되는 건 영향을 안 미침. 왜냐 재할당 되면 주소값도 바뀌니까.

예시)

l1 = [1,[2,3]]

l2 = copy.copy(a)


l1[1] = [4,5]

이런 식으로 아예 값이 재할당 되면 새로운 객체가 생성되고 가리키는 주소값도 바뀌어 버리니 영향이 없음. 

리스트 자체가 바뀌어 버리는 건 상관이 없다는 거임. 객체의 자체의 체인지니까.

print(id(l1[1])) != print(id(l2[1]))




그래서 이걸 방지하기 위한 게 깊은 복사라는 것인데.

깊은 복사는 안에 있는 객체들도 다 하나하나 복사해서 아예 다른 객체로 만들어 버리는 것이다.


copy.deepcopy()의 형태로 쓸 수 있는데 

이렇게 하면 본체와 같은 값을 가지는 완전히 다른 객체가 되는 거지.

그래서 이렇게 복사된 객체는 이리저리 마구마구 쓰여도 본체에는 영향이 없어.
