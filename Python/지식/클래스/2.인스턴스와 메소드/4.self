
self 에 대해서

보통 self는 그냥 메서드에서 처음에 무조건 써야하는 거라고 배우지만 정확히 알아보자.

self 는 해당 함수를 호출한 객체를 말하는 것이다. 밑에 설명을 보며 알아가 보자.



일단 먼저, 메서드에 self를 쓰면서 함수를 호출할 때에는 self값을 왜 안 넣는가.

def av(self, name, power) # 메서드에 self, name, power가 들어감

happy.av(name, power) # 그런데 happy라는 인스턴스에 av 함수를 호출할 때 self를 안 넣음

그것은 메서드에 self를 사용하면 self에 대한 값은 파이썬이 자동으로 넘겨주기 때문이다.

'객체.함수' 형태로 함수를 호출하면 인스턴스에 대한 정보를 self에 자동으로 입력해주는 것.



class abc: 
    def fuc():
        print("")

    def fuc2(self):
        print("slef의 주소 : ", id(self))

print("클래스의 주소 : ",id(abc))

a = abc()

a.fuc2()

print("인스턴스의 주소 : ", id(a))


이렇게 하면 

인스턴스와 self의 주소가 똑같이 출력된다.

위에서 self 에 인스턴스의 정보가 자동으로 들어간다고 했죠?

이 때 정보를 집어 넣는 게 아니라 인스턴스 그 자체를 집어넣는 거라고 볼 수도 있을 것 같음.

인스턴스 = self 니까 메서드 내에 객체 자체를 집어 넣어서 함수 내에서 사용하는 거지.

어떻게 보면 포인터랑 비슷한 거임. 인스턴스의 주소값을 받아서 그 정보를 아예 편하게 쓰는 것.


그럼 여기서 self를 가장 먼저 쓰는 이유를 잠깐 짚고 넘어가자.

self가 있으면 자동으로 self값을 넘겨준다고 했지? 그리고 그걸 인식하기 위해서는 무조건 self가 처음에 쓰자고 약속했다고 생각하면 됨.

약속을 안 해놓으면 self라는 변수가 있는데 뒤에 self라는 변수를 썼을 때 얘를 새로운 변수 self인지 아니면 

인스턴스를 의미하는 건지 구분을 할 수 없기 때문이야.




클래스에 정의된 함수는 self 없이 함수 그 자체만으로도 사용이 가능한데.

예를 들면 

class abc: 
    def fuc():
        print("function1")

    def fuc2(self):
        print("function2")

a = abc()


여기서 abc.fuc() '클래스.함수'의 형태로 함수를 호출하면 정상적으로 function1이 출력이 돼.



근데 'abc.fuc2()' 라고 하면 어떻게 될까?

오류가 뜨지. 

self가 받아 줄 정보를 보내지 않아서 그래.

파이썬이 자동으로 인스턴스를 보내야 되는데 함수를 호출한 객체가 인스턴스가 아니니 오류가 뜨는 거지.

그래서 괄호 안에 다른 변수들 처럼 self에 보낼 값을 직접 넣어주면 됨.

abc.fuc(a) 이렇게.



반대의 경우는 'a.fuc()'가 있겠지? 이 경우에도 오류가 나.

a.fuc() 같은 경우는 a에 대한 정보를 자동으로 메서드에 넘길 때, 이 정보를 받을 변수 self가 없기 때문이야.


결론은 메서드를 호출할 때 '인스턴스.함수'를 사용할 경우 메서드에 인스턴스 정보를 받아 줄 self가 꼭 필요하고 

굳이 인스턴스 정보가 필요 없는 함수라면 '클래스.함수'로 호출하는 방법도 있다는 거지. 


결론)

메서드에 self가 있는 상태일 때.

abc.fuc(인스턴스, 변수들) 와 a.fuc(변수들)는 같은 것이다.

메서드에 self가 없을 때.

클래스.함수() 형태로 사용하거나 그냥 메서드에 self를 넣어서 써.




자 그럼 이제 self를 왜 사용하는 지에 대해 정리를 해보면

메서드에서 self는 호출한 객체 자체를 넣는 것이라고 볼 수 있어.

메서드에서 self를 이용해 객체를 받아줌으로서 객체에 있는 정보도 불러내고 새로운 정보도 입력할 수 있는 거지.

예를 들어서


class abc: 

    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def pri(self):
        print("{0}, {1}".format(self.name, self.age))

    def pri2():
        print("{0}, {1}".format(self.name, self.age))

a = abc(5, 3)  

a.pri()


이거 하나만 봐도 설명이 된다.

__init__ 에서 self를 안 쓰면 입력한 name과 age에 대해 a라는 인스턴스에 정보를 입력하는 self.name과 self.age가 작동을 안 한다.

그 전에 오류부터 뜨겠지만.

밑에 pri 라는 함수도 self로 a에 대한 정보를 불러오지 않으면 self.name 과 self.age를 인식하지 못 한다.

예를 들어 'abc.pri2()'를 시전하면 인스턴스 정보가 없으니 출력 오류가 난다는 것.




결론)

self를 사용해 인스턴스를 불러와야만 어떤 정보를 새로 저장하거나 저장된 정보를 출력할 수 있음

어떤 함수에 대한 함수를 출력할 거면 무조건 self와 함께 사용하면 됨.

self가 인스턴스 그 자체를 불러오는 거라고 했는데 이게 맞는 말일 수 있는게 self를 사용한 변수값들은 값이 달라지면

달라진 값도 인스턴스에 저장이 되기 때문임. return으로 반환할 필요가 없음.

self.변수 = ~~ 이런식으로 앞에 self.을 붙여주면 지금 self로 불러낸 인스턴스 안에 변수를 선언하거나 불러내겠다 라는 의미이다.



