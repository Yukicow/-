

import의 문제점.


import는 파일 정보를 불러낸다는 개념보다는 파일이 한 번 실행되면서 정보가 저장되는 개념임.

그래서 모듈을 불러올 때에 모듈일 한 번 실행되기 때문에 

모듈 안에 있는 불필요한 내용까지 같이 실행이 되기도 한다.

예를 들면 add.py 라는 모듈이 있는데 여기에는 더하기 함수가 들어 있다.

그리고 모듈 자체적으로 input()을 통해 숫자를 받고 값을 구하는 명령어가 있다고 해 보자.

내가 만약 더하기 함수를 사용하려고 이 모듈을 불러 내면 input()이 실행되며

값을 입력하라는 메시지가 나올 것이다.

이런 불필요한 문제를 해결하기 위한 것이 if __name__ == "__main__" 이라는 조건문이다.

__main__은 파일 자기 자신을 의미한다. 

한마디로 모듈에 if __name__ == "__main__"을 사용하면 다른 파일에서 모듈을 사용할 때

모듈을 불러온 형식이기 때문에 __main__이 아니게 된다. 

따라서 모듈에 if __name__ == "__main__"이 붙은 부문은 실행을 안 하게 될 것이다.

그럼 결론적으로 아까 위에서 모듈 내에 input()을 실행하는 부분이 있다고 했는데

그 부분 위에 if __name__ == "__main__" 조건을 달아주면 모듈을 자체 실행할 때에는

input()이 실행되고 다른 파일에서 모듈을 불렀을 때에는 실행이 안될 것이다.




2. import의 정확한 원리


파이썬의 import는 c언어에서 '#include'의 역할과 비슷하지만 엄연히 조금 다르다.

c언어에서는 '#include'가 말 그대로 파일을 현재 코드내에 쫘악~ 한 번 실행하여 

저장하는 식으로 진행되는데, 말 그대로 다른 파일을 현재 파일에 삽입하는 형태인 것이다.

하지만 파이썬의 import는 별개의 3단계의 처리를 수행하는 실제 실시간 연산이다.


1. 모듈 파일 찾기

2. (필요하면) byte 코드로 컴파일

3. 정의한 객체를 구축하기 위해 모듈 코드를 실행


이렇게 세 가지가 있는데 하나씩 알아 보자.


3 단계 모두 프로그램 실행 중에 모듈을 가져오는 첫 시기에만 수행된다는 점을 유의해야 한다. 

프로그램에서 동일한 모듈을 나중에 가져오면 이 모든 단계는 건너뛰어 실행되며 

메모리에 이미 로드 된 모듈 객체를 단순히 가져오게 됩니다. 


파이썬은 sys.modules라는 이름의 테이블에 '로드된 모듈'들을 저장함으로써 

이 일을 하며 import 연산 시작 시에 테이블을 검사합니다. 

만약 모듈이 존재하지 않으면, 3단계 처리를 시작합니다. 


1. 파일 찾기

파이썬에서 모듈을 import 하면 그 모듈을 찾기 위해 아래와 같은 sys.path의 경로들을 탐색한다.


1. 실행된 모듈의 경로

2. 환경변수 PYTHONPATH에 지정된 경로

3. Python이 설치된 경로 및 라이브러리의 경로


2. 컴파일


모듈 로딩을 빠르게 하려고, 파이썬은 __pycache__ 디렉터리에 

각 모듈의 컴파일된 버전을 모듈이름.version(버전).pyc 라는 이름으로 캐싱한다. 

version 은 컴파일된 파일의 형식을 말한다. 일반적으로 파이썬의 버전 번호를 포함한다. 

예를 들어 CPython 배포 3.3 에서 spam.py 의 컴파일된 버전은

__pycache__/spam.cpython-33.pyc 로 캐싱 된다. 
 
이 명명법은 서로 다른 파이썬 배포와 버전의 컴파일된 모듈들이 공존할 수 있도록 한다.


파이썬은 두 가지 상황에서 캐시를 검사하지 않습니다. 

1. 명령행에서 직접 로드되는 모듈들은 항상 재컴파일하고 그 결과를 저장하지 않는다. 

2. 소스 모듈이 없으면 캐시를 검사하지 않습니다. 

소스 없는 (컴파일된 파일만 있는) 배포를 지원하려면

컴파일된 모듈이 소스 디렉터리에 있어야 하고 소스 모듈이 없어야 합니다.

#이 부분 아직 이해가 안 되니 나중에 다시 보자.



3. 모듈 실행

Import 연산의 최종 단계는 모듈의 바이트 코드를 실행하는 것이다. 

파일에 있는 모든 명령들이 위에서 아래로 차례로 실행되며

이 단계에서 이름에 행해진 모든 할당은 결과 모듈 객체의 속성을 생성합니다. 

이것이 모듈에 의해 정의된 도구들이 생성되는 방법입니다. 


import 와 from import

hi 라는 모듈이 있다고 해보자

import hi

이렇게 한다고 hi에 정의된 함수들의 이름이 현재 심볼 테이블에 직접 들어가지는 않는다.

오직 모듈 이름 hi 만 들어갈 뿐이다. 이 모듈 이름을 사용해서 함수들을 액세스할 수 있다

그래서 import만 사용하는 경우 파일 안에 있는 함수나 객체등 정보를 불러올 때 

파일 이름을 함께 사용하는 것이다.


from import는 위 import의 변종인데

from이 패키지,모듈 등을 받아주고 import가 변수,함수를 써주는데

import가 실행되면 현재 심볼 테이블이 아닌 다른 심볼 테이블을 만들고 그 안에 정보를 저장한다.

그래서 다른 심볼 테이블 안에 있는 정보를 불러내기 위해 파일이름.~~ 이런 식으로

파일 이름을 함께 사용하는 것이라고 위에서 얘기했다.

from import의 경우 지역 심볼 테이블에 임포트되는 모듈의 이름을 만들지 않는다.

한 마디로 모듈에 대한 새로운 심볼 테이블이 만들어지는 게 아니라는 것이다.

import 뒤에 오는 함수들이 전역 심볼 테이블에 저장되는 것이죠. # 일단은 그렇다고 예상중 확신x

그래서 파일이름을 같이 써서 호출할 필요가 없는 겁니다. 

그 말은 즉슨 함수가 본 코드 내에 존재하는 게 되기 때문에 그 코드에 의해 오류가 발생하면

코드 전체를 기준으로 보게 되는 것과 같아서 문제가 많음.

다른 심볼 테이블에 저장되는 형식의 import 방식은 불러낸 함수에서 오류가 나면

그 부분에 대해서 딱 알 수 있음.




뭔가 나중에 도움 될 내용)


참고 효율성의 이유로, 각 모듈은 인터프리터 세션마다 한 번만 임포트됩니다. 

그래서, 여러분이 모듈을 수정하면, 인터프리터를 다시 시작시켜야 합니다 —

또는, 대화형으로 시험하는 모듈이 하나뿐이라면, importlib.reload() 를 사용하세요. 

예를 들어, import importlib; importlib.reload(modulename).



자세한 것은 나중에 고수가 되고 이 사이트를 다시 보자

목차 6.2~6.3
https://docs.python.org/ko/3/tutorial/modules.html#compiled-python-files