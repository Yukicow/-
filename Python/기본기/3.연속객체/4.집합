

집합(set).


set(집합)은 '{}'를 이용하면 된다.

사전과 같지만 사전은 키값을 포함하고 집합은 포함하지 않는다.


s1 = {1,2,3}


또는 

s1 = set([1,2,3])

print(s1)

-> {1, 2, 3}


위와 같이 set()의 괄호 안에 리스트를 입력하여 만들거나 

다음과 같이 문자열을 입력하여 만들 수도 있다.


s2 = set("Hello")

print(s2)

-> {'e', 'H', 'l', 'o'}

# 비어 있는 집합 자료형은 s = set()로 만들수 있다.


자, 그런데 위에서 살펴본 set("Hello")의 결과가 좀 이상하지 않은가? 

분명 "Hello" 문자열로 set 자료형을 만들었는데 

생성된 자료형에는 l 문자가 하나 빠져 있고 순서도 뒤죽박죽이다. 


그 이유는 set에 다음과 같은 2가지 큰 특징이 있기 때문이다.

1. 중복을 허용하지 않는다.

2. 순서가 없다(Unordered).


리스트나 튜플은 순서가 있기(ordered) 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있지만 

set 자료형은 순서가 없기(unordered) 때문에 인덱싱으로 값을 얻을 수 없다. 

만약 set 자료형에 저장된 값을 인덱싱으로 접근하려면 리스트나 튜플로 변환한후 해야 한다.


집합 함수.


1. 집합.add(변수) 값 1개 추가 # 1개만 됨

s1 = set([1,2,3,4])

s1.add("방구")

-> {1,2,3,4,"방구"}



2. 집합.update([변수]) 값 여러개 추가 # 여러개 추가할 때 리스트 형식으로

s1.update([5,6])

-> {1,2,3,4,5,6}

*주의) 

update를 통해 문자를 추가할 때에 리스트 형식을 지키지 않으면 

세트를 지정할 때 something = set("무언가") 처럼

문자가 하나하나 '무','언','가' 형태로 구분되어 저장되니 조심할 것.

input()을 통해 set를 받을 때 set([input()])라고 쓰면 집합에 단어별로 저장되고

set(input()) 형태로 쓰면 글자 하나하나 별로 저장된다.

때에 따라 필요하기도 하니 기억해 둘 것.



3. 집합.remove(변수) 값 제거 # 제거하고 싶은 값을 ()에 넣으면 된다. 1개씩만 가능.

s1.remove(2)

-> {1,3,4}




*집합의 활용)

중복을 허용하지 않는 set의 특징은 

자료형의 중복을 제거하기 위한 필터 역할로 종종 사용하기도 한다.


set 자료형을 정말 유용하게 사용하는 경우는 교집합, 합집합, 차집합을 구할 때이다.


1. & , 집합.intersection(집합) 교집합 

s1 = set([1, 2, 3, 4, 5, 6])

s2 = set([4, 5, 6, 7, 8, 9])

s1 & s2

-> {4, 5, 6}



2. | or 집합.union 합집합 # 중복된 값은 하나만 표시

s1 | s2 == s1.union(s2)

-> {1, 2, 3, 4, 5, 6, 7, 8, 9}



3. - or difference 차집합 # 앞 집합과 공통되는 부분만 뺌.

s1 - s2 == s1.difference(s2)

-> {1, 2, 3}

s2 - s1 == s2.difference(s1)

-> {8, 9, 7}
