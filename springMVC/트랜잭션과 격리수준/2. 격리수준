







격리 수준에 대해 알기 전에 데이터 정합성에 대해 먼저 알 필요가 있다.

데이터 부정합 문제에는

DIRTY READ
NON-REPEATABLE READ
PHANTOM READ 

이렇게 세가지가 있다.


1. DIRTY READ

DIRTY READ는 커밋되지 않은 데이터를 읽게 되는 것을 말한다.

이렇게 되면 트랜잭션에서 롤백이 발생해도 전에 그 데이터를 읽어서 처리를 하던 트랜잭션은 

반영도 되지 않은 데이터를 가지고 트랜잭션 처리를 한 것이 되기 때문에 문제가 발생한다.

이 문제는 쓰기-읽기 문제라고도 하는데, 쓰기를 통해서 변경된 값을 읽게되기 때문이다. 

이 때 읽어낸 그 값이 나중에 커밋이 되지 않을 수 있어 문제가 있다.


2. NON-REPEATABLE READ

NON-REPEATABLE READ는 REPEATABLE READ의 반대 개념이다.

REPEATABLE READ는 하나의 트랜잭션에서는 읽기를 했을 때 Data는 같은 값을 가져야 한다는 정합성에 대한 내용이다.

그래서 NON-REPEATABLE READ는 하나의 트랜잭션에서 읽기를 수행했을 때 다른 값이 나온다는 내용이다.


3. PHANTOM READ

PHANTOM READ는 NON-REPEATABLE READ와 비슷하다.

하지만 REPEATABLE READ 조회되는 ROW의 데이터(즉, 속성값?)이 일관적이어야 한다는 내용이라면

PHANTOM READ는 데이터를 조회했을 때 없던 데이터가 생기거나 있던 데이터가 없어지면서 달라지는 것에 대한 내용이다.

쉽게 생각하면, NON-REPEATABLE READ는 서로 다른 트랜잭션에서 UPDATE쿼리에 의한 변경이 적용되어 보이는 것을 의미하고

PHANTOM READ는 서로 다른 트랜잭션에서 DELETE, INSERT의 내용이 적용되어 보이는 것을 말한다.





위의 내용을 인지했다면 이제 격리 수준에 대해 알아 볼 준비가 된 것이다.

격리 수준의 종류에는 

READ UNCOMMITTED (커밋되지 않은 읽기)
READ COMMITTED (커밋된 읽기)
REPEATABLE READ (반복 가능한 읽기)
SERIALIZABLE (직렬화 가능)

이렇게 총 4가지가 있다.

밑으로 내려갈 수록 트랜잭션의 격리 정도가 높아진다.



1. READ UNCOMMITTED (커밋되지 않은 읽기)

READ UNCOMMITTED는 다른 트랜잭션에서 Commit의 여부와 상관없이 변화된 값을 읽고 쓰는 게 가능하도록 하는 것이다.

이 격리 수준은 SELECT문 사용 시 아무 락도 요청하지 않기 때문에, Lock Manager를 통해 요청의 수락을 받을 필요가 없다.

그래서 Lock이랑은 관계가 없는 SELECT가 되는 것이다. 아무 때나 조회가 가능하다 이말이다.

쓰기는 무조건 배타락이 걸린다고 했다. 이는 동시성 문제를 해결하기 위해 어쩔 수 없는 부분이다.

하지만 쓰기가 진행중이든 말든 SELECT는 아무 때나 조회가 되기 때문에 아직 COMMIT되지 않은 경우도 자유롭게 읽을 수 있다.

딱 봐도 문제가 많아 보이는 격리 수준이다.

이 격리 수준에서는 DIRTY READ, NON-REPEATABLE READ, PHANTOM READ가 모두 발생한다.


당연히 커밋되기 이전의 데이터도 읽을 수 있도록 해놓았기 때문에 DIRTY READ가 발생한다.

또 하나의 트랜잭션 내에서 여러번 읽기를 시도했을 때, 다른 트랜잭션에서 데이터를 변경한 내용이 그대로 보이기 때문에

NON-REPEATABLE READ 또한 당연히 발생한다. 그러니 PHANTOM도 발생할 수밖에 없다.


이렇게 보면 동시성 문제는 완전히 개나 줘버린 격리 수준이라고 볼 수 있다.

그래서 오라클은 이 격리수준을 지원하지 않는다.



2. READ COMMITTED (커밋된 읽기)

READ COMMITTED는 일반적으로 가장 많이 사용되는 격리 수준이다.

커밋된 데이터에 한해서만 읽는 게, 즉, DRITY READ를 피하는 게 가능하도록 하는 격리 수준이다.

이걸 구현하기 위해 SELECT구문 수행 시 트랜잭션에서 공유락을 걸도록 한다. 

이렇게 되면 쓰기를 하고 있는 트랜잭션이 있을 경우 그 데이터에 대해 공유락 요청이 거부된다.

그럼 배타락은 트랜잭션이 커밋,롤백될 때까지 이어지니, 해당 트랜잭션이 커밋이나 롤백을 통해 배타락을 해제할 때까지 읽지 못 한다.

즉, 커밋이나 롤백된 값만 읽을 수 있도록 구현이 되었다는 의미이다. 


하지만 이 격리 수준에서 공유락이 걸린 데이터는 SELECT문이 끝나면 공유락을 해제한다.

공유락을 중간에 해제하면 공유락이 해제되었을 때 다음에 배타락이 치고 들어올 수 있게 된다. 

그럼 그 배타락을 건 트랜잭션에서 뭔가 쓰기작업을 거치고 커밋을 할 경우 배타락은 해제된다.

배타락이 해제되고 이전에 읽기를 진행하던 트랜잭션이 이어서 읽기를 수행했을 때 처음과 값이 달라져 있을 수 있다는 것이다.

NON-REPEATABLE READ와 PHANTOM READ는 여전히 발생하게 된다.



오라클에서는 이 격리수준을 UNDO 영역을 통해 구현하고 있다.

일단 트랜잭션에 쓰기 작업을 수행하면 모두 DB에 그대로 반영이 된다.

문제는 이걸 반영하게 하냐 마냐이다. 

반영을 안 할 경우에는 그 전의 값으로 rollback을 해야 하기 때문에 UNDO영역이라는 걸 두고 거기에 복구할 데이터를 snapshot으로 보관한다.

그리고 트랜잭션들에게는 각각 커밋되지 않은 데이터에 대해서는 UNDO영역의 데이터를 보여 주게 한다.

구현 원리는 다르지만 동작은 비슷하다.

차이점이라고 하면 오라클의 경우는 쓰기 중에도 데이터 조회가 가능하다는 점이다.

UNDO영역을 보여 주면 되기 때문에 조회에 제한이 없다. 사실상 조회에는 락을 사용하지 않는다는 것이다.

따지고 보면 위의 READ UNCOMMITTED와 똑같이 동작하는 것이다.

하지만 UNDO 영역을 이용해서 다른 곳에더 커밋이 일어나지만 않으면 계속 같은 데이터를 볼 수 있도록 동작하는 것이다.

이렇게 하면 조회에 제한이 없기 때문에 성능이 더 좋지만 UNDO영역에 대한 관리가 필요하다는 단점이 있다.



3. REPEATABLE READ (반복 가능한 읽기)

딱 봐도 NON-REPEATABLE READ를 해결하기 위한 것이다.

이 격리 수준에서는 READ COMMITTED와 딱 하나만 다르다.

바로 SELECT 구문 후 공유락을 해제하는 게 아니라 공유락을 트랜잭션이 끝날 때까지 유지하는 것이다.

이렇게 되면 특정 트랜잭션 동안 쓰기가 불가능하게 된다.

다른 트랜잭션들에게 읽기만 허용하기 때문에 트랜잭션 중간에 값이 바뀌어서 읽히는 경우가 없어진다.

READ COMMITTED에서 NON-REPEATABLE READ 문제를 해결한 격리수준인 것이다.


오라클에서는 명시적으로 이 격리 수준을 지원하지 않는다.

하지만 FOR UPDATE라는 옵션을 통해서 이 격리수준처럼 동작하게 만들 수는 있다.

FOR UPDATE는 다른 트랜잭션이 레코드를 SELECT하지 못하게 read, write락을 거는 구문이다.

딱 봐도 '나 쓰기할 거니까 아무도 건들 ㄴㄴ' 같은 느낌이 드는 구문이다.

REPEATABLE READ와 살짝의 차이점이라면 얘는 공유락이 아닌 배타락을 걸어버린다는 것이다.




4. SERIALIZABLE (직렬화 가능)

이 친구는 REPEATABLE에서 SELECT되는 영역에 대한 ROW에 공유락을 걸던 것이

SELECT할 때 테이블 전체에 공유락을 거는 것으로 변경되었다고 보면 된다.

이렇게 되면 테이블에 INSERT도 제한되기 때문에 PHANTOM READ에 대한 문제를 해결할 수 있다.

문제는 많이 해결되었지만 동시성이 너무 제한돼서 성능은 가장 안 좋을 수 밖에 없다.





위를 이해하기는 조금 내용이 복잡하지만 오라클은 이렇게 생각하면 된다.

'읽기는 락을 사용하지 않고 쓰기는 배타락을 사용한다.'

배타락이라는 개념만 있다고 이해하고 사용하면 된다. UNDO 영역 덕분이다.

이렇게 이해하고 사용하면 좋은 장점이 말 그대로 '커밋되지 않은 데이터는 반영x 커밋된 데이터만 반영o'라고 이해하기 훨씬 편하다.


그럼 이제 오라클에서 사용하는 READ COMMITTED를 사용할 때 발생할 수 있는 문제가 이해가 될 것이다.

근데 사실 잘 보면 NON-REPEATABLE READ와 PHANTOM READ의 문제 보다는 더 심각한 문제는 이럴 때가 아닐까 한다.

바로 읽기를 한 뒤 쓰기를 해야하는 트랜잭션들에서 발생하는 문제들 말이다.

예를 들어 읽기를 통해 조회한 값이 특정 조건에 부합하는 지를 보고 쓰기를 하는 경우가 제일 문제가 많다.

읽은 값에 따라서 수행을 하는 건데 중간에 그 값이 바뀌어서 수행이 안 되거나 반대로 수행이 되는 경우가 있을 수 있다.


예를 들어 이런 경우이다. 

SELECT한 값 중에 '좋아요'속성값이 100이상이면 '등급' 속성의 값을 '노말'에서 'VIP'로 바꾼다고 해 보자.

1. 먼저, SELECT를 해서 '좋아요'값을 가져온다.

2. 그 값이 100이었다. 따라서 '등급' UPDATE를 준비한다.

3. UPDATE가 수행되기 전에 다른 사용자가 '좋아요'를 취소함

4. '좋아요' 취소에 대한 UPDATE쿼리가 배타락을 먼저 가져감

5. 속성값이 99가 됨.

6. '등급' 업데이트가 수행됨

7. '등급'이 VIP가 됨


이런 경우가 발생할 수 있다.

이렇게 데이터베이스에서 조회하는 값의 조건에 의해서 특정 쓰기 작업이 이뤄질 때가 동시성에서 제일 무서운 경우이다.

즉, UPDATE하기 전에 조회를 할 건데, 그 중간에 값이 변경되면 안 되는 경우는 다 이런 문제가 발생할 가능성이 있다.

사실 REPEATABLE READ의 경우였다면 위와 같은 일은 일어나지 않았을 것이다.

REPEATABLE READ의 경우 SELECT를 수행하고 나서 공유락이 해제되지 않기 때문에 변경될 걱정이 없기 때문이다.


하지만 오라클은 READ COMMITTED를 제공한다.

그럼 어떻게 해야 할까?

사실 여러 방법이 있다.

위에서 말한 SELECT FOR UPDATE를 사용하는 방법, 또는 쓰기 작업을 할 때 조건으로 읽은 값을 비교하는 방법 등이 있다.

뭐 이런 걸 비관적 락, 낙관적 락 이런 식으로 내용이 있는데, 이건 나중에 다루도록 하겠다.

