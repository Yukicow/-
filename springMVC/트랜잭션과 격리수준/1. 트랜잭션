





트랜잭션은 쉽게 커밋이 일어나기 전까지의 수행을 하나로 묶은 수행 단위를 뜻한다.

수행을 묶는다고 해서 뭐 크게 묶는 뭐가 있는 게 아니고 

실제로 수행 결과가 반영되도록 하는 Commit이 수행되기 전까지 하나의 트랜잭션이라고 보면된다.

우리가 실제로 DB를 사용할 때 트랜잭션을 시작하고 끝내는 것을 명시적으로 사용하지 않지만

실제로는 내부적으로 그런 과정을 알아서 처리하도록 다 담겨 있다고 한다.


데이터베이스에는 세션이라는 개념이 존재하는데,

일반적인 데이터베이스는 커넥션을 통해 연결이 맺어지면 세션을 만들어서 해당 커넥션의 요청은 해당 세션을 통해 실행되도록 한다.

# 구현 레벨에따라 다를 수 있는데, 보통 이렇다고 한다.

이렇게 세션이 커넥션마다 생성되기 때문에 같은 세션을 이용하고 싶으면 우리는 코드 내에서 같은 커넥션을 이용해야 한다.

즉, 같은 트랜잭션에 수행을 묶고 싶으면 같은 커넥션 객체를 사용해야 한다는 것이다.



이러한 트랜잭션은 4가지 원칙 A(Atomicity) C(Consistency) I(Isolation) D(Durability)를 보장해야 한다.

원자성은 트랜잭션 내에서 실행한 작업들은 모두 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다는 내용이고

일관성은 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다는 것.

격리성은 동시에 실행되는 트랜잭션들은 서로에게 어떻게 영향을 미치지 않도록 격리한다는 것이고

지속성은 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다는 것이다.


여기서 원자성과,일관성,지속성은 크게 문제가 없다.

왜냐하면 그냥 저기서 바라는대로 DBMS가 설계 되어 있고 잘 동작하기 때문이다.

근데 문제는 격리성이다.

예를 들어 위의 말대로 동시에 실행되는 트랜잭션들은 서로에게 영향을 미치지 않도록 격리해야 한다는 말에 따라서

무조건 서로 영향을 안 미치게 하려면 무조건 트랜잭션 시작 순서별로 작동해야 하며, 

현재 트랜잭션이 시작해서 끝날 때까지 아무도 같은 테이블에 접근을 못하게 해야 하기 때문이다.

이렇게 하면 완벽하게 격리성이 보장은 되겠지만, 성능에 문제가 발생한다.

# 성능이라는 문제점 때문에 우리는 이제부터 ㅈㄴ 힘든 길을 걷게될 것이다.


하지만 그렇다고 트랜잭션들에게 자유를 주게 되면, 문제가 발생한다. 

위처럼 여러 트랜잭션이 서로 같은 ROW에 동시에 접근하는 경우 크게 문제가 될 수 있기 때문이다.

경우에 수에 따라 어떤 문제가 있는 지 확인해 보자. 

두 개의 트랜잭션이 있다고 가정해 보자.


첫 번째 경우는 두 개의 트랜잭션들이 모두 같은 데이터에 접근하는데, 읽기만 수행한다고 하면 이런 경우는 문제될 게 없다.

어차피 읽기만 하는 거고 데이터가 유지되는 상태이기 때문에, 모두 같은 값을 조회만 하고 빠져나가기 때문이다.


두 번째 경우는 여러개의 트랜잭션들 중에서 누구는 읽고 누구는 쓰는 경우이다.

이런 경우 여러 가지 문제가 발생할 수 있는데, 대표적으로 DIRTY READ, NON-REPEATABLE READ, PHANTOM READ 가 있다.

뭐 대충 읽는 쪽에서 쓰는 쪽의 영향을 받아 계속 읽어내는 값이 달라지는 내용이다.


세 번째 경우는 둘 다 쓰는 경우이다.

이런 경우는 갱신 손실과 같은 문제가 발생할 수 있다. 한 쪽이 변경하는 작업이 다른 쪽에 의해 덮어 씌워지는 것이다.


네 번째 경우는 둘 다 읽고 쓰는 경우이다.

이 경우는 두 번째 경우와 세 번째 경우가 뒤섞여 난리가 날 것이다.

읽고 쓰는 일이 서로 어느 순간에 일어나느냐에 따라 위의 경우의 수들이 막 발생할 것이다.

# 지우고 생성하는 케이스는 안 쓴 이유는 대부분 지우고 생성하는 것에서 문제가 발생하는 경우는 많지 않아서 고려에서 배제한 듯?

# 정말 가끔 지우고 생성하는 것에서도 문제가 발생할 수 있을 것 같긴한데, 그건 나중에 발생하면 생각해 보자.


이러한 문제를 막기 위해서 락이라는 개념을 이용해서 동시성 문제를 해결할 수 있다.

먼저, 락이라는 개념을 알야아 한다.

락의 종류에는 여러 가지가 있지만 가장 기본적인 공유락과 배타락을 알아 보자.

락이라는 것은 동시성 제어를 위해 사용되는 개념으로 여러 세션에서 테이블이나 row, column 등에 대한 접근을 제한하는 개념이다.

# 락 설정 레벨에 따라 락의 범위가 달라진다.

트랜잭션은 락이 걸려 있지 않으면 해당 데이터에 락을 걸 수가 있다.

락을 건다는 것은 락에 대한 요청처리를 Lock Manager에게 부탁하는 것이다.

그리고 Lock Manager에 의해 요청이 수락되고 처리가 되면 그제서야 쿼리가 실행된다.

그래서 락을 건다는 표현 보다 락을 얻는다 라는 표현이 더 맞는 것 같다. 실제로 그렇게 쓰기도 한다.

데이터가 락을 가지고 있고 그 락을 가져간 트랜잭션만이 뭔가를 수행할 수 있도록 하는 개념으로 이해하는 게 더 쉽다.

락을 건다는 개념으로 이해하는 게 어려우면 락을 가져가야 수행을 할 수 있다는 식으로 이해해도 나쁘지 않다.

# 락의 범위는 SQL문에서 접근하는 데이터 범위에 락이 걸림


공유락을 걸면(얻으면) 트랜잭션은 해당 데이터에 대해 읽기가 가능해 지고 다른 세션들도 해당 데이터에 대해 읽기만이 가능해진다.

공유락의 이름이 공유락인 이유는 공유락이 걸린 데이터에 대해 여러 트랜잭션이 공유락 요청을 보내면 요청을 수용하기 때문이다.

한 마디로 같은 공유락에 대해서는 락을 공유(공유락은 무한하다)한다는 뜻이 된다.

# 이런 관점에서 보면 락을 건다는 말 보다 락을 얻는다는 말이 좀 더 맞긴 하다.

# 근데 말 그대로 '락'이라는 관점에서 보면 락을 얻는다는 게 뭔가 이상하다 ㅋㅋㅋㅋ 둘이 뭔가 안 맞음

# 락을 '권한'이라는 말고 바꾸면 딱 맞는데, 왜 Lock을 쳐 쓰고 지랄이지

그래서 여러 트랜잭션에서 공유락이 걸린 데이터에는 SELECT로 읽기 조회가 가능한 것이다.

하지만 공유락이 걸린 데이터에 배타락 요청이 오면 요청을 거부한다.


배타락을 걸면 읽기 쓰기가 모두 제한된다.

배타락은 공유락에 대한 요청을 허용하지 않는다. (공유락을 가져갈 수 없게 한다.)

그래서 배타락이 걸린 데이터에 공유락에 대한 요청이 오면 해당 트랜잭션은 배타락이 해제될 때 까지 대기상태에 빠진다.

정확히는 자신의 락 요청이 수락될 때까지이다. 

만약 배타락 요청을 한 트랜잭션이 커밋을 해서 배타락이 풀렸는데 다음 우선순위가 또 배타락일 경우 또 기다려야 하기 때문.

락을 걸고나면 트랜잭션 동안 유지를 시킬 수도 중간에 해제시킬 수도 있다.


그럼 문제는 이 락을 어떻게 걸어 줘야 할까?

그냥 무작정 모든 트랜잭션에 배타락을 걸어버릴까? 공유락을 걸어버릴까?

모든 트랜잭션을 하나하나 신경 써주면서 락을 걸까..?

그래서 이 때 격리 수준이라는 개념이 나온다.

위와 같은 고민의 중간지점을 찾아 적당한 락의 기준점을 찾고 그걸 베이스로 레벨을 나눈 것이다.


먼저, 쓰기를 할 때에는 무조건 배타락을 사용한다고 보면 된다. 

위를 보면 알겠지만 모든 문제의 근원은 쓰기가 발생하면서 시작된다.

그래서 일단 쓰기는 무조건 배타락을 사용해서 동시성을 제어하도록 하고, 읽기의 조건을 격리 수준에 따라 제어하는 것이다.

즉, 격리 수준은 락을 통해 구현된 것이라고 볼 수 있다. 물론 DB에 따라 다르게 구현하는 경우도 많다.

#오라클의 경우는 UNDO영역이라는 것을 이용해서 격리 수준을 구현한다.  DB2, SQL Server, Sybase는 위처럼 락을 통해 구현

다음 챕터의 내용은 SQL Server, Sybase에서의 구현 방식이고 오라클의 구현과 비교하면 작성할 것이다.





