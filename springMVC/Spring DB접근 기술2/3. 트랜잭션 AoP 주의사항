






트랜잭션을 사용할 때 조심해야할 것이 있다.



1. 내부 호출

@Transactional이 붙은 메소드를 호출할 때에는 AoP가 적용된 프록시 객체가 그 메소드를 호출하기 전에

트랜잭션에 대한 로직을 수행한 후에 메소드를 호출하게 된다.

그러면 이미 트랜잭션이 시작되었기 때문에 그 이후에는 어떤 로직이든 connection을 사용할 때

트랜잭션 동기화 매니저에 담겨 있는 connection을 가져와서 사용하게 되고, 트랜잭션이 문제 없이 동작할 것이다.


하지만 @Transactional이 붙지 않은 메소드를 호출한 다음에,

그 메소드 내부적으로 다른 @Transactional이 붙은 메소드를 호출한다면 어떨까?

이럴 경우에는 당연하게도 트랜잭션이 이루어지지 않는다.


@Transactional이 붙지 않은 메소드를 프록시 객체가 호출하게 되면

트랜잭션 처리를 하지 않고 실제 객체에서 메소드를 호출하게 된다.

그럼 그 메소드 내부에서 같은 객체의 @Transactional이 붙어 있는 메소드를 호출하는 로직이 있어도 

실제 객체에서 호출한 메소드 내부에서 일어나는 일과는 관련이 없다는 것이다.


이렇게 이해하면 좋다.

프록시를 적용하면, 실제 메소드를 호출하기 전에 @Transactional 여부를 판단해서 test()메소드를 호출한다고 해 보자.

@Transactional이 붙은 메소드를 호출하면 

test();
invoke(); // 실제 객체로부터 호출하는 메소드

이렇게 동작할 것이다.

이미 프록시는 test()를 통해 자신의 일은 끝났고 invoke() 메소드는 실제 객체로부터 호출된 메소드이기 때문에

실제 객체에서 메소드를 호출하는 것과 똑같이 동작한다.

invoke() 라는 메소드 자체가 하나의 동작인 것이다.

AoP는 이 동작(메소드)이 시작되거나 끝나기 전후로 어떤 작업을 하는 개념이기 때문에 그 동작 동안에는 어떤 영향도 끼치지 않는다.

왜냐면 그 동작이라는 것은 실제 객체로부터 그냥 메소드를 호출한 것 뿐이니까.


즉, @Transactional이 붙지 않은 메소드를 호출하면 test()는 일어나지 않고 바로 invoke()만 호출된다.

그렇기 때문에 트랜잭션에 대한 부분은 처리되지 않고 invoke()가 호출되는 것이고 

invoke()메소드 수행 동안은 AoP와는 관계가 없으니 같은 객체의 @Transactional이 붙은 메소드를 호출해도 아무 동작을 하지 않는다.


하지만 만약 invoke() 메소드 내부에 다른 객체의 @Transactional이 붙은 메소드를 호출한다면, 그건 얘기가 다르다.

그럴 때에는 그 메소드를 호출했을 때 그 메소드 호출을 담당하는 객체가 또 다시 다른 프록시 객체가 되는 것이고

그 객체가 트랜잭션에 대한 처리를 하고 실제 메소드를 호출하는 것이 되기 때문에 이럴 때에는 제대로 동작한다.

그래서 실제로도 위와 같은 문제를 해결하기 위해 @Transactional이 걸리지 않은 메소드를 호출한 다음에

그 메소드 내부에서 호출하는 메소드 중 Transaction이 필요한 경우에는 객체를 분리해서 @Transactional을 붙인다.

애초에 처음부터 다른 객체를 통해 메소드를 호출하는 경우면 신경써 주지 않아도 되긴 한다.





2. public

@Transactional은 public 메소드에만 적용이 된다.

이건 스프링에서 그렇게 막아 놓은 것인데, 

일반적으로 public이 아닌 메소드는 애초에 트랜잭션이 필요한 경우가 아닌 케이스가 많다고 한다.

근데 @Transactional을 클래스 단위로 붙이게 되면 모든 메소드에 @Transactional이 붙은 것으로 동작하기 때문에

불필요한 메소드에까지 @Transactional이 적용될 수 있어서 그렇다는 것 같다.

# 난 public이랑 private말고는 안 써 봐서 잘 모르겠지만


하여튼 이런 경우가 있다고 하니 private, protected, default 메소드를 사용하는데 Transaction을 걸고 싶은 경우는

직접 프로그래밍 방식을 통한 트랜잭션 처리를 하거나,

@Transactional을 단 public메소드를 하나 만들어서 그 메소드 내부적으로 위의 메소드들을 호출해 주면 된다.