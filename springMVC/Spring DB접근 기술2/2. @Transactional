







@Transactional에 대한 내용을 복습하며, 어떤 옵션들이 있는 지 알아 보자.

참고로 @Transactional은 클래스 단위에 붙어도 메소드 단위에 따로 붙여 놓은 게 우선순위가 더 높아서 

메소드에 붙은 옵션을 따라간다는 점을 미리 알아 두자.

정확한 우선 순위는 이렇다.

1. 클래스의 메소드에 붙인 @Transactional

2. 클래스에 붙인 @Transactional

3. 인터페이스 메소드에 붙인 @Transactional

4. 인터페이스에 붙인 @Transactional




1. Value

@Transactional은 TransactionManager를 이용해서 트랜잭션 처리를 하기 때문에 어떤 TransactionManager를 사용하는 지 적어 주어야 한다.

적어 주지 않으면 기본으로 등록된 TransactionManager를 자동으로 사용하지만 만약 TransactionManager가 두 개 이상이라면 꼭 명시해야 한다.

이 때 사용 가능한 옵션이 value이다. 

옵션으로 value = "빈으로 등록된 TransactionManager이름"을 적어 주면 그 TransactionManager를 통해 트랜잭션을 처리한다.

아무 옵션도 사용하지 않을 경우는 옵션의 default가 value이기 때문에 ("TransactionManager이름")이렇게만 적어 주어도 된다.



2. rollbackFor

@Transactional을 사용하면 Checked예외 발생 시 롤백을 처리하지 않고, UnChecked예외 발생 시 롤백을 처리한다.

이것은 스프링 기술 스택에서 그렇게 정해 놓은 것이고 원하면 변경도 가능하다.

Checked예외는 기본적으로 비즈니스적으로 처리가 가능할 것이라고 판단하고 그렇게 설정한 것이다.

그럼 이 때 Checked예외가 발생해도 rollback을 하고 싶다면 어떻게 해야 할까?

그럴 때 사용 가능한 옵션이 rollbackFor이다.


rollbackFor 옵션을 사용하고 값으로 예외 class를 적어 주면 그 예외와 하위 예외가 발생했을 때 rollback처리를 한다.

@Transactional(rollbackFor = RuntimeException.class) 이런식으로 사용 가능하다.

rollbackForClassName이라는 것도 있는데 클래스 이름을 직접 적는 식으로 지정하는 것이다.

사실상 동작은 rollbackFor랑 다를 게 없기 때문에 보통 rollbackFor를 쓴다.


rollbackFor의 반대 기능을 하는 noRollbackFor이라는 것이 있다.

UnChecked예외가 발생했을 때에 rollback을 시키지 않게 할 수도 있다는 것이다.

근데 일반적으로 많이 쓰이지는 않는다고 한다. 보통 rollbackFor 정도만 쓴다고 함.



3. isolation

트랜잭션의 격리수준을 지정하는 옵션이다.

기본 설정은 DB에서 사용하는 격리수준을 사용하는 'DEFAULT'이다.

READ COMMITTED, REPEATABLE READ 등 설정이 가능하다.

이 설정을 옵션으로 사용하면 해당 트랜잭션은 지정된 격리수준을 사용하여 동작하게 된다.



4. timeout

트랜잭션 수행시간에 대한 타임아웃을 초 단위로 설정할 수 있다.

기본값은 트랜잭션 시스템의 타임아웃을 사용한다.

운영 환경에 따라 동작할 수도 있고 그렇지 않을 경우도 있기 때문에 확인이 필요하다.

timeoutString이라는 것도 있는데 숫자대신 문자로 숫자값을 넣을 수 있는데 별로 안 쓴다.



5. label 

트랜잭션 어노테이션이 있는 값을 직접 읽어서 어떤 동작을 하고 싶을 때 사용할 수 있는 옵션이다.

뭐 label = "test" 이런 식으로 라벨을 달아 놓고 나중에 이 값을 읽어서 특정 수행을 하고 싶을 때 쓰면 된다.

일반적으로는 사용하지 않는다.



6. readOnly

트랜잭션은 기본적으로 읽기 쓰기가 모두 가능한 트랜잭션이 생성된다.

readOnly=true 옵션을 사용하면 읽기 전용 트랜잭션이 생성된다. 

이 경우 등록, 수정, 삭제가 안 되고 읽기 기능만 작동한다.

드라이버나 데이터베이스에 따라 정상 동작하지 않는 경우도 있다고 한다.


readOnly 옵션은 크게 3곳에서 적용된다.


프레임워크

- JdbcTemplate은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다.

- JPA는 읽기 전용 트랜잭션의 경우 커밋 시점에 플러시를 호출하지 않는다.

따라서 추가로 변경이 필요 없으니 변경 감지를 위한 스냅샷 객체도 생성하지 않아 최적화에 도움이 된다.


JDBC 드라이버

- 읽기 전용 트랜잭션에서 변경 쿼리가 발생하면 예외를 던진다.

- 읽기, 쓰기(일반적으로 마스터, 슬레이브라고 하는 듯?) 데이터베이스를 구분해서 사용하는 경우 요청을 구분한다.

읽기(슬레이브) 전용 트랜잭션의 경우 읽기 데이터베이스의 커넥션을 획득해서 사용한다.


데이터베이스

- 데이터베이스에 따라 읽기 전용 트랜잭션의 경우 읽기만 하면 되므로, 내부에서 성능 최적화가 발생할 수 있다. (DB마다 다름)



여기서 중요한 건 JPA에 대한 내용이다.

JPA에서는 readOnly옵션을 사용하면 최적화가 일어나기 때문에 사용해 주는 게 좋다.

물론 readOnly옵션을 사용하면 네트워크에서 통신과정이 일어나기 때문에 반대로 느려지는 경우가 있을 수도 있다고 하는데,

웬만하면 최적화가 일어나는 경우가 많고 느려지는 경우는 거의 없다고 한다. 

그래도 상황 마다 다르기 때문에 정확히 성능 테스트가 필요하다고는 하다.

그러니 웬만하면 JPA를 사용할 때에 읽기만 하는 경우는 readOnly옵션을 사용하는 게 좋다.





7. propagation

트랜잭션 전파 레벨을 설정한다.

트랜잭션 전파에 대한 내용을 보지 않았다면 그 부분을 보고 오자.

default는 REQUIRED이며, 
