



orElse는 Optional의 값이 null이면 실행되고 orElseGet은 null일 때만 실행한다는 것은 틀렸다.

정확히는 아래의 과정 때문에 그렇게 보이는 것 뿐이다. 



orElse는 인자로 특정 객체를 바로 받고 

return  ?  :  형식에서 그 객체를 바로 넘기는 형태이기 때문에

객체가 orElse 실행시점에 실제 존재해야 해서 orElse()의 인자로 함수를 넣으면 함수가 실행되고 나온 객체가 인자로 넘어간다.


하지만 orElseGet의 경우에는 함수형 인터페이스를 받고

return ? : 에서 return 되는 값에 함수형 인터페이스의 함수 실행을 하고 객체를 생성한 값을 return 하기 때문에 

orElse와는 다르게 Optional이 null이면 함수가 실행될 일이 없다.

당연히  ? Optional.get() : method() 의 ?의 값이 true인 시점에서는 Optional.get()이 호출되므로

method()가 호출될 필요가 없어서 실행이 안 된다.

하지만 orElse의 경우에는 객체를 인자로 받아서 직접 ? Optional.get() : Obejct  의 형태로 넣기 때문에

? 에서 false일 때에 넘겨질 객체가 미리 준비되어 있어야 하므로 

orElse에서 함수를 인자로 넣으면 그 함수가 한 번 호출되고 나온 결과값이 사용되는 것이다.


그래서 함수를 통해 특정 로직을 수행하고 객체가 생성되고 인자로 넘겨야 하는 거라면

orElse 대신 orElseGet을 사용하는 게 함수 호출의 비용이 없기 때문에 더 좋다.


그리고 이러한 원리 때문에 마치 orElseGet은 null이지 않을 때 호출되지 않는 것처럼 보이지만 그렇지 않다.

정확히는 null이지 않을 때에는 인자로 받은 함수 로직이 실행되지 않는다는 말이 맞다.