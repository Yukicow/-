




지금까지 Validator를 통해서 검증과정을 직접 처리했는데, 이것은 너무 반복적이고 귀찮은 일이다.

웬만한 검증에 대한 내용은 대부분 값이 있는 지 없는 지, 아니면 값이 유효한 지, 크기가 넘는 지 아닌 지 등처럼

너무나도 기본적인 내용들, 누구라도 사용할 것 같은 내용들을 보통 검증한다.

그래서 java는 이런 기본적인 내용들에 대한 검증은 공통화 하고 표준화해서 Bean Validation이라는 기술 표준을 만들었다.

그리고 이러한 표준을 구현한 구현체 중 하나가 하이버네이트가 있는데, 보통 이걸 많이 사용한다.


기술 표준이기 때문에 표준에 없는 내용에 대한 검증 과정은 전에 배운 내용을 토대로 따로 검증기를 만들어서 사용해야 한다.

하지만 제공되는 것이 많이 있기 때문에 웬만하면 다 Bean Validation으로 처리 가능하다.


먼저, Bean Validation을 사용하려면 라이브러리를 추가해야 한다.

스프링 부트의 gradle의 경우 implementation 'org.springframework.boot:spring-boot-starter-validation'을 추가하면 된다.

그냥 스프링에서 사용하려면 java에서 제공하는 표준과 구현체 라이브러리를 따로 추가해야 한다. 이건 검색을 통해서 알아 보자.


사용법은 간단하다.

검증이 필요한 객체의 필드에 표준에서 제공하는 어노테이션을 사용하면 그에 맞는 검증기가 알아서 검증을 진행한다.

물론 예전처럼 @ModelAttribute앞에 @Validated 또는 @Valid가 붙어 있어야만 동작한다.

이렇게 자동으로 검증이 가능한 이유는 스프링 부트에서 이러한 어노테이션을 확인하고 검증 작업을 하는 Validator를

글로벌 Validator로 등록하기 때문이다.






다음은 이렇게 Bean validation을 사용하면 에러코드와 오브젝트 오류는 어떻게 하느냐 이다.

에러코드의 경우는 어노테이션의 값이 에러코드로서 사용된다.

즉, 어노테이션을 그대로 에러코드로 사용하고 원하는 메시지를 넣으면 된다는 것이다.

예를 들어 @Range라는 어노테이션이 있다면 에러코드는 'Range'가 된다.

그럼 Range.item.itemName 이런식으로 에러코드가 제공된다.

또, 어노테이션에 옵션으로 message라는 것을 설정할 수 있는데 따로 에러코드가 없으면 default message로 사용하도록 하는 것이다.

@Range(message = "범위 오류입니다.") 이런식으로 사용할 수 있다.


오브젝트(글로벌) 오류는 @ScriptAssert 라는 것을 사용하면 된다.

하지만 그닥 좋은 방법은 아니라고 한다. 제약도 많고 복잡하고, js를 사용하는 문법이기 때문에 썩 좋지 않다.

그래서 Object 오류의 경우는 그냥 따로 검증 과정을 수행하고 bindingResult를 이용해서 처리하는 게 낫다.





Bean Validation에는 한계가 있다.

바로 검증해야 하는 내용이 여러 경우에 따라 달라지는 경우이다.

예를 들어 아이템을 등록할 때에는 수량을 999까지 입력가능하게 하고 싶은데 수정할 때에는 99개까지 하고 싶다고 해 보자.

같은 객체를 사용할 경우 수량에 대한 검증 어노테이션은 하나밖에 쓰지 못하기 때문에 각 경우에 따로 적용할 수 없다.

이러한 한계점을 극복하는 방법으로 groups라는 것이 있다.

groups는 마치 그룹을 나누는 것처럼 검증이 적용되는 그룹을 나누어 따로 적용하는 것이다.


예를 들어 위와 같은 경우에 적용을 한다고 하면

하나는 등록할 때를 구분하기 위한 클래스 나머지 하나는 수정할 때 구분할 클래스, 총 두 개의 클래스나 인터페이스를 만들고 


@Max(value = 999, groups = {Add.class}, message = "999이하이어야 합니다.")
@Max(value = 99, groups = {Update.class}, message = "99이하이어야 합니다.")
private Integer price;


위처럼 설정할 수 있다.

그리고 컨트롤러의 @Validated에 옵션으로 적용할 클래스.class를 배열 인자로 넘기면 적용이된다.

@Validated({Add.class}) 라고 하면 999이하 까지 입력 가능하고, 

@Validated({Update.class})라고 하면 99개 까지 입력이 가능해 진다.


그리고 등록이든 수정이든 똑같이 적용하고 싶은 필드가 있다면

@Max(value = 999, groups = {Add.class, Update.class}, message = "999이하이어야 합니다.")
private Integer quantity;

이런식으로 작성하면 된다. 그럼 @Validated({Add.class})를 적용하든, @Validated({Update.class})를 적용하든

둘다 같은 검증을 사용하므로 똑같이 동작할 것이다.


사실 위의 방법도 쓸 일이 있기는 하겠지만, 보통 저런 식으로 검증에 대한 부분을 구분하지 않고

아예 클래스를 두개 만들어 분리하여 사용하는 경우가 많다.

왜냐하면 등록, 수정은 사실 입력 받는 값이나 그런 건 조금 비슷할 지 몰라도 사실 완전 별개의 동작이라고 보는 게 맞다.

그래서 클래스를 두 개로 분리하고 등록할 때 사용하는 객체, 수정할 때 사용하는 객체를 나눈다.

그렇게 하는게, 적용하기도 편하고 각각의 동작에 따른 검증 과정이 더 눈에 잘 들어오기 때문에 많이 사용한다고 한다.





이 검증기, 즉, @Validated를 과연 @ModelAttribute뿐만이 아니라 @RequestBody에도 사용할 수 있을까?

결론 부터 말하면 가능하다.

따지고 보면 @RequestBody를 통해 특정 객체를 만들어 낸다고 하면,

만들어낸 객체를 검증기를 이용해 검증만 하면 되기 때문에 문제될 게 없다.

그리고 실제로 @RequestBody를 처리하는 객체도 이 검증기를 사용한다.


하지만 문제가 하나 있다.

@ModelAttribute처리된 객체를 만들기 위해 사용되는 WebDataBinder는 binding과정을 거친 후에 검증을 거치는 녀석이다.

바인딩이라는 것은 객체를 생성한 다음에 받은 인자를 객체의 필드에 setter로 주입하는 형태라는 것이다.

그렇기 때문에 setter로 값을 입력할 수 없는 즉, 유효하지 않은 값의 형태일 경우에는 TypeMismatch를 때려버리면 된다.

그리고 값에 null이나 숫자라면 0(?)을 쳐 넣으면 되는 것이다.

쉽게 말해서 @ModelAttribute의 경우는 객체가 생성된 뒤에 바인딩이 이루어지기 때문에 

필드에 값이 제대로 담기지 못하는 것인 TypeMismatch에 대한 부분을 bindingResult에 담고 Controller를 호출해도 문제가 없다.

왜냐면 객체의 필드에 값이 제대로 담기지 않았을 뿐 Controller의 핸들러 메소드를 수행하기 위한 객체 자체는 인자로 넘길 수 있기 때문이다.

하지만 @RequestBody는 json형식의 body 데이터를 받아서 그것을 바로 객체로 생성해야 한다.

한 마디로 json형식이 잘못되거나, 형식은 잘 됐는데 필드와 TypeMismatch하는 값에 대해서 입력되어 올 경우 객체 자체가 생성이 안 된다.

그래서 이런 경우는 검증 과정은 커녕 Controller 호출조차 할 수가 없다.

왜냐하면 객체가 생성되지 않았기 때문에 Controller의 핸들러 메소드에서 필요한 인자를 넘길 수 없고 그럼 호출도 불가능하다.


결론은 @RequestBody는 TypeMismatch에 대한 부분은 다룰 수 없다는 것이고, 검증과정은 커녕 Controller호출도 이루어지지 않는다.

그래서 @RequestBody에 @Validated가 적용되는 경우는 객체가 생성되고 나서 그 값이 요구사항과 일치하는 지에 대한 검증 과정 뿐이다.

예를 들어 Max값을 999로 설정한 경우와 같은 것이다.

이런 경우는 객체가 생성되고 나서 필드 값을 가져온 다음 검증기로 비교만 해 보면 되기 때문에 문제 될 게 없다.

@RequestBody를 사용해서 객체의 생성 과정이 제대로 이루어지기만 한다면 나머지는 똑같이 검증 과정이 일어날 수 있다.