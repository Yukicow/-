






쿠키는 사용자 브라우저에 데이터를 저장시키는 방법이다.

그리고 클아이언트는 서버에서 한 설정에 따라 요청을 할 때에 쿠키가 필요하다면 그 쿠키를 요청과 함께 보내게 된다.

그럼 서버측은 그 쿠키를 받아서 값을 확인하고 여러 로직을 수행할 수 있게 된다.

쿠키에는 영속 쿠키와 세션 쿠키가 있다.

영속 쿠키는 만료 날짜를 서버가 지정해서 특정 시간이 지나거나 날짜가 되면 없어지게 하는 것이고

세션 쿠키는 그냥 브라우저가 종료되면 사라지는 쿠키이다.


쿠키의 개념은 이게 전부이다. 크게 어려운 것은 없다.

하지만 사용할 때에 조심해야 할 것이 있다.

쿠키는 path를 지정하지 않으면 기본적으로 쿠키를 생성했던 URL 범위에서 전송이 이뤄진다.

예를 들어 /board/view url요청에서 쿠키가 생성되었다면 그 쿠키의 path는 /board로 지정되어 있다.

전체 url이 아닌 상위 url path가 저장된다. 즉, /board가 url이면 /가 path로 저장되는 것이다.

이렇게 되면 문제인 게, 쿠키가 중복될 수 있다는 것이다.

같은 이름의 쿠키라도 path가 다르면 다른 쿠키로 인식되기 때문에 서로 다른 url에서 생성되어 path가 다르게 저장되면

같은 이름의 쿠키 두 개가 브라우저에 저장된다.

그래서 쿠키를 생성할 때에는 path를 꼭 지정해야 한다.


근데 생성할 때만 path를 지정한다고 끝나는 게 아니다.

우리가 만약에 기존의 쿠키를 새로운 value를 갖도록 덮어 씌우고 싶다면 같은 이름의 response.addCookie로 쿠키를 추가할텐데, 

이 때에 기존에 있던 쿠키를 iterator로 돌려 뽑아서 그대로 add하는 경우가 많을 것이다.

이 때에도 path를 지정해 주어야 한다. http스펙에서는 쿠키의 name값과 value값만을 제공하기 때문에

Cookie의 path와 같은 다른 값들은 항상 초기화되기 때문이다.

그래서 완전히 같은 쿠키로 인식시키려면 path나 다른 값들을 똑같이 맞춰야 한다. (age 제외)

다시 쿠키를 response에 추가할 때, path를 지정해 주지 않으면 null이 들어가기 때문에 

브라우저에 저장된 path를 갖고 있는 cookie와는 다른 쿠키로 인식되는 것이다.


그리고 이 path는 쿠키가 보내지는 url이기도 하다. 

path에 지정한 url( + 그 하위) 요청에서만 쿠키가 보내지기 때문에 모든 url에 대해 쿠키를 보내고 받고 싶다면

setPath("/")로 지정해서 쿠키를 생성해야 한다.

결론은 새로 생성하는 쿠키는 요청 url을 path값으로 갖는데, 그렇게 생성되고 이후 보내지는 쿠키에는 스펙상 path값을 포함하지 않는다.

따라서 쿠키를 덮어 씌우고 싶으면 path값을 똑같이 맞춰서 addCookie해야 기존의 쿠키가 완전히 덮어진다.

특히 여러 url에서 생성되는 쿠키라면 더더욱 신경써야 한다.




하여튼 이러한 쿠키는 보안상으로 문제가 많기 때문에 중요한 정보를 쿠키에 담아서 저장하면 안 된다.

정말 그냥 화면에 보이는 무언가를 처리하거나 별 거 아닌 내용을 다룰 때 쓰는 게 좋다.


그래서 우리는 조금 중요한 내용을 담을 때에는 쿠키 대신 세션이라는 것을 사용할 수 있다.

물론 세션도 보안적으로 완벽한 건 아니기 때문에 쿠키 보다 낫다는 것이지 세션이 최고라는 게 아니다.

사실 세션도 쿠키를 이용하는 하나의 개념일 뿐이다.

대신 쿠키값은 말 그대로 클라이언트와의 연결을 위한 값으로서 사용하고 

사용에 필요한 데이터는 서버가 갖는 방식으로 동작하는 것이다.


세션을 생성하게 되면 세션에 데이터를 저장할 수 있게 된다.

저장하는 데이터는 서버가 갖고 있게 되고, 클라이언트에게는 쿠키를 하나 보낸다.

이 때 쿠키에 담긴 데이터는 알 수 없는 복잡한 해시코드값이다.

사용자에게 보내지는 쿠키에는 이 해시코드값이 담겨져 있는 것이고 서버는 sessionId로 이 값을 갖는다.

나중에 클라이언트가 요청을 할 때에 이 쿠키를 보내게 되고, 서버는 그 값을 sessionId와 확인해서 매핑되는 게 있는 지 확인한다.

만약 값이 일치하는 sessionId가 있다면 그 세션 정보를 사용할 수 있도록 동작한다.


세션이라고 크게 특별한 게 아니다.

그냥 쿠키라는 개념을 이용해서 서버가 데이터를 저장하는 식으로 동작하게 하는 방법일 뿐이다.

이것도 결국은 쿠키 개념을 이용해 java코드로 만든 하나의 동작 개념일 뿐이다.



세션은 핸들런 메소드의 인자로 받을 수 있다.

그럼 request를 받아서 getSession을 하지 않아도 되기 때문에 편리하다.

근데, session을 받아온 다음 결국은 또 getAttribute를 해야 하는데 핸들러 메소드에는 이를 한 번에 해 주는 어노테이션이 있다.

바로 @SessionAttribute이다. 

이 어노테이션을 사용하고 옵션을 적어 주면 그 속성값에 맞는 데이터를 바로 인자로 넘겨 준다.

@SessionAttribute(name = , required = ) 이런 옵션이 있다.

name은 setAttribute할 때 넣은 속성 이름을 적어 주면 된다. 

required는 세션이 필수 인자인 지 아닌 지를 적어 주는 것이다.

우리가 request.getSession() 메소드를 사용하면 사실 인자 중에 true가 들어간 것과 똑같이 동작한다.

여기서 인자에 들어가는 boolean값은 세션이 없을 경우 새로 생성하느냐 마느냐 에 대한 값이다.

getSession은 요청이 올 때 세션이 있으면 그 세션을 반환하고 없으면 새로 만드는 메소드이다.

하지만 이 때 false값을 인자로 넘기면 세션이 없으면 그냥 null을 반환해 준다.

required에 false가 지정되면 세션이 없을 경우 null을 반환할 수 있도록 하는 옵션이다.

@SessionAttribute는 기본적으로 세션을 새로 생성하지 않게 되어 있기 때문에 만약 required가 true이면

사용자가 세션이 없을 경우 그냥 예외를 던져 버린다.




세션에는 타임아웃이라는 중요한 개념이 있다.

세션 id를 계속 똑같이 유지하는 것은 썩 좋은 방법은 아닐 것이다.

보안상의 문제도 있고, 서버가 데이터를 보관하는 방식이기 때문에 계속 남아 있으면 서버의 메모리가 힘들어한다.

그래서 세션을 일정 시간이 지나면 삭제되도록 만들면 된다.

근데, 단순히 일정 시간을 지정해서 생성하면 딱 그 시간이 지나면 없어져 버린다는 것이다.

도중에 사용자가 다른 요청을 마구마구 해도 결국은 정해진 시간이 지나면 세션이 만료된다는 것이다.

이러한 것을 막기 위해서 인터셉터나 필터를 만들어서 요청이 올 때마다 세션을 유지해 주면 된다.

즉, 사용자의 마지막 요청을 기준으로 시간을 계속 재설정 하는 것이다.

크게 어려운 내용은 아니지만 이 방법을 직접하기에는 조금 귀찮을 수도 있는데

스프링은 설정으로 이것을 적용할 수가 있다.

application.properties파일에 server.servlet.session.timeout=값(초 단위)를 적어주면 된다.

이렇게 하면 세션의 타임아웃을 글로벌하게 적용할 수 있다.

단점이라고 하면 글로벌 타임아웃 설정은 분 단위로밖에 하지 못한다는 것이다. (1분, 2분...)

그래도 이정도면 아주 훌륭한 설정인 듯 하다. 잘 사용해 보자.
