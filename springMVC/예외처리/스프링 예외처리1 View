






스프링의 동작방식은 WAS -> Filter -> Servlet -> Interceptor -> Handler 순으로 작동하는데 

이 때 도중에 예외가 발생하게 되면 역순으로 예외를 던지게 된다. 

이 과정 중 예외가 Front Controller(dispathcerServlet)에 던져질 때, 

프론트 컨트롤러는 예외를 처리하기 위해 등록된 ExceptionResolver가 있는 지 확인하고 없으면 다시 던지게 된다.

이렇게 계속 던지게 되어 결국 WAS까지 넘어가면 WAS에서는 예외에 대한 처리를 하기 위해 에러페이지를 위한 재요청을 보낸다.


( sendError()를 통해 예외를 보내는 것은 Http상태코드에 바로 상태코드를 지정하는 형태이고, 

WAS에 response가 도착해서 sendError가 호출되었는 지를 확인하기 전까지는 에러에 대해 모른다.

sendError()와 같은 상태코드 변경 처리도 예외가 중간에 처리되지 않고 WAS까지 도착한 것과 똑같이 동작한다. 

setStatus와 sendError는 엄연히 다르다. WAS는 재요청을 할 때에 sendError가 호출된 적이 있는 지를 기준으로 하기 때문에

setStatus를 통해서 http상태코드를 바꾸는 것은 재요청과 관계 없이 그냥 상태코드만 바뀐 상태로 사용자에게 응답된다. 

즉, setStatus는 정상흐름인데 의도적으로 http상태코드를 변경한 것으로 인지한다는 것이다. )  


재요청 과정은 Server에 등록되어 있는 ErrorPage객체를 참조하여 url을 서버 내부적으로 다시 요청하는 방식이다. 

이 객체는 '예외정보와 url정보' 또는 '상태코드와 url정보'를 넘겨서 생성되기 때문에 

WAS에 넘겨진 예외나 snedError를 통한 상태코드에 따라 특정 url을 호출하는 형태로 동작할 수 있는 것이다.


이러한 예외정보,상태코드에 따른 url정보를 갖는 ErrorPage객체는 우리가 직접 만들어서 커스터마이징이 가능하다.

커스터마이징 방법은 spring에서 커스터마이징을 위한 WebServerFactoryCustomizer를 제공하는데 이 인터페이스를 implements해서

customize 메소드를 구현하고 안에 ErrorPage객체를 생성하면 된다. 

그리고 생성한 ErrorPage객체를 인자로 받은 factory객체를 이용해서 factory.addErrorPage()메소드를 호출해서 넣어 주면 된다.

이렇게 생성한 클래스를 빈으로 등록하면 동작한다.

이 ErrorPage객체는 서블릿 컨테이너에서 직접 참조하게 된다. 그럼 재요청시에 url처리를 ErrorPage객체에 등록된 대로 하게 될 것이다.

# 스프링 부트가 우리의 커스터마이징 설정 정보를 보고 컨테이너에 객체를 넘긴다고 한다.

그리고는 ErrorPage객체들에 등록한 url로 재요청이 왔을 때 처리를 위한 컨트롤러도 하나 만들어 주면 된다.

# 글로만 봐서 이해가 잘 안 되면 자세한 등록 방법은 인터넷에 검색하거나 김영한 씨의 '스프링 MVC2 - 오류 화면 제공'강의를 보자.


근데 이 때 필터나 인터셉터는 어떻게 될까??

인터셉터의 경우는 배제 경로를 지정할 수 있으니 매핑한 예외처리 url을 배제하면 된다.

필터의 경우는 DispatcherType이라는 걸 지정할 수 있는데, request,forward,error 등 서버에서 요청에 대한 타입에 따라 

DispatcherType이 지정되어 요청된다. 필터에는 이러한 DispatcherType을 설정하는 메소드가 있는데 그 메소드를 통해

DispatcherType을 지정하면 그 DispatcherType을 가진 요청에 대해서만 필터가 작동하도록 할 수 있다.



우리가 직접 url을 커스터마이징 하고 url에 대한 컨트롤러와 에러페이지를 직접 만들어 주어야 한다는 것은 귀찮은 일이다.

어차피 이런 작업은 프로젝트마다 거의 모든 공통사항이고, 어차피 똑같이 만들 건데 매번 해 줘야하는 귀찮은 일에 불과하다.

그래서 스프링 boot의 경우에는 기본적으로 Server의 DispatcherType Error에 대한 재요청 url을 /error로 매핑시키고 

각 에러코드에 대한 url처리를 할 수 있는 컨트롤러인 BasicErrorController라는 것을 재공해 준다.

이 말은 우리가 url을 따로 직접 커스터마이징할 필요 없이 리소스에 /error라는 디렉토리를 만들고 거기에 에러페이지만 만들면 된다는 것이다.

그럼 특정 예외가 발생했을 때 WAS로 넘어오면 BasicErrorController에 의해 재요청된 url을 알아서 컨트롤 해주고

우리가 만들어 놓은 /error 디렉토리의 View리소스들에 자동으로 연결 시켜준다는 것이다.


그래서 우리는 스프링 부트를 사용해서 사용자에게 에러 페이지를 보여줄 때에는 그냥 /error 디렉토리를 만들고

거기에 에러페이지만 만드는 형태로 사용하면 된다. 

이때 각 에러코드에 따른 error페이지 이름이 정해져 있는데, 상태코드 이름으로 페이지 이름을 적으면 된다.

예를 들어 404 에러면 /error/404.html이 될 것이다. 

그리고 만약 특정 에러페이지를 전부 만들기 싫고 그냥 하나에 통일 되면 좋겠다면 

4xx이런 형태로 만들어 두면 400대와 관련된 상태코드는 4xx.html로 가게된다.

즉, 404에러가 터졌는데 404.html이 없는 경우에 default가 되는 페이지인 것이다.


이 때 만약에 template/error에 위처럼 등록한 html파일이 없을 경우 static디렉토리의 /error 디렉토리를 뒤진다.

근데 이렇게 했는데도 못찾으면 template/error.html이 있는 지 확인하고 있다면 그 파일을 View로 없으면 

다시 예외가 발생하고 또 재요청이 되면서 기본 예외 페이지를 호출한다.


참고로 상태코드에 따른 처리가 아닌 예외발생으로 인한 처리는 기본적으로 다 500에러로 통일한다.

그렇게 하기 싫으면 커스터마이징을 통해 몇 개 등록해 주는 것도 좋지만 굳이 그럴 필요까진 없어 보인다.

어차피 뒤에 가면 더 좋은 예외처리 방법이 나오기 때문에 그 걸 사용하면 되기 때문이다.












