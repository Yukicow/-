





트랜잭션 부분을 배웠다면, 또는 배우지 않았다고 해도

Service객체에서는 어떤 특정 기술에 의존적이어서는 안 된다는 것을 알 수 있을 것이다.

순수히 자바코드로 이루어진 비즈니스 처리 로직만이 담겨야 이상적인 Service라고 볼 수 있다.


이 때 트랜잭션의 마지막을 보면 다 비즈니스 로직만 남게 처리한 것 같아 보이지만 사실 문제가 하나 있다.

바로 예외처리이다.

예외 처리를 보면 throws를 통해 예외를 던지고 있는 것을 볼 수 있다.

repository나 다른 Service 객체에서 사용하는 의존 객체들에서 넘어오는 예외를

Servcie가 받아서 Controller로 넘기고 있는 형태를 띄고 있다는 것이다.

이것은 Servcie로 예외가 넘어오는 것에 국한되는 문제가 아니다.

repository의 구현체에서 예외를 넘긴다는 것은 인터페이스도 특정 예외처리에 의존적이게 된다는 뜻이다.


이 부분을 해결하기 위해서는 Checked Exception과 UnChecked Exception을 이해하고 있어야 한다.

UnChecked Exception의 경우는 처리 과정을 생략하면 자동으로 throw 되기 때문에 사실 문제가 없다.

하지만 Checked Exception에서 문제가 발생한다.

Servcie 객체의 의존 객체들에서 넘어오는 Checked Exception이 특정 기술에 의존적인 Exception일 수 있다는 것이다.

예를 들어 repository에서 JDBC 기술을 사용하는데, 이때 SQLException이라는 게 발생할 수 있다.

이 예외는 Checked Exception이다. 

그런데, 이 SQLException은 JDBC 기술에 의존적인 예외이다. JDBC 기술을 사용할 때에만 발생하는 예외라는 것이다.

우리가 만약 JPA를 사용하는 repository로 바꾼다면 만날 일이 없는 예외이다.

이럴 경우 throw나 예외처리를 다시 소스코드로부터 변경해야 하는 일이 발생한다.

또, 인터페이스는 JPA를 사용하는 repository를 위해서 또 새로운 예외에 의존적이게 된다.


그래서 이런 일을 해결하기 위해 우리는 이런 Checked Exception을 Service 객체로 넘어오기 전에 잡아서 해결하거나

미리 전의 객체들에서 잡은 뒤 RuntimeException(Unchecked Exception)으로 바꾸어 던지도록 하는 방법을 사용한다.

이렇게 하면 의존 객체에서 Checked 예외가 발생해도 Servcie객체로 던져지는 예외가 UnChecked로 넘어오니,

Servcie 객체에서는 예외처리에 대한 부분을 신경쓰지 않아도 되게 된다. 알아서 throws 되기 때문.

물론 Service 객체에서 처리할 수도 있지만 그건 의존적인 로직이기 때문에 Service 객체에서 처리해서는 안 된다.

정말 비즈니스 로직상 중요한 예외의 경우만 따로 캐치해서 처리한다고 한다.


그리고 이러한 예외를 넘기는 것에서 문제가 있는데,

단순히 Checked예외가 발생했을 때, RuntimeException으로 던지기만 하면 끝나는 문제면 다행인데,

그렇게 되면 각 문제에 대한 예외를 구분할 수가 없어진다.

예를 들면 특정 상황에서는 예외를 받아서 처리하고 싶은데, 

RuntimeException으로 변환하는 과정에서 실제 예외와는 크게 관련 없는 예외로 던질 수 있기 때문이다.

그래서 문제 상황에 대한 구분이 불가능하다.


다행히도 데이터베이스에서 예외가 발생하면 데이터베이스는 에러코드를 넘기는데,

이 에러코드는 예외에 담겨 있기 때문에, 우리가 이 에러코드에 따라서 특정 예외를 던지는 로직을 만들 수 있다.

# 예를 들어 JDBC사용 중 SQLException발생 시 그 예외 안에 에러코드가 담겨 있음

또 스프링에서 제공하는, DB에 대한 예외들이 있기 때문에 

우리는 에러코드와 이 예외들을 이용해서 예외를 잡은 다음 스프링 제공 DB 예외로 throws 하면 된다.

하지만 각 데이터베이스마다 에러코드도 다르고, 우리가 직접 에러코드에 따라서 던지는 예외 코드를 하나하나 작성해 주어야 한다.


그래서 Spring은 여러 가지 exceptionTranlator라는 것을 제공해 준다.

그 중 하나를 예로 들면 우리가 예외가 발생했을 때 그 예외를 인자로 넘기면 

거기에 저장된 에러코드에 맞는 spring의 특정 예외를 자동으로 반환해 주는 녀석이 있다.

이러한 각각의 db마다 다른 에러코드에 대한 매핑 정보는 Translator가 참조하는 xml 파일이 따로 존재한다.

하여튼 우리는 덕분에 예외가 발생하면 Translator에 예외를 넘기고 받은 예외를 throw하면 된다.

그럼 우리는 특정 로직 수행 중 발생하는 특정 예외에 대해서만 처리하고 싶다면 그 예외에 대해서만 따로 캐치해서 처리하는 게 가능해 진다.

물론 이것도 스프링에서 제공하는 예외에 의존적이게 되지만, 사실상 스프링을 안 쓰게 되는 것이 아닌 한은 문제가 없고,

정 스프링에 의존적인 게 싫다면 직접 예외 클래스와 Translator를 쳐 만들어서 사용해도 상관은 없다.

(Translator는 jdbc기술과 jpa를 사용할 때에 각각 다른 Translator가 존재한다.)

# Translator의 구현체에는 사실 에러코드 뿐만 아니라 status? 뭐 이런 걸 보고 해석하는 구현체도 있다.




