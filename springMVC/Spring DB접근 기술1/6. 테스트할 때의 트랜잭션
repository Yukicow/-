





우리가 DB를 이용할 때에 테스트를 어떻게 해야 할까?

그냥 단순히 원래 있는 DB를 테스트할 때에도 사용하면 기존의 데이터들이 테스트를 하는 데에 방해가 된다.

쉽게 말해서 격리성을 보장하지 않는다는 것이다. 또, 트랜잭션 문제도 있다.

이걸 해결하기 위한 방법이 여러 가지 있고, 점점 진화되어 왔는데 어떻게 발전했는 지 보자.


먼저, 첫 번째는 가장 누구라도 떠올릴 수 있는 테스트용 DB를 만드는 것이다.

test 디렉토리에 application.properties 파일을 만들고 거기에 테스트에서 사용할 DB정보를 적으면 된다.


그럼 트랜잭션 처리는 어떻게 하는가?

트랜잭션 처리는 TransactionManager를 이용해서 BeforeEach에서 getTransaction()으로 트랜잭션을 시작하고 

AfterEach에서 rollback()을 이용해서 각 테스트를 실행할 때마다 롤백처리를 하도록 하면 된다.


위의 방법도 충분히 간편하고 좋지만, 스프링은 더 편한 기능을 제공해 준다. 

바로 @Transaction이다. 

일반 웹앱 실행 환경에서 @Transaction을 사용하면 문제 없이 로직 수행 시 자동으로 커밋이 되도록 돼 있지만

Test 환경에서 @Transaction을 사용하면, 각 테스트 마다 실행 후 rollback을 수행하도록 하는 기능이 있다.

원하는 Test에만 @Transaction을 적어도 되고 클래스 단위로 적어서 모든 테스트에 적용해도 된다.

또, 만약 rollback되는 게 싫고 눈으로 확인해 보고 싶을 때에는 클래스나, 메소드 위에 @Commit을 적어 주면

@Transaction에 의해 트랜잭션 처리를 마친 후 rollback이 아닌 Commit처리를 한다.



그럼 이제 다 끝난 건가? 싶다.

db도 분리했고 트랜잭션도 문제 없다.

트랜잭션은 더 쉬워질 방법이 없어 보이는데, db 분리는 조금 귀찮다.

우리는 db분리를 좀 더 쉬운 방법으로 처리할 것이다.

임베디드 모드라는 것을 사용할 것이다.

자세한 사용법 어차피 뒤에서 더 쉬워지니 인터넷이나, 김영한님 강의를 보고 내용만 설명하겠다.


임베디드 모드란, 마치 라이브러리 처럼 db가 웹 어플리케이션과 함께 런타임에서 메모리 상에 함께 올려져서 

메모리 위에서 db가 동작하도록 하는 기능이다.

그렇기 때문에 서버가 다운되면 함께 모든 내용이 지워진다.

실제 배포 환경에서는 ㅈ도 쓸모 없겠지만, 마치 테스트할 때에는 좋아 보인다.

그래서 테스트할 때에 임베디드 모드를 사용하는 것이다.


하지만 임베디드 모드를 사용하려면 DataSource를 직접 등록하고 테이블 생성에 대한 내용도 따로 작성해야 하기 때문에

이것 조차도 꽤나 번거롭다는 문제가 있다.

하지만 스프링은 이걸 자동으로 지원해 준다.

그냥 아무 것도 건들지 않고(DataSource 등록 없이) 테스트 환경에서 테스트를 실행하면 자동으로 임베디드 모드로 db를 실행한다.

알아서 데이터베이스 url과, user,password를 생성하고 임베디드 모드로 db를 띄워 준다.

우리는 생성할 테이블에 대한 쿼리문만 작성해 놓으면 된다.

이것은 규칙이 있다. test의 resource디렉토리에 schema.sql이라는 파일을 만들고 

거기에 우리가 원하는 테이블 생성 쿼리문을 적어 두면 메모리 상에 올라갈 때 그걸 참고해서 테이블을 생성한다.



