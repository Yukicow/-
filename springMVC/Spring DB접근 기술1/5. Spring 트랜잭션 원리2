




그럼 이제 템플릿을 사용하면 우리는 끝나는 것일까?

그렇지 않다.

궁극적으로 나눠지는 Controller - Service - repository 관계에서 Service는 

특정 기능에 의존적이어서는 안 된다.

순수한 자바코드로 비즈니스 로직만을 수행하는 역할을 해야 하는 것이다.

물론 그렇게 짜는 것이 이상적이고 옳다는 것이지, 완벽히 그렇게 할 수는 없을 지도 모른다.

하지만 현재 상황에서 우리가 템플릿을 사용함으로써, 주요한 비즈니스 로직이 아닌,

'트랜잭션 처리'라는 부가 요소가 Service객체에 포함되게 된 것이다.

'트랜잭션 처리'는 주요 비즈니스 로직이 아니다. 

그저 비즈니스 로직 수행 과정에서 트랜잭션의 원자성이 지켜지게 하기 위해 부가적으로 동작하도록 하는 요소인 것이다.

쉽게 말하면 선택 사항(?)에 해당한다고도 볼 수 있다. 

# ㅈㄴ 중요해서 거의 필수긴 함

비즈니스 로직이라 함은 필수사항(? 비유가 이게 맞나)이라고도 볼 수 있다.

즉, 비즈니스 로직은 절대 빠져서는 안 되는 것이다.

우리의 웹앱이 동작하는데 필수적인 요소이고, 우리가 원하는 동작(기능)을 수행하기 위한 절대적인 코드들이다.

근데, 트랜잭션 처리는 물론 아주아주아주 중요한 것이기는 하지만, 이게 없어도 기능은 동작한다.

동작에 문제가 있을 수 있을 뿐.

결국 우리가 트랜잭션 처리를 하기 싫으면 안 해버릴 수도 있다는 것이다.

(실제 그럴 일이 있어서는 안 되겠지만)

하여튼 비즈니스 로직과 부가적인 내용에 대한 비유를 하기 위해서 그렇다는 것이다.



글이 길어졌는데, 요점은 이거다.

위의 템플릿 사용을 해서 확실히 비즈니스 로직이 부각되도록 서비스 객체의 로직이 단순해졌지만

아직 잡티가 조금 남았다는 것이다.

저런 잡티도 완전히 제거할 줄 알아야 우리는 완벽한 서비스 객체를 구현해야 지리는 개발자가 될 수 있다.

그럼 위와 같은 상황에서 불필요한 부가 로직을 어떻게 해야 없앨 수 있을까..

바로 트랜잭션 처리를 AoP를 통해서 구현하는 것이다.

서비스 객체에는 말 그대로 비즈니스 로직만을 두고 트랜잭션 처리는 AoP를 구현해서 

AoP 프록시 객체가 서비스 객체에 있는 비즈니스 로직만 쏙 빼가서 실행하고 

나머지 트랜잭션에 대한 부분은 프록시 객체에서 비즈니스 로직 실행 전후로 처리하도록 하는 것이다.



우리가 AoP를 배웠다면, 위의 AoP객체를 직접 만드는 건 사실 크게 어려운 일이 아니다.

그저 템플릿 부분만 AoP객체를 만들어서 전후로 쳐 넣으면 되니까.

하지만, 나는 아직 AoP를 제대로 안 배웠고, 스프링에서 제공하는 지리는 기능이 있는데, 굳이 만들 이유가 없다.


스프링에서는 이런 트랜잭션 AoP를 제공하는데 @Transactional 이라는 어노테이션을 사용하면 된다.

서비스 객체에서 Transaction처리가 필요한 메소드에 @Transactional 어노테이션을 달아주면

그 메소드를 실행하는 로직이 있으면 프록시에 감싸서 트랜잭션 처리와 함께 수행되도록 도와 주는 어노테이션이다.

메소드 대신 클래스 단위로 어노테이션을 사용하면 public 메소드에 모두 @Transactional이 붙은 것으로 간주한다.


이 AoP는 기본적으로 TransactionManager를 이용해서 동작한다.

그렇기 때문에 @Transactional을 사용할 때에는 어떤 TransactionManager를 사용할 지 지정해 주어야 한다.

만약 지정하지 않으면 기본으로 등록된 TransactionManager를 사용한다.

AOP를 이용해서 실제 비즈니스 로직이 수행되기 전에 Transaction을 얻고 수행 후 commit과 rollback을 처리해 준다.

스프링 부트에서는 기본적으로 TransactionManager를 등록해 주는데, 

사용하는 라이브러리를 보고 그에 맞는 TransactionManager를 알아서 등록해 준다.

인터페이스 PlatformTransactionManager라는 녀석을 등록해 주는데 그냥 TransactionManager라고 생각하면 된다.

(원래 TransactionManager라고 이름을 짓고 싶었는데, 이미 먼저 어딘가에서 사용해서 Platform을 붙인 것이라는 썰이 있다.)

이 PlatformTransactionManager에는 DataSourceTransactionManager, JpaTransactionManager 등등 실제 구현체가 들어 있을 것이다.


그럼 나중에 Jpa와 Jdbc 템플릿, 마이바티스를 함께 사용한다고 하면, 어떤 트랜잭션 매니저를 사용해야 할까?

그럴 때에는 그냥 JpaTransactionManager만 등록해서 사용하면 된다.

JpaTransactionManager도 결국은 내부적으로 DataSource와 JDBC 기술을 이용하기 때문에 다른 기술 스택의 기능을 거의 지원한다.







내용은 다 끝났고 이제 조금 설명이 부족했던 내용을 추가로 말하면

일단 위의 내용들은 DataSourceTransactionManager의 동작원리이다.

다른 TransactionManager는 동작원리가 조금씩 그 형태에 맞게 다르게 구현되어 있지만 크게 다르지 않다는 듯 하다.

예를 들어 DataSourceTransactionManager는 JDBC 기술을 사용하는 경우에 동작할 수 있다.

DataSource 자체가 JDBC, 커넥션 풀과 같은 JDBC 방식을 이용한 Connection을 불러오는 방식이니 

DataSource를 이용해서 트랜잭션 처리를 하니 당연한 내용이다.

DataSourceTransactionManager 말고도 예를 들면 JpaTransactionManager, HibernateTransaction 등이 있다.

Jpa를 사용하는 경우에 트랜잭션 처리를 위해 사용될 수 있다.

다른 TransactionManager는 어떻게 동작하는 지는 모르겠지만, 거기서 거기이지 않을까 싶다.



결론

트랜잭션의 진화 과정을 한 흐름에 정리하면


1. DriverManager 직접 사용

문제점 : 반복, 가독성, 커넥션 풀과 호환 안 됨,Service객체의 비즈니스 로직 외 코드 포함



2. DataSource를 이용해 직접 프로그래밍으로 설정 기능을 하나하나 작성하여 로직 처리

-> DriverManagerDataSource를 사용하며, 커넥션 풀을 구현하는 객체들과 DataSource인터페이스로 호환

문제점 : 반복, 가독성, Service객체의 비즈니스 로직 외 코드 포함


3. TransactionManager를 사용 

-> 커넥션을 공통 사용하여 불필요한 코드(connection을 인자로 받는 오버로딩 메소드 등) 감소 

문제점 : JDBC기술에 대한 코드 반복, 가독성, Service객체의 비즈니스 로직 외 코드 포함 문제.


4. Transaction 템플릿, JDBC 템플릿 등 사용 

-> 트랜잭션에 대한 반복 코드 감소, JDBC 기술에 대한 코드 반복 감소, 가독성 증가

문제점 : Service객체의 비즈니스 로직 외 코드 포함.


5. AoP 사용

-> Service객체의 비즈니스 로직 외 코드 포함 문제 해결.

문제점 : X





사실은 아직도 마지막 문제가 남았는데, 이건 예외처리와 관련된 내용이니 

예외 처리 관련 부분에서 알아보도록 하자.