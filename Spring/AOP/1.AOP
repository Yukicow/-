





AOP(Aspect Oriented Programming)

관점지향 프로그래밍


사용자측에서 바라보는 비즈니스적 로직이 아니고 그러한 비즈니스 로직을 개발하는데 부가적으로 필요에 의해 포함되는 로직들이 있을 것이다.

이러한 보조 로직에는 로깅,보안 등이 포함되는데 이러한 로직들은 OOP 관점에서는 주요 로직이 아니기 때문에 중요 관심사는 아니었다.

하지만 이러한 중요 관심사과 부가적인 관심사를 그 관점에 따라 각각 모듈화 하겠다는 관점의 프로그래밍 기법이다.


즉, 핵심적인 관점뿐 아니라 부가적인 관점에 해당하는, 여러 곳에서 쓰이는 공통 기능을 모듈화하고, 쓰이는 곳에 필요할 때 연결함으로써, 

유지 보수 혹은 재사용에 용이하도록 프로그래밍 하는 것이라고 할 수 있다.


핵심적인 관점: 개발자가 적용하고자 하는 핵심 비즈니스 로직

부가적인 관점: 핵심 로직을 수행하기 위해 필요한 DB연결(JDBC), 로깅, 파일 입출력 등


AOP는 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법이다. 

핵심 기능과 공통 기능의 구현을 분리함으로써 핵심 기능을 구현한 코드의 수정 없이 공통 기능을 적용 할 수 있게 만들어 준다.



AOP 예시를 들 때 많이 사용하는 것이 시간측정이다.

예를 들어 우리가 비즈니스 로직에 대해서 걸리는 시간을 측정하는 로깅에 대한 로직을 추가 하려면

비즈니스 로직 위아래로 소스코드를 추가하여 작성하는 형태로 구현할 수도 있다.

하지만 이럴 경우 문제가 참 많다. 모든 비즈니스 로직에 이러한 소스코드를 추가해야할 뿐만 아니라(중복 증가)

나중에 다른 기능으로 테스트 해 보고 싶을 때에는 모든 소스코드를 수정해야 한다.(유지 보수성 감소)

심지어는 소스코드가 없는 경우에는 추가가 불가능하다.


그래서 이러한 문제점을 해결하고자 비즈니스 로직과 이러한 부가적인 관점에 해당하는 로직을 구분하여 모듈화 하는 것이다.


이러한 AOP의 구현을 java에서 제공하는 proxy 객체를 이용해서 해 보고

그 다음에는 Spring에서 제공하는 기능을 이용해서 구현해 보도록 하자.


proxy는 영어로 대리,대리인 등을 뜻한다.

뜻에서도 알 수 있듯이 proxy는 우리가 실제로 생성해서 사용해야 할 객체의 대리 역할을 한다.

예를 들어 우리가 생성해서 사용해야할 비즈니스 로직을 포함하는 객체가 Exam 객체라면

proxy 객체를 만들어 통해 Exam객체의 기능을 대신해서 사용하는 것이다. 


먼저, Proxy 객체를 만들 것이다.

Proxy.newProxyInstance() 메소드를 통해 생성할 수 있다.

이 메소드는 3개의 인자를 필요로 하는데 우리가 구현하고자 하는 클래스의 클래스 로더와 인터페이스 배열, 그리고 InvocationHandler 객체이다.

아마도 이렇게 받은 인자를 통해 Proxy 객체를 생성해 주는 듯 하다.

Proxy 객체는 우리가 인자로 넘긴 인터페이스의 형태 중 하나로 타입캐스팅이 가능하다.

Proxy 객체 자체가 우리가 사용하려는 객체가 되는 것은 아니다. 그 객체의 기능만을 할 수 있을 뿐.

아마도 Proxy 객체를 생성하기 위한 메소드에 넘긴 인자들을 통해 실제 Proxy 객체가 그 클래스의 객체처럼 작동할 수 있는 것 같다.


다른 클래스 로더나 인터페이스는 그렇다 치는데 InvocationHandler는 조금 생소하다.

InvocationHandler는 인터페이스이다. 이 인터페이스를 구현하는 객체를 인자로 받는 것인데,

이 인터페이스는 함수형 인터페이스로 invoke라는 메소드를 구현하고 있다.


이 invoke 메소드가 실제로 우리가 proxy 객체를 통해 특정 메소드를 호출했을 때 실행되는 로직이 담기게 되는 곳이다.

함수형 인터페이스이기 때문에 익명 객체를 통해 바로 생성해서 넘길 수 있다. (람다식을 사용해도 편하다)


이 invoke 메소드는 3개의 인자를 필요로 한다. 이것들은 proxy 객체를 통해 우리가 특정 메소드를 호출하면

내부적으로 자동으로 넘어가는 인자들인 듯 하다.

메소드가 호출된 proxy객체 즉, 우리가 생성한 proxy 객체와 Method 객체, 

우리가 호출한 메소드에서 필요로 하는 인자들을 Object 형태로 배열에 저장한 Object 배열을 매개변수로 갖는다.

우리는 이 invoke 메소드 안에 보조 로직(Cross-cutting Concern)에 대한 내용을 작성해 주면 된다.

단 이 때 보조 로직을 작성한다고 끝나는 게 아니고 실제 주요 로직이 중간에 함께 수행되어야 하는데

그것을 넣어 주어야 한다. 이 때 사용하는 게 invoke 메소드의 인자로 받은 method객체이다.

method객체는 invoke 메소드를 갖는데 이 메소드가 우리가 proxy 객체를 통해 호출한 메소드와 매핑되는 

실제 클래스에 정의된 메소드 로직을 수행하는 녀석이다.

이 method 객체의 invoke 메소드는 실제 주요 로직을 갖는 객체를 인자로 받는다. 

# 아마도 실제 주요 로직을 갖고 있는 객체를 인자로 받아서 그 객체에서 메소드를 찾아 호출하는 듯 하다.

그리고 그 객체의 주요 로직을 호출할 때 필요한 인자들도 인자로 받는다.

# 객체의 메소드를 실행하는데 필요한 인자들이 있을 수 있으니 당연히 필요하다.

객체는 우리가 생성해서 넣어 주면 되고 인자는 invoke 메소드가 인자로 받은 인자를 그대로 넘기면 된다.


Proxy.newProxyInstance() 에서 Class loader에 담기는 것은 우리가 두 번째 인자로 넘기는 

Interface를 구현하는 클래스의 클래스로더 또는 interface의 클래스 로더를 넘기면 된다.

두 번째 인자는 인터페이스들을 배열로 넘기는 것인데, 꼭 인터페이스여야 한다.

실제 주요 로직을 담고 있는 클래스가 구현하고 있는 인터페이스를 넣으면 된다.

# 아마 의존성을 낮추기 위해 구체화가 아니고 인터페이스를 통해 추상화를 강제하기 위함 인듯?

즉, Proxy를 사용하려면 주요 로직을 담고 있는 클래스는 인터페이스를 한 번 거쳐서 구현되고 있어야 한다는 것이다.

세 번째 인자인 InvocationHandler는 위에서도 말했듯이 보조 로직과 주요로직이 담기는 invoke 메소드를 구현하는 인터페이스이다.

람다식을 사용하거나 익명객체를 만들어서 넘기면 된다.



실제 구현한다면 이런 느낌이 될 것이다.

AOPInterface proxy = (AOPInterface) Proxy.newProxyInstance(AOP.class.getClassLoader(), new Class[] {AOPInterface.class}, new InvocationHandler() {
			
			@Override
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				
					System.out.println("before logic");
					method.invoke(aop, args);
					System.out.println("after logic");
					return null;
	    }}); 
		



우리는 이렇게 생성된 proxy 객체를 통해 보조로직을 포함하는 주요 로직을 호출할 수 있다.

proxy 객체는 위에서도 말했지만 실제 수행 객체는 아니지만 그 객체와 똑같이 작동하기 때문에 마치 그 객체처럼 사용할 수 있다.

원하는 메소드를 호출하면 이제 보조 로직을 포함한 주요 로직이 수행되는 것을 볼 수 있다.
