




DI(Dependency Injection)


DI에 대해 설명하기 전에 is-a 와 has-a 의 개념에 대해 알아 보도록 하자.

저것들을 이해하려면 상속과 포함의 개념을 다시 알아보고 갈 필요가 있다.


두 가지 경우의 수가 있다고 해 보자.

A,B,C 클래스가 있는데 B와 C는 A의 기능을 사용하고 싶다.

B는 A를 상속 받기를 선택했고 C는 자신이 멤버변수에 A객체를 포함하기로 했다.

그럼 이제 둘 다 A의 기능을 이용할 수 있다.


근데 상속과 위처럼 객체를 포함하는 형태의 차이점이 무엇일까?


상속은 서로 연관이 있는 것들끼리 상속을 통해 상위 클래스의 기능을 물려 받는 것이다.

그렇기 때문에 결합력이 강하다. 상위 클래스의 로직이 변경되면 상속을 받은 하위 클래스는 고스란히 그 영향을 물려받는다.

C는 특정 C의 로직들이 A를 필요로 하기도 하고 A의 기능에 따라 결과물이 달라지는 형태이다. 

또 A가 C에서 원하는 기능과 완전히 다르게 수정되면 A를 다른 것으로 바꿔야 하는 등 

C가 A에 의존적이기 때문에 의존관계라고 한다. 정확히는 C가 A에 의존적인 상태이다.


예를 들어보겠다.

A는 동물에 대한 클래스이다. B는 동물 중에서도 호랑이에 대한 클래스이고 C는 동물원에 해당하는 클래스이다.

A에는 '먹는다'라는 메소드가 있다. '먹는다' 메소드에는 '동물은 배가 고프면 음식을 먹는다'라는 내용이 담겨 있다고 해 보자.


근데 이 때 A의 '먹는다' 라는 메소드가 바뀌었다.

'동물은 배가 고프면 풀을 먹는다.' 라고 바뀌어 버린 것이다.

이 때 B와 C에게 향하는 영향력이 다르다.


B는 호랑이에 대한 내용을 포함해야 하기 때문에 호랑이가 풀을 먹는다는 것은 말이 이상해 진다. 

따라서 오버라이딩이 필요하게 된다. 결합력이 강하다는 것이다.

하지만 C는 각 동물들이 풀을 쳐먹든 똥을 쳐먹든 알 바는 아니지만 동물원의 모든 동물이 풀을 먹게 되어 풀을 많이 준비해야 할 것이다.

A의 변화에 따라 C의 수행에 영향이 가는 형태인 것이다. 이게 원하는 수행의 형태가 아니라면 문제가 생긴다.

그래서 C는 A에 의존적인 형태라고 한다.


A와 B처럼 'B는 A이다'의 형식을 갖는 것이 is-a이고 A와 C처럼 C가 A를 포함하는 개념이 has-a 이다.

is-a 형태는 결합력이 강한 형태이고 has-a는 is-a에 비해서는 상대적으로 결합력이 느슨하다.



중요한 것은 위에서 is-a과 has-a이 무엇인 지 구분하는 것과 has-a의 의존관계에 대한 내용이다.


프로그래머들은 위와 같은 상황을 원치 않는다. C는 C에 변화가 필요할 때에만 변화가 있어야지

A의 기능을 사용하려고 넣은 것 뿐인데 A의 변화로 C에 영향이 오는 것은 있어서는 안 되는 일이다.

이렇게 C가 A에 의존적이면 안 된다는 것이다. 

그래서 이러한 의존성을 역전하기 위해 Dependency Inversion Principle (DIP) 디자인 패턴(기법)을 사용한다.


Interface -> D를 이용해서 C가 의존하는 대상을 추상화 시키는 것이다.

C가 A를 자신이 포함하도록 할 때에 A가 아니면 안 되는 즉, 구체화를 통한 기법이 아니고

A를 사용하기 위해 다른 중간다리 역할의 인터페이스(D)를 두는 것이다.

C는 A를 사용해도 되지만 A가 변화되거나 다른 무언가를 사용할 필요가 생겼을 때 문제 없이 바꾸는 것이 가능하다.

C의 의존 대상이 D로 추상화 되었기 때문에 A가 아니면 다른 D 형태의 객체를 사용하면 된다.

이런 식으로 의존성의 역전을 시키는 디자인 패턴을 DIP라고 한다.


그리고 has-a에서 C가 A를 포함하는 방식에는 여러 가지가 있을 것이다.

첫 번째 방법은 A를 C의 로직 내에서 new A()를 통해 생성하고 바로 초기화 하는 것이고

두 번째 방법은 외부에서 A에 해당하는 객체를 만들어서 setter나, 생성자에서 인자로 받아 넣어 주는 방식이다.


첫 번째 방법 같은 경우 C가 생성되면 C의 로직에서 생성한 A에 대한 객체를 갖기 때문에 일체형 has-a이다.

그래서 다른 객체를 넣어 주고 싶을 때에는 소스코드의 변경이 필요해 진다.


하지만 두 번째 방법 같은 경우는 A에 해당하는 객체를 직접 생성하여 초기화 하기 때문에 원하는 A객체를 넣어줄 수가 있는 것이다.

첫 번째 방법도 팩토리 패턴을 통해 두 번째 방법과 비슷한 효과를 내기도 한다.


하지만 팩토리 패턴을 사용하는 두 번째 방법을 사용하든 아직도 완전히 문제가 해결되지 않았다.

밑의 로직을 한 번 보자.


Exam ex = new Exam1()
Exam ex = new Exam2()

TestPrinter tp = new TestPrinter1(ex)
TestPrinter tp = new TestPrinter2(ex)


위를 보면 TestPrinter가 Exam에 의존하는 형태이다.

하지만 바뀌는 건 Exam뿐만 아니라 Exam을 받아 수행을 하는 TestPrinter도 때에 따라 바뀔 수도 있을 것이다.

우리는 때에 따라 Exam1이나 Exam2를 사용할 수도 있고 때에 따라 TestPrinter1을 사용할 수도 TestPrinter2를 사용할 수도 있다.

만약 if문을 통해 A요청이 들어오면 TestPrinter1에 Exam1을 넣고 B요청이 들어 오면 Exam2를 넣기로 해 놓았다.

또 요청 C와 D에 대해서는 각각 TestPrinter2를 사용하게 해 놓았다.


근데 사용하다 보니까 TestPrinter2가 너무 안 좋아서 없애기로 했다. 모든 요청에 대해 TestPrinter1을 쓰기로 한 것이다.

또는 반대로 TestPrinter3을 만들어서 TestPrinter2 대신 쓰기로 한 것이다.

그러면 TestPrinter2를 사용하지 않기 위해서는 어떻게 해야 할까.

결국 소스코드를 뜯어서 고치는 방법밖에 없다. 

다르게 말하면 우리가 생성한 객체, 메소드 즉, 우리가 작성한 코드에 대해서 제어의 흐름이 우리에게 있다는 것이다.

이것을 다른 표현으로 '오브젝트는 프로그램 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한다.'

라고도 표현한다. 이런 의존관계에 대한 부분이 소스코드 상(컴파일 시)에서 결정된다는 것이다. 

즉, 객체 자신들에게 필요한 건 자신들이 결정하는 형태라서 오브젝트가 오브젝트를 구성하는 작업에 능동적이라고 하는 것이다.



이런 것을 해결하기 위해 Spring에서는 IoC 컨테이너라는 개념을 사용한다. 그럼 IoC는 무엇일까?

IoC 컨테이너가 나오기 전에 먼저, IOC라는 개념이 등장하였는데 

"프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 프로그래밍 원칙" 이라고 정의 되어 있다.

즉, 우리가 코드를 작성하거나 외부의 라이브러리를 가져와서 사용하는 형태의 내부적인(컴파일 환경) 제어의 흐름을 역전시켜서

외부(런타임 환경)에서 우리가 작성한 코드를 가져다 사용하게 하는 개념. 그것을 Inversion Of Control (IOC)라고 한다.

프레임워크는 이런 IoC의 개념이 적용된 사례라고 할 수 있다.



IOC라는 것은 좀 포괄적이고 넓은 개념이고 디자인 패턴으로 오해하는 경우가 있는데 그렇지 않다. 

위처럼 제어의 흐름을 다른 무언가에게 넘기는 것을 IOC라고 할 수 있다.

여기서 제어란 프로그램의 흐름, 객체의 생성, 의존성을 가진 객체의 생성과 binding 등이 될 수 있다.


조금 쉽게 설명하면 결국은 우리가 작성해서 만들어질 함수나,클래스나,객체들도 결국은 이것들을 사용하고 제어하기 위해서는

코드의 작성이 필요하다는 것이다. 코드를 작성해서 객체의 라이프사이클을 관리하거나 의존관계 등을 제어해야 한다.

이런 능동적인 형태의 제어의 흐름을 바꾸고자 제어를 담당해 줄 '무언가'를 구현해서 그것에게 제어를 위임시키는 것에 

초점을 맞춘 개념이 IOC라고 할 수 있다. 

여기서 '무언가'는 객체가 될 수도 특정 기법이 될 수도 있다? 내가 아직 예시를 잘 몰라서 IoC에 뭐뭐가 있는 지 모른다.

하여튼 '코드를 짜서 만들어 놓을 건데 그걸 이용하고 관리하는 건 우리가 아냐' 이런 느낌이다.


이러한 개념을 적극 차용하여 컴포넌트 종속성 및 라이프사이클 설정, 리소스 등을 외부에서 자동으로 해결해 주는 

IoC Bandwagon라는 게 나왔는데 이 기술이 IoC Container라는 이름으로 알려지게 된다.

즉, 한 마디로 IoC 컨테이너라는 것은 결국 IoC 개념의 구현을 위한 주체가 되는 것이다.

제어를 담당해 줄 '무언가' 에 속하는 녀석 중 하나라고 할 수 있다.


Spring 에서는 IoC 컨테이너라는 것을 이용한다. 

IoC 컨테이너의 말뜻을 조금 정확히 이해하려면 위의 IOC 개념 보다는 Spring에서 한정되는 IoC의 개념을 알 필요가 있다.

Spring Framework의 core 문서에는 IoC를 다음과 같이 정의하고 있다.


"이 챕터에서는 Spring Framework가 IoC를 구현하는 원리를 다룬다. IoC는 DI(Dependency Injection) 이라고도 알려져 있다. 

객체가 자신과 의존관계에 있는 객체를 생성자, 팩토리 메소드의 인자, 객체의 인스턴스가 생성되고 나서 setter에 의해

또는 팩토리 메소드에서 리턴되고 나서 설정된 프로퍼티로만 받는 프로세스(과정)가 IoC다."


즉, 위에서 알아 본 넓은 의미의 IOC와는 다르게 '특정 방법으로 객체의 의존관계를 설정하는 경우'만을 IoC라고 하고 있다. 

그리고 문서에 보면 IoC가 DI라고 불린다고도 말하고 있는데 조금 정리하면 이렇다. 


Spring에서는 IoC를 원래의 의미가 아닌 저렇게 좁은 의미로 사용하고 있는데 심지어는 IoC의 개념과는 조금 거리가 멀기도 하다.

IoC가 아니고 IoC의 구현을 위해 필요한 객체의 형식에 대한 정의에 가깝다.

그렇기 때문에 단순히 IoC라는 단어를 사용하는 것이 사람들에게 혼동을 줄 수 있다.

그래서 몇몇 사람들은 IoC라고 표현하는 것은 너무 폭넓은 의미의 IoC의 개념 때문에

스프링이 제공하는 기능의 특징을 명확하게 설명하지 못해서 다른 말로 표현하는 게 더 적절하다고 판단했다. 

스프링의 궁극적인 기능은 의존관계 설정에 대한 부분에 IOC개념을 더해 좀 더 효율적이고 Control이 자유로운 형태로 만드는 것이고

IoC라는 표현 보다는 실제 Spring의 궁극적 기능에 해당하는 '의존관계 설정'에 기인해서

의존관계 주입(Dependency Injection)이라고 표현하는 것이 어떠냐는 의견이 나왔다.

그래서 IoC, IoC컨테이너라고 불리던 것들이 DI, DI 컨테이너 라고 불리기도 했다.

하지만 합의가 된 내용은 아니라 아직까지는 혼용되어 사용된다.

내가 보기에도 IoC라는 단어는 좀 좋지 않은 것 같다. DI가 더 구체적이고 좋다.


결국 지금은 일반적으로 하위 모듈(의존 관계에 있는 객체)을 생성자, 프로퍼티, 메서드(Setter)를 통해 주입하는것을 DI라 하고, 

설정에 따라 의존관계를 자동으로 resolve 하여 주입해 주는 기술을 통칭하여 DI Framework라고 부르는 듯 하다.


그럼 다시 위의 로직으로 돌아와서 우리는 각 객체들의 의존관계 관리를 직접 해 주어야 했다.

하지만 이러한 관리(흐름)를 다른 무언가에게 넘기면 어떨까? 

우리가 코드상에서 의존관계를 관리하는 것이 아니고 의존관계의 관리를 위임하는 것이다.

그렇게 되면 프로그램의 시작을 담당하는 main() 과 같은 엔트리 포인트를 제외하면 

모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트(또는 로직이 될 수도?)에 의해 결정되고 만들어진다.

그러면 우리는 의존관계 설정에 대한 재사용성과 테스트성, 유지보수력이 훨씬 올라갈 것이다.

즉, 스프링이라는 것은 의존관계의 설정에 대한 부분에 IoC개념을 더한 프레임워크이다.


의존관계를 설정하는 방법이 위처럼 한계점이 있었는데 그 한계점을 보완하고자 IoC 개념을 더해

일반적인 로직의 형태로 의존관계 설정을 할 경우에 대한 한계점을 극복할 수 있게 된 것이다.



이제는 라이브러리와 프레임워크의 차이를 설명할 수 있다.

라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 

단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 

반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 

보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 

개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다. 

즉, 둘 다 남이 작성한 코드를 가져다 쓴다는 것은 다르지 않지만

라이브러리는 그냥 그 기능을 갖다 쓰는 거고 프레임워크는 IOC의 개념이 적용된 것이라고 할 수 있다.

그래서 우리가 라이브러리를 사용했을 때에는 inversion이 일어나지 않기 때문에 우리의 코드가 프로그램의 흐름이 제어하지만

프레임워크를 사용하면 Inversion이 일어나서 프로그램의 흐름이 프레임워크에게로 넘어간다.

그래서 프레임워크의 경우는 프레임워크가 우리의 코드를 가져다 쓴다고 표현하는 것이다.


즉, Spring은 프레임워크에 속하기 때문에 IoC는 당연히 포함되는 개념이다.

그래서 Spring이 DI 컨테이너를 통한 IoC를 제공하기 때문에 특별하다 라고 하는 것은 무리가 있다.

스프링은 프레임워크이기 때문에 당연한 내용이기 때문이다.

애초에 프레임워크라서 그걸 목적으로 설계된 것이고 특별하다라는 말 보다는 

Spring의 기능은 IoC를 통한 의존관계 설정이라고 하는 것이 맞겠다.



DI(의존관계 주입)의 진짜 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다.

제3의 존재는 관계 설정의 책임을 갖는다.

그렇기 때문에 인터페이스에 의존하는 형태를 갖고 있다가 제3자의 영향으로 주입된 객체와 의존관계를 맺는 형식이다.



근데 위에서 첫 번째 방법도 setter를 넣어 주면 되는 게 아닌가요?

그럴 거면 그냥 처음 부터 setter만 사용하는 게 더 효율적이다.

실제로 의존 관계의 변경이 필요한 상황은 거의 없다.

그래서 Spring을 포함한 다른 DI 프레임워크에서도 생성자를 통한 주입을 권장하고 있는데

그렇기 때문에 굳이 default를 초기화해 놓고 요청이 들어오면 바꾸는 건 두 번째 방법의 setter를 사용한 방식과 다를 게 없다. 

오히려 default값이 존재해서 메모리 효율이 나쁠 뿐이다.

요청에 따른 의존관계를 때에 따라 주입해서 결합력을 낮추는 것이냐 아니냐의 문제인 것이다.



