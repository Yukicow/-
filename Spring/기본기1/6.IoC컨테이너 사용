





우리는 전에 xml파일을 통해 컨테이너에게 어떤 객체를 생성하고 주입해 주면 되는 지 설정했다.

그럼 이제 컨테이너를 사용해야 한다.


컨테이너 객체를 만드는 법은 간단하다. Spring에서 제공하는 라이브러리를 사용하면 된다.

메이븐에서 배운대로 라이브러리를 다운 받아서 사용하면 된다. Spring context라는 라이브러리를 사용하게 될 것이다.


다운을 받았다면 이제 객체를 생성하면 되는데

컨테이너 객체에는 여러 가지가 있다.

ClassPathXmlApplicationContext

FileSystemXmlApplicationContext

XmlWebApplicationContext

AnnotationConfigApplicationContext


이 클래스들 모두 ApplicationContext 타입의 객체를 반환한다.

ApplicationContext는 인터페이스이다. 

하여튼 위의 함수들로 만들어진 객체가 우리가 사용하게 될 컨테이너이다.


그래서 각 클래스들의 차이가 무엇이냐 하면 사실 차이는 없다.

반환되는 객체는 결국 같은 것이다.

하지만 ()안에는 들어가는 인자의 방식이 좀 다르다. 

()에는 우리가 작성한 xml파일이 들어가야 하는데 함수들의 각 이름을 보면 알겠지만 

()안에 그 xml파일에 대한 경로를 적어 주는 방식의 차이일 뿐이다.


ClassPath의 경우 프로젝트 내에서 xml파일을 찾아 주기 때문에 패키지명을 포함한 xml파일을 적어 주면 되고

FileSystem의 경우 C드라이브 부터 해서 실제 파일이 위치한 경로를

XmlWeb의 경우 웹에 존재하는 xml파일의 경로

Annotation은 어노테이션으로 하는 거라는데 뒤에서 알아 볼 것이다.


하여튼 이렇게 만들어진 컨테이너를 사용해 보자.

우리가 만든 객체가 잘 주입되었는 지 확인하기 위해서 has-a 객체를 불러와 볼 것이다.

컨테이너 객체의 getBean 메소드를 이용할 것인데 두 가지 방법이 있다.


첫 번째는 xml파일에서 설정한 id를 통해 호출하는 것이다.

예를 들어 위에서 컨테이너 객체를 context 변수에 넣었다고 한다면

context.getBean("xml파일에 설정한 빈의 id") 


두 번째 방법은 데이터 타입을 통해 호출하는 방식이다.

인자로 인터페이스나 클래스를 받는다. 

context.getBean(클래스.class)

이 때 만약 실제 xml파일에 정의한 클래스의 데이터 타입이 아니고 그 객체가 타입 캐스팅 가능한 인터페이스를

인자로 넘겼을 경우에는 자동으로 그 인터페이스로 타입 캐스팅 가능한 객체를 찾아서 반환한다.


위의 첫 번째 방법의 경우에는 만약 getBean이 반환한 객체를 인터페이스 데이터 타입으로 바꿀 때에는 

(타입) context.getBean("xml파일에 설정한 빈의 id")  을 통해 직접 타입 캐스팅 과정이 필요하지만

두 번째 방법으로 한 번에 인터페이스를 인자로 넘겨서 호출하면 그 타입으로 타입캐스팅 되어 반환되기 때문에 

첫 번째 방법 보다 간편해서 많이 애용되는 방식이라는 듯 하다.


하지만 만약 xml파일에 타입캐스팅 가능한 타입의 객체를 여러개 설정해 놓았을 경우에는

문제가 생길 수 있으니 구체화해서 호출해야 한다.


그럼 이제 반환된 객체를 통해 잘 주입이 되었는 지 확인해 보자.
